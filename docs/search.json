[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmierung für Ingenieurinnen und Ingenieure",
    "section": "",
    "text": "Version: 1.1\nWillkommen zu dieser Einführung in die Programmierung! Dieses Skript bildet die Basis für die Vorlesungen „Ingenieurinformatik 1“ und „Grundlagen der Programmierung“ an der Hochschule Trier. Keine Sorge, Vorkenntnisse in Programmierung oder Informatik sind nicht erforderlich!\nWir werden die grundlegenden Konzepte und deren praktische Umsetzung in der Programmiersprache Python erkunden. Der Kurs richtet sich an Studierende der Ingenieurwissenschaften in den ersten beiden Semestern, ist aber auch für Interessierte mit anderen Hintergründen geeignet.\nObwohl Python unsere exemplarische Programmiersprache ist, handelt es sich nicht um einen reinen Python-Kurs. Unser Ziel ist es, ein umfassendes Grundverständnis der Programmierung zu vermitteln: Wie funktioniert sie? Welche fundamentalen Konzepte gibt es in nahezu allen Programmiersprachen und wie können diese genutzt werden, um Probleme zu lösen? Um den Blick für das große Ganze zu bewahren, ziehen wir immer wieder Vergleiche mit anderen Programmiersprachen und vermeiden es, zu tief in die spezifischen Details von Python einzutauchen.\nNach erfolgreichem Abschluss des Kurses werden Sie in der Lage sein, die Themen, die für Ihren persönlichen Weg von besonderer Bedeutung sind, eigenständig zu vertiefen. Das Gelernte wird Ihnen auch ein sicheres Fundament geben, wenn Sie eine andere Sprache als Python lernen müssen (oder wollen). Abschließend sei noch auf den Folgekurs “Ingenieurinformatik II” hingewiesen, der auf diesem Kurs aufbaut und den Fokus stärker auf Anwendung und Problemlösung legt.\nNo one is perfect: Das Skript befindet sich noch im Aufbau und es werden sich leider Fehler einschleichen (wie übrigens auch in jedem größeren Programm). Hinweise bitte an den Autor: m.weber@hochschule-trier.de\nViel Erfolg bei diesem Kurs – oder wie man unter Programmierer*innen sagt: Happy Coding!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Vorwort</span>"
    ]
  },
  {
    "objectID": "notebooks/0-einleitung.html",
    "href": "notebooks/0-einleitung.html",
    "title": "2  Einleitung",
    "section": "",
    "text": "2.1 Was ist Programmierung?\nProgrammierung ist die Kunst und Wissenschaft, Computer dazu zu bringen, bestimmte Aufgaben auszuführen. Dies geschieht, indem man ihnen genaue Anweisungen in Form von Code gibt. Dabei werden Logik, Problemlösungsfähigkeiten und technisches Know-how kombiniert, um Software-Anwendungen, Websites, Spiele und vieles mehr zu entwickeln. Programmieren ist nicht nur eine technische Fertigkeit, sondern auch ein kreativer Prozess, der neue Lösungen für reale Herausforderungen ermöglicht.\nIn der Praxis bedeutet Programmieren weit mehr als nur das Schreiben von Code. Es umfasst das Verstehen von Problemen, das Entwerfen effizienter Lösungen sowie das Testen und Optimieren von Programmen. Gerade in den angewandten Wissenschaften spielt Programmieren eine zentrale Rolle, um praxisnahe Lösungen zu entwickeln – sei es die Automatisierung eines Fertigungsprozesses, die Analyse komplexer Daten oder die Optimierung einer Maschine.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "notebooks/0-einleitung.html#was-ist-programmierung",
    "href": "notebooks/0-einleitung.html#was-ist-programmierung",
    "title": "2  Einleitung",
    "section": "",
    "text": "Exemplarische Anwendungsbereiche der Programmierung\nAutomatisierung: Vereinfachen von Routineaufgaben. \nRobotik: Steuern von Robotern und automatisierten Maschinen. \nDatenanalyse: Analysieren großer Datenmengen. \nKünstliche Intelligenz: Entwickeln von KI-Systemen, z.B. zur Klassifizierung oder Generierung von Bildern.\nCybersecurity: Schützen von Computersystemen und Netzwerken vor Angriffen.\nMedizinische Informatik: Entwickeln von Softwarelösungen für das Gesundheitswesen. \nE-Commerce: Erstellen von Online-Shops und Zahlungsplattformen. \nWebentwicklung: Erstellen und Gestalten von Websites und Webanwendungen. \nSpieleentwicklung: Entwickeln von Computerspielen.\nMobile Apps: Programmieren von Anwendungen für Smartphones und Tablets.\nProgrammieren zu lernen ist vergleichbar mit dem Erlernen einer neuen Sprache: Je mehr Sie üben, desto besser können Sie Ihre Ideen in funktionsfähige Programme umsetzen. Lassen Sie sich dabei nicht von der Vielzahl an Programmiersprachen abschrecken. Ähnlich wie beim Sprachenlernen erleichtert das Wissen über eine Sprache das Erlernen einer weiteren: Wer Spanisch beherrscht, wird sich leichter in Italienisch zurechtfinden. Und selbst bei einer völlig anderen Sprache wie Japanisch profitieren Sie von Ihrer allgemeinen Sprachlernerfahrung. Deshalb beginnt man mit einer ausgewählten Programmiersprache und baut auf diesem Wissen auf, wenn man weitere benötigt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "notebooks/0-einleitung.html#welche-bedeutung-hat-programmierung-für-ingenieurinnen-und-ingenieure",
    "href": "notebooks/0-einleitung.html#welche-bedeutung-hat-programmierung-für-ingenieurinnen-und-ingenieure",
    "title": "2  Einleitung",
    "section": "2.2 Welche Bedeutung hat Programmierung für Ingenieurinnen und Ingenieure?",
    "text": "2.2 Welche Bedeutung hat Programmierung für Ingenieurinnen und Ingenieure?\nProgrammieren ist längst kein reines IT-Thema mehr – es ist ein unverzichtbares Werkzeug für moderne Ingenieurinnen und Ingenieure. Ob Maschinenbau, Elektrotechnik, Mechatronik oder Bauingenieurwesen – in nahezu jedem ingenieurwissenschaftlichen Bereich spielen Software und Algorithmen eine zentrale Rolle. Eine Auswahl an Argumenten, warum Grundfertigkeiten der Programmierung für Ingenieurinnen und Ingenieure unverzichtbar sind:\n\nAutomatisierung und Effizienzsteigerung: Ingenieurinnen und Ingenieure nutzen Programmierung, um wiederkehrende Aufgaben zu automatisieren und somit die Effizienz zu steigern. Dies kann die Steuerung von Maschinen und Prozessen umfassen, aber auch die Erstellung von Berichten und Analysen. Durch Automatisierung können Fehler reduziert und Zeit gespart werden, was zu einer höheren Produktivität führt.\nSimulation als Schlüsselwerkzeug: Simulationen ermöglichen Ingenieurinnen und Ingenieuren, komplexe Prozesse oder Systeme virtuell nachzubilden, zu analysieren und zu optimieren. Programmierkenntnisse sind hier unverzichtbar, um leistungsfähige Simulationen zu entwickeln und anzupassen.\nDatenanalyse und Entscheidungsfindung: In der modernen Ingenieurpraxis fallen große Mengen an Daten an. Programmierkenntnisse ermöglichen es Ingenieurinnen und Ingenieuren, diese Daten zu sammeln, zu analysieren und daraus fundierte Entscheidungen zu treffen. Dies ist besonders wichtig in Bereichen wie der Qualitätskontrolle, der Forschung und Entwicklung sowie der Prozessoptimierung.\nEntwicklung von maßgeschneiderten Lösungen: Ingenieurinnen und Ingenieure stehen oft vor komplexen Problemen, die standardisierte Softwarelösungen nicht immer abdecken können. Durch Programmieren können sie individuelle Softwarelösungen entwickeln, die genau auf ihre spezifischen Anforderungen zugeschnitten sind. Mit Programmierkenntnissen können sie dabei auch auf OpenSource-Frameworks, globale Entwicklungscommunities und eine nahezu unbegrenzte Palette an modernen Tools zugreifen.\nInterdisziplinäre Zusammenarbeit: Die Fähigkeit zu programmieren erleichtert die Zusammenarbeit mit anderen Fachbereichen, wie der Informatik oder der Datenwissenschaft. Ingenieurinnen und Ingenieure können durch Programmierkenntnisse besser kommunizieren und gemeinsame Projekte effizienter umsetzen. Dies fördert den interdisziplinären Austausch und die Innovationskraft.\nKarrierechancen und berufliche Weiterentwicklung: Programmierkenntnisse sind in der heutigen Arbeitswelt sehr gefragt und eröffnen Ingenieurinnen und Ingenieuren vielfältige Karrierechancen. Sie können sich in Bereichen wie der Robotik, der künstlichen Intelligenz, der Automatisierungstechnik oder der Medizintechnik spezialisieren. Darüber hinaus verbessern Programmierkenntnisse die berufliche Flexibilität und die Fähigkeit, sich an neue technologische Entwicklungen anzupassen.\nEntscheidende Metakompetenzen: Programmieren fördert wichtige Metakompetenzen, die Ingenieurinnen und Ingenieuren helfen, in ihrer Arbeit erfolgreich zu sein. Dazu gehören:\n\nKritisches Denken: Die Fähigkeit, Probleme systematisch zu analysieren und fundierte Entscheidungen zu treffen.\nProblemlösungsfähigkeiten: Entwickeln kreativer und effektiver Lösungen für komplexe technische Herausforderungen.\nTeamarbeit: Zusammenarbeiten in interdisziplinären Teams und effektive Kommunikation mit Kolleginnen und Kollegen.\nAnpassungsfähigkeit: Schnell auf neue Technologien und Methoden reagieren und diese in die Arbeit integrieren.\nSelbstständiges Lernen: Kontinuierliches Lernen und Weiterentwickeln der eigenen Fähigkeiten, um immer auf dem neuesten Stand der Technik zu bleiben.\n\n\nIm Zusammenhang mit dem letzten Punkt ist eine Untersuchung des World Economic Forums (Link) interessant, welche versucht, die Schlüsselqualifikationen für den zukünftigen Arbeitsmarkt zu identifizieren:\n\n\n\n\n\n\nAbbildung 2.1: Wichtigste Zukunftsskills laut World Economic Forum.\n\n\n\n\nÜbungen:\n\nBetrachten Sie Abbildung 2.1, welche basierend auf einer Studie des World Economic Forums die wichtigsten Zukunftsskills auflistet. Welche dieser Skills könnten von einem Programmierkurs und weiteren Erfahrungen auf diesem Gebiet profitieren?\nKI ist in den letzten Jahren immer mächtiger geworden und kann selbständig Code schreiben. Diskutieren Sie vor diesem Hintergrund die Frage: Muss man heutzutage überhaupt noch programmieren lernen?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "notebooks/0-einleitung.html#grundbegriffe-algorithmus-und-programm",
    "href": "notebooks/0-einleitung.html#grundbegriffe-algorithmus-und-programm",
    "title": "2  Einleitung",
    "section": "2.3 Grundbegriffe: Algorithmus und Programm",
    "text": "2.3 Grundbegriffe: Algorithmus und Programm\n„In der Informatik geht es genauso wenig um Computer, wie in der Astronomie um Teleskope.“ ―Edsger W. Dijkstra (niederländischer Informatiker und Wegbereiter der Programmierung)\nDas Eingangszitat macht deutlich, dass Computer für die Informatik vor allem nützliche Werkzeuge sind. Werkzeuge wozu? Allgemein gesprochen: zur Lösung von Problemen. Hierzu werden Algorithmen entwickelt und in Programmen umgesetzt. Diese beiden Grundbegriffe möchten wir in diesem Abschnitt genauer definieren:\n\n\n\n\n\n\nAlgorithmus: Eine präzise, endliche Abfolge von Anweisungen zur Lösung eines Problems oder zur Durchführung einer Aufgabe.\n\n\n\nAlgorithmen bilden die Grundlage der Programmierung, indem sie die Logik und die Schritte definieren, die ein Computer ausführen muss, um ein gewünschtes Ergebnis zu erzielen. Sie sind aber unabhängig von einer Programmiersprache, müssen auch gar nicht auf einem Computer ausgeführt werden, sondern können theoretisch auch von Hand durchgeführt werden. Wir alle kennen Algorithmen für bestimmte Probleme aus der Schule, z.B. den Euklidischen Algorithmus, der den größten gemeinsamen Teiler (ggT) von zwei Zahlen berechnet. Eine wichtige Eigenschaft aller Algorithmen ist die Finitheit: Ein Algorithmus muss mit endlich vielen Schritten zu einem Ergebnis kommen (es können durchaus sehr viele Schritte sein, aber eben nicht unendlich viele). Oft wird behauptet, dass Algorithmen deterministisch seien, also bei gleicher Eingabe auch gleiche Ausgaben erzeugten. Das stimmt allerdings nicht immer, denn es gibt auch nicht-deterministische Algorithmen, die mit Zufallszahlen arbeiten und bei wiederholter Durchführung andere Ergebnisse liefern (ein Beispiel lernen wir in Ingenieurinformatik II kennen).\nBeispiel: Bubble-Sort einer Liste von Zahlen.\nProblem: Gegeben ist eine Liste von Zahlen, z.B. 42, 6, -7, 100, 3. Die Zahlen sollen der Größe nach aufsteigend sortiert werden.\nEin Algorithmus für dieses Problem ist der sog. “Bubble-Sort”:\n\nSchritt 1: Gehe zum ersten Element der Liste.\nSchritt 2: Vergleiche das aktuelle Element mit dem nächsten Element.\nSchritt 3: Wenn das aktuelle Element größer ist als das nächste Element, dann tausche die beiden.\nSchritt 4: Gehe zum nächsten Element und wiederhole die Schritte 2 und 3, bis du das Ende der Liste erreichst.\nSchritt 5: Gehe zurück zum Anfang der Liste und wiederhole die Schritte 1 bis 4, bis keine Vertauschungen mehr vorgenommen werden.\n\nProbieren Sie den Algorithmus einmal von Hand aus. An diesem Beispiel erkennen Sie bereits die wichtigsten Elemente vieler Algorithmen: Bedingungen (“Wenn…, dann…”) und Wiederholungen (“wiederhole die Schritte…, bis…”). Mit diesen Strukturen werden wir uns noch viel beschäftigen.\n\n\n\n\n\n\nProgramm: Eine Sammlung von Anweisungen, die ein Computer ausführt, um eine bestimmte Aufgabe zu erledigen.\n\n\n\nProgramme bestehen aus einem oder mehreren Algorithmen, die in der Regel mit zusätzlichen Anweisungen kombiniert werden, z.B. für die Ausgabe der Ergebnisse. Sie sind in einer Programmiersprache geschrieben (man sagt auch “implementiert” und spricht auch von einer “Implementierung” oder “Implementation” anstelle von einem Programm). Programme können von einfachen Skripten bis hin zu komplexen Softwareanwendungen reichen. Ein und derselbe Algorithmus kann je nach Wahl der Programmiersprache unterschiedlich aussehen und unterschiedlich schwer zu implementieren sein, da nicht jede Programmiersprache dieselben Funktionalitäten bietet. Manche Programmiersprachen bieten spezifische Funktionen und Bibliotheken, die die Implementierung erleichtern, während andere Sprachen möglicherweise mehr manuelle Arbeit erfordern.\nWie würde nun eine Implementierung von Bubble-Sort in Python aussehen? Hinweis: Sie müssen den folgenden Code selbstverständlich noch nicht verstehen, aber vielleicht können Sie bestimmte Parallelen zum Algorithmus bereits erkennen. Hinter dem Symbol # stehen übrigens Kommentare, die für Menschen zur Erläuterung gedacht sind und keine Auswirkung auf den Code haben.\n\n\nCode\n# Python-Code, der den Algorithmus \n# Bubble Sort implementiert:\n\ndef bubble_sort(numbers):    \n    # Vorbereitungen:\n    result = numbers[:]  # Input kopieren\n    n = len(numbers)  # Länge der Liste \n    swapped = True # merkt sich, ob getauscht wurde\n\n    # Es folgt eine Schleife, die\n    # den Algorithmus wiederholt, bis nicht\n    # mehr getauscht wurde\n    while swapped: \n        swapped = False    \n       \n        # alle Elemente durchlaufen:\n        for j in range(1, n): \n            if result[j-1] &gt; result[j]:\n                # Vorgänger ist größer als Nachfolger: tauschen!\n                result[j-1], result[j] = result[j], result[j-1]\n                swapped = True  # es wurde getauscht\n\n    # die sortierte Liste wird zurückgegeben:\n    return result\n\n\nNatürlich wollen wir unsere Implementierung testen:\n\nbubble_sort([42,6,-7,100,3])\n\n[-7, 3, 6, 42, 100]\n\n\n\nÜbungen:\n\nErinnern Sie sich an Algorithmen aus der Schulzeit und lassen Sie sich von einer KI (z.B. ChatGPT) eine Implementierung vorschlagen. Variieren Sie die Programmiersprache und vergleichen Sie!\nIst es bei Bubble Sort wirklich erforderlich jedes Mal durch die gesamte Liste zu gehen? Wie könnte man den Algorithmus optimieren?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "notebooks/0-einleitung.html#von-assembler-bis-python-ein-kurzer-überblick-über-programmiersprachen",
    "href": "notebooks/0-einleitung.html#von-assembler-bis-python-ein-kurzer-überblick-über-programmiersprachen",
    "title": "2  Einleitung",
    "section": "2.4 Von Assembler bis Python: Ein kurzer Überblick über Programmiersprachen",
    "text": "2.4 Von Assembler bis Python: Ein kurzer Überblick über Programmiersprachen\nProgrammiersprachen sind Werkzeuge, die es Entwicklern ermöglichen, Anweisungen zu schreiben, die ein Computer ausführen kann. Sie spielen eine zentrale Rolle in der Softwareentwicklung und haben sich in den letzten Jahrzehnten stark weiterentwickelt.\n\nHistorie der Programmiersprachen\nDie Geschichte der Programmiersprachen beginnt in den 1940er Jahren mit der Entwicklung der ersten maschinennahen Sprachen. Hier sind einige wichtige Meilensteine:\n\n1940er Jahre: Die ersten maschinennahen Sprachen (Assembler) werden entwickelt. Sie ermöglichen es, Prozessorbefehle zu schreiben, die der Computer direkt versteht (der Laie allerdings umso weniger).\n1950er Jahre: Die Entwicklung von höheren Programmiersprachen beginnt, darunter Fortran (1957) und COBOL (1959). Diese Sprachen erlauben es, Programme in einer für Menschen verständlicheren Form zu schreiben.\n1960er und 1970er Jahre: Sprachen wie ALGOL, BASIC und C werden entwickelt. C wird besonders einflussreich und bildet die Grundlage für viele moderne Sprachen.\n1980er und 1990er Jahre: Objektorientierte Sprachen wie C++ und Java werden populär. Objektorientierung hilft, den Code besser zu strukturieren und wiederverwendbare Module zu erstellen. Python, eine vielseitige und leicht verständliche Sprache, wird 1991 veröffentlicht.\n\n\n\nInterpretiert oder kompiliert - das ist hier die Frage!\nProgrammiersprachen können grob in zwei Kategorien eingeteilt werden: interpretierte und kompilierte Sprachen.\n\nInterpretierte Sprachen: Diese Sprachen werden zeilenweise zur Laufzeit (also während das Programm läuft) vom Computer interpretiert und ausgeführt. Beispiele sind Python, JavaScript und Ruby. Vorteile interpretierter Sprachen sind ihre Flexibilität und Einfachheit, da sie in der Regel keine separate Kompilierungsphase erfordern. Allerdings können die Programme langsamer sein als bei kompilierten Sprachen, da der Code während der Ausführung interpretiert werden muss. Im Hintergrund arbeitet also immer ein sog. “Interpreter”.\nKompilierte Sprachen: Diese Sprachen werden vor der Ausführung in Maschinencode übersetzt, den der Computer direkt ausführen kann. Beispiele sind C, C++ und Go. Kompilierte Sprachen bieten in der Regel eine höhere Ausführungsleistung, da der Code vor der Ausführung optimiert wird und nicht mehr während der Ausführung interpretiert werden muss. Sie müssen allerdings für jede Plattform eine eigene Kompilierung durchführen und erhalten jeweils ein plattformspezifisches Ergebnis: z.B. entstehen für Windows die bekannten .exe-Dateien, die für Linux- oder Mac-Benutzer unbrauchbar sind.\n\n\n\nWelche Programmiersprache darf es denn sein?\nVielleicht fragen Sie sich an dieser Stelle, welche Programmiersprache denn nun die beste ist. Es muss doch eine geben, die alle anderen schlägt, oder? Die Antwort lautet, wie so oft im Leben: it depends! Und zwar hängt es von vielen Faktoren ab, sowohl technischen, als auch menschlichen, welche die beste Programmiersprache für ein bestimmtes Projekt ist. Nennen wir einige Aspekte:\n\nProjektanforderungen:\nUnterschiedliche Projekte begünstigen unterschiedliche Sprachen. Webentwicklung, Datenanalyse, maschinelles Lernen, Spieleentwicklung und Systemprogrammierung haben jeweils bevorzugte Programmiersprachen. Benötigt man die höhere Leistung von kompilierten Sprachen wie C und C++ oder eher die Portabilität von interpretierten Sprachen wie Python? Auch der Umgang mit dem Speicher unterscheidet sich von Programmiersprache zu Programmiersprache und könnte ein wesentlicher Faktor sein. \nUnterstützung durch Bibliotheken und Frameworks:\nProgrammiererinnen und Programmierer erfinden das Rad nicht täglich neu, sondern verwenden “Bibliotheken” und “Frameworks” für ihre Projekte. Das sind frei verfügbare Funktionen, Programme und Tools, die für spezielle Anwendungen zur Verfügung gestellt werden und die Arbeit erheblich vereinfachen und beschleunigen. Jede Programmiersprache bietet ihre eigene Palette!\nBeispiele: NumPy und Pandas in Python, React und Angular in JavaScript, Spring und Hibernate in Java.\nLernkurve, Community und persönlicher Geschmack:\nFür Anfängerinnen und Anfänger sind Sprachen wie Python und Ruby aufgrund ihrer klaren und einfachen Syntax ideal zum Lernen. Eine starke Community und umfangreiche Dokumentation können den Lernprozess erheblich erleichtern, da es zahlreiche Ressourcen gibt (die passenden zu finden, kann dennoch eine Herausforderung sein). Nicht zu unterschätzen sind aber auch die persönlichen Präferenzen: Welche Sprache liegt mir und welche mag ich einfach nicht? Menschen sind verschieden.\n\nDie Wahl der passenden Programmiersprache ist daher nicht immer eine einfache Entscheidung. Es kommt in der Praxis aber auch oft vor, dass man sich über diese Frage gar keinen Kopf zerbrechen muss: Man stößt z.B. neu zu einem Projekt dazu, bei dem die Sprache längst gesetzt ist. Auch ist es nicht selten, dass man älteren Code für die eigenen Zwecke anpassen muss und sich mit der dort verwendeten Sprache arrangieren muss.\nWie auch immer: Die eine one-size-fits-all-Sprache gibt es leider nicht. Wichtig ist, dass man die Grundkonzepte des Programmierens mit einer Sprache richtig gut gelernt hat, gleichzeitig aber offen gegenüber anderen Sprachen und neuen Technologien ist.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "notebooks/1-prep.html",
    "href": "notebooks/1-prep.html",
    "title": "3  Vorbereitungen",
    "section": "",
    "text": "3.1 Anaconda installieren\nIn diesem Kapitel geht es um die konkreten Vorbereitungen für das Programmieren in Python: Wir legen unsere Werkzeuge bereit! Dafür installieren wir Anaconda (eine weit verbreitete Python-Distribution) und eine IDE. Alternativ können Sie auch in der Cloud programmieren, ohne etwas auf Ihrem Rechner installieren zu müssen. Hierfür empfehlen wir Google Colab (siehe unten).\nIm Grunde bräuchten wir nur eine Python-Installation und einen Texteditor zum Programmieren. Wir gönnen uns aber etwas mehr Komfort und installieren “Anaconda”, eine umfassende Python-Distribution, die viele nützliche Bibliotheken und Werkzeuge integriert. Mit Anaconda können wir Python und wichtige Pakete problemlos installieren, verwalten und aktualisieren. Die integrierte Benutzeroberfläche, der Anaconda Navigator, ermöglicht den einfachen Zugriff auf beliebte Entwicklungsumgebungen wie Jupyter Notebooks oder Visual Studio Code (siehe unten).\nInstallationsanweisungen für die Plattformen Win / macOS / Linux findet man hier.\nMit der Anaconda Installation wird auch der Anaconda Navigator installiert, der eine grafische Benutzeroberfläche zur Verfügung stellt, mit der man Conda-Umgebungen und Bibliotheken verwalten, sowie Programme (z.B. IDEs) starten kann. Eine Dokumentation des Navigators findet man hier, die Bedienung ist aber intuitiv, probieren Sie es aus!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vorbereitungen</span>"
    ]
  },
  {
    "objectID": "notebooks/1-prep.html#anaconda-installieren",
    "href": "notebooks/1-prep.html#anaconda-installieren",
    "title": "3  Vorbereitungen",
    "section": "",
    "text": "Was ist eine Umgebung in Anaconda?\n\n\n\nUmgebungen (engl. environments) sind isolierte Arbeitsbereiche, in denen man verschiedene Versionen von Python und Paketen installieren und verwalten kann, ohne dass diese sich gegenseitig beeinflussen. Dies ist besonders nützlich, wenn man an mehreren Projekten arbeitet, die unterschiedliche Abhängigkeiten und Versionen von Bibliotheken erfordern. Die Standardumgebung heißt “base” und wir benötigen in diesem Kurs keine weiteren Umgebungen. Zum Experimentieren können Sie sich aber eine weitere Umgebung anlegen und dort Pakete installieren und testen, ohne Sorge zu haben in Ihrer Standardumgebung etwas “kaputt zu machen”.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vorbereitungen</span>"
    ]
  },
  {
    "objectID": "notebooks/1-prep.html#die-ide---unsere-werkbank-fürs-programmieren",
    "href": "notebooks/1-prep.html#die-ide---unsere-werkbank-fürs-programmieren",
    "title": "3  Vorbereitungen",
    "section": "3.2 Die IDE - unsere Werkbank fürs Programmieren!",
    "text": "3.2 Die IDE - unsere Werkbank fürs Programmieren!\nBeim Programmieren ist eine integrierte Entwicklungsumgebung (IDE, engl.: integrated development environment) das wichtigste Werkzeug – vergleichbar mit der Werkbank eines Handwerkers. Eine IDE kombiniert verschiedene Funktionen, die das Coden effizienter und angenehmer machen. Über Anaconda können wir verschiedene IDEs einfach über den Navigator installieren. Aber auch IDEs, die außerhalb des Navigators installiert werden, können in Anaconda integriert und später über den Navigator gestartet werden.\n\nWas ist eine IDE?\nEine IDE ist eine Software, die mehrere Programmier-Tools in einer einzigen Oberfläche bündelt. Typische Bestandteile sind:\n\nCode-Editor mit Syntax-Highlighting und Autovervollständigung. Das ist das Herzstück: Ein Texteditor, mit dem wir unseren Quellcode schreiben.\nDebugger, um Fehler im Code zu finden. Beim “Debuggen” sucht man systematisch nach einem Fehler im Programm und nutzt hierzu verschiedene technische Hilfsmittel (z.B. “Break Points”, die das Programm an bestimmten Stellen anhalten, um Variablen gezielt auszulesen und das gewünschte Verhalten zu überprüfen).\nCompiler oder Interpreter, um den Code auszuführen.\nVersionskontrolle, um Änderungen am Code zu verwalten.\n\n\n\nVorteile einer IDE\nWarum sollte man eine IDE nutzen? Die Alternative zur IDE wäre ein einfacher Texteditor ohne spezielle Coding-Funktionalitäten. Hier sind einige Gründe, die stark für die IDE sprechen:\n✅ Produktivität: Schnelleres Schreiben, Testen und Debuggen von Code.\n✅ Fehlerminimierung: Automatische Code-Analyse und Debugging-Werkzeuge.\n✅ Komfort: Bessere Übersicht und Organisation durch Projektverwaltung.\n\n\nIDEs für die Python-Entwicklung\n\nPyCharm\nPyCharm ist eine der bekanntesten IDEs für Python und wird von JetBrains entwickelt. Es gibt eine kostenlose Community Edition sowie eine kostenpflichtige Professional Edition mit erweiterten Funktionen. Studierende können eine kostenfreie Educational Licence erwerben (siehe PyCharm education).Ein Vorteil der Professional Edition ist, dass sie auch Jupyter Notebooks anlegen und bearbeiten kann.\nGetting Started with PyCharm: Guide.\nVisual Studio Code\nVisual Studio Code (VS Code) von Microsoft ist ein beliebter, kostenloser Code-Editor, der durch eine Vielzahl von Erweiterungen leicht in eine vollwertige IDE verwandelt werden kann. Es handelt sich im engeren Sinne nicht um eine IDE, sondern einen Editor. Erst durch die Installation von Extensions, wird VS Code zu einer mächtigen IDE und kann für verschiedene Programmiersprachen verwendet werden. Für Python benötigen wir z.B. die Python Extensions von Microsoft. Es gibt außerdem Extensions für das Arbeiten mit Jupyter Notebooks (siehe unten). Hier geht es zur Dokumentation.\nJupyter Notebooks\nJupyter Notebooks ist eine webbasierte Entwicklungsumgebung, die besonders beliebt für interaktive Datenanalyse oder maschinelles Lernen ist. Das Besondere ist die Kombination aus Markdown- und Code-Zellen. Während in Code-Zellen programmiert wird, können in Markdown-Zellen Texte formatiert werden, aber auch Bilder oder Animationen eingebunden werden (Markdown-Zellen unterstützen auch Latex-Befehle zur Darstellung mathematischer Formeln). So entsteht ein interaktives Skript, welches mehr als reiner Quellcode ist. Wir werden in der Vorlesung oft Jupyter Notebooks verwenden, da die Kombination aus Text, Bildern und Code für die Lehre sehr vorteilhaft ist. Auch dieses Skript ist in Jupyter Notebooks entstanden. Mehr darüber gibt es hier.\nJupyterLab ist eine Weiterentwicklung von Jupyter Notebooks.\nCloud-Alternative: Google Colab\nGoogle Colab (Colaboratory) ist eine cloudbasierte Entwicklungsumgebung. Mit Google Colab kann Python-Code direkt im Browser geschrieben und ausgeführt werden, ohne dass eine lokale Installation erforderlich ist. Im Prinzip können wir somit auch von einem Tablet oder Smartphone aus programmieren (ein kleiner Bildschirm und eine fehlende Tastatur können dennoch sehr herausfordernd sein beim Coden). Außerdem erhalten wir Zugriff auf leistungsstarke GPUs und TPUs, ohne dass wir uns selbst Hardware anschaffen müssen. In Google Colab arbeitet man ebenfalls mit der beliebten Notebook-Struktur aus Markdown- und Code-Zellen. Wenn man diese nicht braucht, kann man den gesamten Code in eine einzelne Zelle schreiben. Google Colab ermöglicht auch das gemeinsame Arbeiten an einem Projekt oder die Freigabe von Notebooks für andere. Zur Nutzung der Online-IDE ist ein (kostenfreies) Google-Konto erforderlich. Zu Google Colab geht es hier.\nEine Alternative wäre PythonAnywhere (siehe Website), allerdings ohne GPU-Unterstützung in der kostenlosen Version.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vorbereitungen</span>"
    ]
  },
  {
    "objectID": "notebooks/2-basics.html",
    "href": "notebooks/2-basics.html",
    "title": "4  Einführung ins Programmieren",
    "section": "",
    "text": "4.1 Das erste Programm: Hello, World!\nJetzt geht’s los: Wir schreiben unser erstes Programm! Danach lernen wir die grundlegenden Konzepte der Programmierung kennen: Arithmetische Operationen (das Rechnen), Zuweisungen (wie man Ergebnisse in Variablen speichert) und logische Ausdrücke (was ist wahr und was ist falsch?).\nWann immer man eine neue Programmiersprache lernt oder eine Programmierumgebung neu einrichtet (z.B. eine neue IDE installiert und ausprobiert), fängt man mit dem berühmten “Hello, World”-Programm an. Aufgabe des Programms ist die Ausgabe des Textes “Hello, World” auf dem Bildschirm. Ist dies gelungen, weiß man, dass man eine arbeitsfähige Umgebung hat und kann sich komplizierteren Aufgaben zuwenden. Let’s do it:\nprint('Hello, World')\n\nHello, World\nIn Python benutzen wir den Befehl print für eine Bildschirmausgabe. Er ist gleichzeitig unser erstes Beispiel für eine Funktion, das erkennen wir an den runden Klammern nach dem Befehl: Hier erwartet die Funktion ein Argument oder mehrere Argumente. Das kennen wir aus der Mathematik: Die Funktion \\(f(x)\\) erwartet als Argument einen Wert \\(x\\). Funktionen in der Programmierung unterscheiden sich allerdings in einigen Punkten von Funktionen in der Mathematik, wir werden z.B. gleich sehen, dass print mit beliebig vielen Argumenten aufgerufen werden kann, während \\(f(x)\\) immer genau ein Argument erwartet.\nDie Funktion print(...) wird mit dem auszugebenden Text aufgerufen. Texte werden in Python in einfache (') oder doppelte (\") Anführungszeichen gesetzt. Wir hätten also auch diesen Befehl verwenden können:\nprint(\"Hello, World\")\n\nHello, World\nDer print-Befehl in Python ist ein grundlegender und oft verwendeter Befehl, der dazu dient, Texte oder andere Daten auf dem Bildschirm anzuzeigen. Das ist sehr nützlich, um Informationen während der Ausführung eines Programms zu überprüfen oder Ergebnisse von Berechnungen anzuzeigen.\nWie bereits erwähnt, kann man auch mehr als ein Argument übergeben (getrennt durch ein Komma):\nprint(\"Hello,\", \"World!\")\n\nHello, World!\nDas Ergebnis ist dasselbe, da die einzelnen Argumente standardmäßig durch ein Leerzeichen getrennt werden. Dieses Verhalten kann durch weitere Argumente geändert werden. Probieren Sie das folgende einmal aus:\nprint(\"It\", \"is\", \"a\", \"beautiful\", \"day.\", sep=\"-\")\nNun haben Sie schon ein sog. “Keyword-Argument” kennengelernt: sep. Ein Keyword-Argument erkennen Sie daran, dass es explizit einem Namen zugewiesen wird, in unserem Beispiel durch sep=.... (Das Gegenstück dazu heißt “Positionsargumente”, es sind alle Argumente, die ohne Zuweisung übergeben werden. Ohne das Keyword sep könnte die print-Funktion das Argument nicht von den vorherigen unterscheiden. Auf den Unterschied zwischen Positions- und Keywordargumenten werden wir natürlich später noch ausführlicher eingehen. Wir sind hier noch bei unseren ersten Gehversuchen in der Welt der Programmierung.)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Einführung ins Programmieren</span>"
    ]
  },
  {
    "objectID": "notebooks/2-basics.html#das-erste-programm-hello-world",
    "href": "notebooks/2-basics.html#das-erste-programm-hello-world",
    "title": "4  Einführung ins Programmieren",
    "section": "",
    "text": "Übungen: 1. Experimentieren Sie mit dem print-Befehl. Können Sie außer Text auch andere Argumente verwenden? 2. Der print-Befehl kennt noch ein weiteres Keyword-Argument: end=.... Finden Sie durch Experimentieren heraus, was dieses Argument bewirkt. Sie können anschließend auch im Netz recherchieren, ob Sie es richtig verstanden haben. 3. Recherchieren Sie, wie das “Hello, World”-Programm in anderen Programmiersprachen aussieht. Suchen Sie mindestens nach C, C++, Java und einer weiteren Programmiersprache Ihrer Wahl. Wo erkennen Sie Ähnlichkeiten zu unserem Beispiel in Python und wo sieht es ganz anders aus?",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Einführung ins Programmieren</span>"
    ]
  },
  {
    "objectID": "notebooks/2-basics.html#python-als-taschenrechner",
    "href": "notebooks/2-basics.html#python-als-taschenrechner",
    "title": "4  Einführung ins Programmieren",
    "section": "4.2 Python als Taschenrechner",
    "text": "4.2 Python als Taschenrechner\nProgramme können mächtige Berechnungen und Analysen durchführen. Die Grundlage aller Berechnungen sind die Basisoperationen, die wir alle in der Schule gelernt haben. Anhand der folgenden Beispiele sehen Sie, wie wir mit Python rechnen können (es wechseln sich zeilenweise Ein- und Ausgabe ab; hinter # steht einen Kommentar, der nur für Menschen gedacht ist und das Programm nicht beeinflusst):\n\n# Addition\n3 + 2  \n\n5\n\n\n\n# Subtraktion\n6 - 2 \n\n4\n\n\n\n# so funktioniert es auch:\n-2 + 6  \n\n4\n\n\n\n# Multiplikation\n3 * 2  \n\n6\n\n\n\n# Division\n3 / 2 \n\n1.5\n\n\n\n# Ganzzahl-Division \n# (alle Nachkommastellen werden verworfen)\n3 // 2  \n\n1\n\n\n\n# Zweites Beispiel für \n# die Ganzzahl-Division\n9 // 2 \n\n4\n\n\n\n# Modulo-Division: Division mit Rest \n# Gibt den Rest zurück.\n9 % 2 \n\n1\n\n\n\n# Zweites Beispiel für Modulo\n31 % 7 \n\n3\n\n\n\n# Potenz \n3 ** 2  # 3 hoch 2  \n\n9\n\n\n\n# Klammern\n3 * (2 + 4) \n# Ohne Klammern hält sich \n# Python an Punkt vor Strich!\n\n18\n\n\nSelbstverständlich können wir nicht nur mit ganzen Zahlen rechnen, sondern auch mit Dezimalzahlen. Wichtig: Diese verwenden immer einen Punkt als Dezimalzeichen!\n\n# Dezimalzahlen\n2.8 + 3.2 \n\n6.0\n\n\nMöglich ist auch die sog. Exponentialschreibweise:\n\n# Exponentialschreibweise\n# e4 bedeutet \"mal 10 hoch 4\": \n# Komma um 4 Stellen nach rechts verschieben \n2e4 \n\n20000.0\n\n\n\n# e-4 bedeutet \"mal 10 hoch -4\": \n# Komma um 4 Stellen nach links verschieben\n2e-4 \n\n0.0002\n\n\nDie Exponentialschreibweise ist besonders praktisch um sehr große oder sehr kleine Zahlen kompakt darzustellen (ohne viele Nullen). Sie wird auch wissenschaftliche Notation genannt, da sie in wissenschaftlichen Kontexten häufig verwendet wird. Es folgen noch ein paar Beispiele:\n\n5.34e5\n\n534000.0\n\n\n\n1.267e-4\n\n0.0001267\n\n\n\n8.11e9  # Erdbevölkerung in 2025\n\n8110000000.0\n\n\n\nÜbungen:\n\nMachen Sie sich mit allen Operationen vertraut. Achten Sie auf die korrekte Syntax, z.B. * für die Multiplikation anstelle eines Punktes.\nFühren Sie die folgenden Berechnungen in Python aus:\n\n\n\\(2\\cdot(3+4)^2\\)\n\\(\\frac{7}{8}\\cdot(1,2 - 5,3)\\)\n\\(-3\\cdot(\\frac{4}{3} - 2,1)^3\\)\n\n\nLösungen der Rechenaufgaben:\n\n\nCode\n2 * (3 + 4)**2\n\n\n98\n\n\n\n\nCode\n7 / 8 * (1.2 - 5.3)\n\n\n-3.5874999999999995\n\n\n\n\nCode\n-3 * (4 / 3 - 2.1)**3\n\n\n1.3518888888888898",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Einführung ins Programmieren</span>"
    ]
  },
  {
    "objectID": "notebooks/2-basics.html#zuweisungen",
    "href": "notebooks/2-basics.html#zuweisungen",
    "title": "4  Einführung ins Programmieren",
    "section": "4.3 Zuweisungen",
    "text": "4.3 Zuweisungen\nIn der Programmierung sind Zuweisungen ein grundlegendes Konzept, um Werte in Variablen zu speichern. Eine Zuweisung erfolgt in Python mit dem Gleichheitszeichen (=). Schauen wir uns Beispiele an:\n\n# Zuweisung:\n# Die Variable x erhält den Wert 5\nx = 5 \n\n\nprint(x)  # Überzeugen wir uns davon!\n\n5\n\n\n\n# Die Variable name erhält\n# den Wert \"Tina\"\nname = \"Tina\" \n\n\n# Die Variable y erhält \n# den Wert 1.3\ny = 1.3 \n\nMit Variablen können wir rechnen:\n\n# Die Variable z erhält \n# den Wert der Addition x + y\nz = x + y \n\n\nprint(z)  # Überzeugen wir uns davon!\n\n6.3\n\n\n\n\n\n\n\n\nVorsicht\n\n\n\nDas Gleichheitszeichen ist nicht mit dem mathematischen Gleichheitszeichen zu verwechseln: In der Mathematik sind beide Seiten einer Gleichung gleichberechtigt und die Gleichung x = 5 ist entweder wahr oder falsch. In der Programmierung führen wir aber eine Operation durch, nämlich eine Zuweisung: Der Wert auf der rechten Seite wird der Variable auf der linken Seite zugewiesen!\n\n\nMachen Sie sich an dem folgenden Beispiel klar, dass x = y und y = x nicht dasselbe sind in der Programmierung!\n\n# Beispiel:\nx = 5\ny = 7\nx = y # was würde y = x am Ergebnis ändern?\nprint(x, y) \n\n7 7\n\n\nDie bisherigen Beispiele waren sog. Einfach-Zuweisungen: Einer Variable wurde ein Wert zugewiesen. In Python sind aber auch Mehrfach-Zuweisungen erlaubt (das ist eine Besonderheit, die es in anderen Programmiersprachen wie C oder C++ nicht gibt):\n\n# Zwei Variablen \n# gleichzeitig zuweisen:\nname, age = \"Tina\", 25 \n\n\nprint(\"Ich heiße\", name, \"und bin\", age, \"Jahre alt.\")\n\nIch heiße Tina und bin 25 Jahre alt.\n\n\nEinschub: Die letzte Ausgabe geht deutlich leichter, wie das folgende Beispiel zeigt.\n\n# Achten Sie auf das kleine f und die geschweiften\n# Klammern:\nprint(f\"Ich heiße {name} und bin {age} Jahre alt.\")\n# Hier verwenden wir einen sog. f-String. \n# Das f steht für formatiert bzw. formatted.\n# Es sagt Python, dass die Variablen in den geschweiften \n# Klammern durch ihre Werte ersetzt werden sollen.\n\nIch heiße Tina und bin 25 Jahre alt.\n\n\nSelbstverständlich kann sich der Wert einer Variable nach der ersten Zuweisung noch verändern, indem ein neuer Wert zugewiesen wird. Das demonstrieren wir anhand verschiedener Beispiele:\n\nBeispiel mit einer einzelnen Variable.\n\n\nx = 20  # x hat den Wert 20\nx = 21  # x hat den Wert 21\nx = 22  # x hat den Wert 22\nprint(x)  # Überzeugen wir uns!\n\n22\n\n\n\nBeispiel mit zwei Variablen.\n\n\nx = 1.2  # x hat den Wert 1.2\ny = 42  # y hat den Wert 42\nx = y  # x bekommt den Wert von y, also 42\ny = 0  # y bekommt den Wert 0, x bleibt unverändert\nprint(x, y)\n\n42 0\n\n\n\nBeispiel, welches den Unterschied zur mathematischen Gleichung noch einmal deutlich hervorhebt.\n\n\nx = 2\nx = x + 2 # Das Ergebnis von x+2 wird der Variable x zugewiesen.\nprint(x)\n\n4\n\n\n\n\n\n\n\n\nErweiterte Zuweisungen\n\n\n\nMit +=, -=, *=, /= können Zuweisungen wie im letzten Beispiel verkürzt werden. Dabei steht x += 5 für x = x + 5 (die anderen analog). Es wird also eine mathematische Operation mit der Variable durchgeführt (z.B. “addiere 5”) und das Ergebnis derselben Variablen als neuer Wert zugewiesen. Es handelt sich lediglich um eine kürzere Schreibweise.\n\n\n\nBeispiel mit erweiterten Zuweisungen.\n\n\nx,y,z = 1, 2, 3\nx += 10\ny -= 10\nz *= 10\nprint(x, y, z)\n\n11 -8 30\n\n\nWichtig: Python-Code wird vom Interpreter der Reihe nach abgearbeitet. Wenn Sie eine Variable z.B. erst nach einem Aufruf von print verändern, so bekommt der print-Befehl das nicht mit. Beispiel:\n\nx = 5\nprint(x)\nx += 10  # für das print darüber unerheblich!\nprint(x) # jetzt sieht man die Veränderung!\n\n5\n15\n\n\n\nEinschub: Benutzereingaben\nIn Python wird die Funktion input() verwendet, um Benutzereingaben zu erfassen. Sie wartet, bis der Benutzer eine Eingabe macht und mit Enter bestätigt. Der eingegebene Wert wird immer als Zeichenkette (also Text) zurückgegeben, kann aber bei Bedarf in andere Datentypen umgewandelt werden (mehr dazu im nächsten Kapitel). Die Eingabe des Benutzers wird häufig einer Variable zugewiesen, damit sie weiter verarbeitet werden kann. Als Argument können Sie der Funktion eine Aufforderung oder Frage übergeben:\n\nname = input(\"Wie heißen Sie? \")  # fragt nach dem Namen; speichert die Eingabe in name\ncity = input(\"Wo wohnen Sie? \")  # fragt nach dem Wohnort; speichert die Eingabe in city\nage = input(\"Bitte Alter eingeben: \")  # Variante mit Aufforderung statt Frage\n\nprint(f\"Sie heißen {name}, sind {age} Jahre alt und wohnen in {city}.\")\n\nWie heißen Sie?  John\nWo wohnen Sie?  New York\nBitte Alter eingeben:  40\n\n\nSie heißen John, sind 40 Jahre alt und wohnen in New York.\n\n\n\n\n\n\n\n\nGute Variablennamen\n\n\n\nObwohl Python im Vergleich zu anderen Programmiersprachen mehr Freiheiten bei der Benennung von Variablen zulässt (z.B. die Verwendung von Umlauten und anderen spezielle Buchstaben), sollte man sich auf das lateinische Alphabet beschränken. Der offizielle Python-Style-Guide (PEP) empfiehlt mit einem kleinen Buchstaben anzufangen und mehrere Wörter mit einem Unterstrich (_) zu trennen (das nennt man snake_case). Es sind auch Ziffern erlaubt (allerdings nicht am Anfang). Wichtig ist eine gute Verständlichkeit, damit auch andere Menschen Ihren Code nachvollziehen können. Daher empfehlen sich kurze, aber aussagekräftige Namen. Es folgen eine paar Beispiele:\ncustomer_name = \"Markus\"\nuser_age = 32\ntotal_price = 3.4e3\ncoordinate_1, coordinate_2, coordinate_3 = 3.1, -2.0, 0.0\nx_coordinate, y_coordinate, z_coordinate = -1.0, -1.0, 1.0\nIm Style-Guide wird außerdem davor gewarnt, dass die Buchstaben ‘l’ (kleines L), ‘O’ (großes o) oder ‘I’ (großes i) leicht mit den Zahlen ‘1’ bzw. ‘0’ verwechselt werden können (in manchen Schriftarten werden sie identisch dargestellt!). Immer darauf achten, ob es aus dem Kontext eindeutig zu erkennen ist.\nViele Organisationen oder Teams definieren übrigens eigene Style-Guides, die weitere Details festlegen. In internationalen Projekten legt man z.B. häufig fest, dass die englische Sprache im Code zu verwenden ist. Andere Unternehmen verwenden deutsche Wörter. Wenn Sie Teil eines Teams werden, fragen Sie nach den internen Konventionen (explizit niedergeschrieben oder implizit von allen befolgt).\nAbschließend sei an dieser Stelle darauf hingewiesen, dass Sie natürlich keine Schlüsselwörter von Python für Ihre Variablennamen verwenden dürfen. Bsp.: Ein Variable namens print ist nicht erlaubt, da dieser Begriff eine Funktion von Python bezeichnet. Verboten sind auch if, else, class, return, usw.\n\n\n\nÜbungen:\n\nBetrachten Sie das folgende Code-Beispiel und überlegen Sie sich, welche Werte am Schluss ausgegeben werden. Überprüfen Sie Ihr Ergebnis anschließend, indem Sie den Code implementieren:\n x = 5\n x += 10\n y = 2 * x + 10\n y -= 15\n x /= 2 \n print (x, y) \nBetrachten Sie die folgenden Variablennamen und schlagen Sie bessere vor:\nX = 10           # Anzahl der Äpfel im Korb\nCLIENTnum = 1440 # Kundennummer\nZähler = 0       # zählt etwas\ntxt = \"Hallo\"    # Begrüßungstext\nisLoggedIn = True  # Ob ein Benutzer angemeldet ist\nlO = 10.0       # Koordinate links oben",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Einführung ins Programmieren</span>"
    ]
  },
  {
    "objectID": "notebooks/2-basics.html#vergleiche",
    "href": "notebooks/2-basics.html#vergleiche",
    "title": "4  Einführung ins Programmieren",
    "section": "4.4 Vergleiche",
    "text": "4.4 Vergleiche\nIn Programmen wird viel gerechnet, wofür die arithmetischen Operationen, die wir bisher betrachtet haben, die Grundlage bilden. Ein weiteres grundlegendes Element von Programmen ist die Logik: Dabei geht es um die Entscheidung, ob etwas wahr oder falsch ist. Je nach Ergebnis kann ein Programm unterschiedliche Wege einschlagen: Ist eine Bedingung wahr, wird eine bestimmte Aktion ausgeführt. Ist sie falsch, passiert etwas anderes.\nSchauen wir uns nun die grundlegenden logischen Ausdrücke an, mit denen wir solche Entscheidungen treffen können. Vergleichen wir zunächst zwei Zahlen:\n\n1 &lt; 42  # Ist 1 kleiner als 42?\n\nTrue\n\n\n\n1 &gt; 42  # Ist 1 größer als 42?\n\nFalse\n\n\n\n2 &lt;= 3  # Ist 2 kleiner oder gleich 3?\n\nTrue\n\n\n\n2 &gt;= 3  # Ist 2 größer oder gleich 3?\n\nFalse\n\n\n\n2 == 3  # Ist 2 gleich 3?\n\nFalse\n\n\n\n2 != 3  # Ist 2 ungleich 3?\n\nTrue\n\n\n\n\n\n\n\n\nVorsicht\n\n\n\nFür den logischen Vergleich verwendet man das doppelte Gleichheitszeichen ==, welches nicht mit dem Zuweisungsoperator = verwechselt werden darf!\n\n\nWie Sie festgestellt haben, liefern logische Vergleiche als Ergebnis einen Wahrheitswert: True für wahr oder False für falsch. Wahrheitswerte können genauso wie andere Werte einer Variable zugewiesen werden:\n\nx = 3\ny = 0\ncomparison = x &gt; y  # Zuweisung\nprint(comparison)\n\nTrue\n\n\nDie Variable comparison speichert das Ergebnis des Vergleichs und kann an anderer Stelle im Programm verwendet werden. Es folgt ein Beispiel, welches auf die If-else-Verzweigung vorgreift (Sie können es sicher trotzdem schon verstehen):\n\nif (comparison):\n    print(x, 'ist größer als', y)\nelse:\n    print(x, 'ist kleiner oder gleich', y)\n\n3 ist größer als 0\n\n\n\n# Zur Erinnerung: Wir legen unsere\n# Variablennamen selbst fest. Hier zur Demo dasselbe\n# Beispiel erneut mit einem Quatsch-Namen:\nx = 3\ny = 0\ndagobert_duck = x &gt; y  # Zuweisung\nprint(dagobert_duck)\n# Wir könnten jetzt mit dagobert_duck\n# alles tun, was wir zuvor mit comparison\n# getan haben.\n\nTrue\n\n\nWahrheitswerte tauchen nicht nur bei Vergleichen von Zahlen auf, sondern auch in vielen anderen Situationen, wie zum Beispiel bei der Suche nach einem Buchstaben in einem Wort. Das würde in Python so aussehen:\n\n# Suche nach einem 'a' in 'apple':\n'a' in 'apple' \n\nTrue\n\n\n\n# Suche nach einem 'a' in 'lemon'\n'a' in 'lemon' \n\nFalse\n\n\n\n# Achtung: Kleinbuchstaben != Großbuchstaben\n'a' in 'YOGA'\n\nFalse\n\n\nMit der Negation not kehren wir einen Wahrheitswert in sein Gegenteil um, wie die folgenden Beispiele illustrieren:\n\nnot (4 &lt; 3)\n\nTrue\n\n\n\nnot ('a' in 'apple')\n\nFalse\n\n\nEinfache logische Ausdrücke können durch die Verknüpfungen or und and zu komplexeren Bedingungen kombiniert werden. Wenn zwei Bedingungen mit and verknüpft werden, ist die kombinierte Bedingung genau dann wahr, wenn beide Einzelbedingungen wahr sind:\n\n5 &gt; 4 and 4 &gt; 3 \n\nTrue\n\n\n\n5 &gt; 4 and 4 &gt; 6\n\nFalse\n\n\nVerknüpft man hingegen mit or, so genügt es, dass eine der beiden Einzelbedingungen wahr ist:\n\n5 &gt; 4 or 4 &gt; 6 # mindestens eine Bedingung wahr.\n\nTrue\n\n\n\n5 &gt; 4 or 4 &gt; 3 # beide wahr\n\nTrue\n\n\nProbieren Sie eigene Beispiele mit and, or und not aus!\n\n\n\n\n\n\nWahrheitswerte in anderen Programmiersprachen\n\n\n\nIn vielen Programmiersprachen werden Wahrheitswerte als True (wahr) und False (falsch) dargestellt. Die Schreibweise variiert aber je nach Sprache: * In Python: True, False * In C++ und PHP: true, false * In SQL: TRUE, FALSE (oder klein geschrieben)\nIntern werden Wahrheitswerte oft wie Zahlen behandelt: True entspricht dann einer 1 und False einer 0. Probieren Sie in Python Vergleiche der folgenden Art aus: True == 1, False == 0. Kleiner Vorgriff: An vielen Stellen (siehe Verzweigungen, Schleifen) werden in Python alle Zahlen ungleich 0 als True interpretiert.\n\n\n\nÜbungen:\n\nDefinieren Sie eine Variable age und weisen ihr das Alter einer Person zu. Schreiben Sie einen Vergleich, der True zurückgibt, wenn die Person erwachsen ist. Schreiben Sie einen weiteren Vergleich, der überprüft, ob die Person exakt 25 Jahre alt ist. Implementieren Sie einen dritten Vergleich, der überprüft, ob die Person jünger als 67 ist.\nRecherchieren Sie, wie der BMI (‘Body Mass Index’) definiert ist. Legen Sie Variablen für die benötigten Parameter einer Person an und berechnen Sie den BMI. Definieren Sie anschließend eine Variable, die True ist, wenn der BMI ein Normalgewicht anzeigt. Tipp: Verwenden Sie and, um zwei Bedingungen miteinander zu verknüpfen. (Lösung siehe unten.)\n\n\n\n\n\nCode\nlength = 1.80  # Größe in m\nweight = 75  # Gewicht in kg\nbmi = weight / length**2\nis_normal_weight = bmi &gt;= 18.5 and bmi &lt;= 24.9  # laut Wikipedia\n\n# Hinweis: Wir verwenden in der Ausgabe \n# round(), um das Ergebnis auf eine Stelle zu runden\nprint('BMI:',round(bmi,1),'Normalgewicht?', is_normal_weight)\n\n\n\n\n\n\n\n\nComparison Chains in Python\n\n\n\nEs gibt in Python eine Möglichkeit, mehrere Vergleiche miteinander zu verketten, wie man es z.B. aus der Mathematik kennt. Die Vergleiche in der Kette werden einzeln ausgewertet und mit and verknüpft:\n\n\n\nComparison Chain\nBedeutung\n\n\n\n\n18.5 &lt;= x &lt;= 24.9\n18.5 &lt;= x and x &lt;= 24.9\n\n\nx &lt; y &gt; z\nx &lt; y and y &gt; z\n\n\nx == y == z\nx == y and y == z\n\n\nx != y != z\nx != y and y != z\n\n\n\nWährend das erste Beispiel genauso aussieht, wie man es aus der Mathematik kennt, sieht das zweite Beispiel vielleicht etwas seltsam aus. Die Vergleiche werden aber einfach der Reihe nach abgearbeitet, unabhängig davon, welche Vergleichsoperatoren verwendet werden. Das dritte Beispiel prüft, ob alle Variablen gleich sind. Trügerisch ist das vierte Beispiel x != y != z, da es nicht feststellt, ob alle Variablen ungleich sind (x und z werden nicht miteinander verglichen!).\nTipp: Setzen Sie Comparison Chains mit Bedacht ein. Am intuitivsten sind sie, wenn die Ausdrücke so aussehen, wie man es aus der Mathematik kennt (vgl. erste Zeile in der Tabelle).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Einführung ins Programmieren</span>"
    ]
  },
  {
    "objectID": "notebooks/2-basics.html#zum-abschluss-des-kapitels-ein-wenig-fachsprache",
    "href": "notebooks/2-basics.html#zum-abschluss-des-kapitels-ein-wenig-fachsprache",
    "title": "4  Einführung ins Programmieren",
    "section": "4.5 Zum Abschluss des Kapitels: ein wenig Fachsprache",
    "text": "4.5 Zum Abschluss des Kapitels: ein wenig Fachsprache\nWir können bereits eine Menge tun in Python. An dieser Stelle wollen wir kurz auf das bisher Gelernte zurückschauen und dabei zwei wichtige Fachtermini einführen, die Ihnen immer wieder begegnen werden. Es handelt sich um die Begriffe “Ausdruck” und “Literal”.\n\n\n\n\n\n\nAusdruck (engl. expression): Ein Ausdruck in der Programmierung ist eine Kombination von Werten, Variablen und Operatoren, die zusammen ein Ergebnis berechnen. Ein Ausdruck wird ausgewertet und liefert immer einen Wert, der in einer Variablen gespeichert oder direkt weiterverwendet werden kann.\n\n\n\nWir haben bereits verschiedene Ausdrücke kennengelernt: Arithmetische und logische Ausdrücke.\n\n5 + 3  # ist ein arithmetischer Ausdruck. Wert: 8\nx = 5 + 3 # nur die rechte Seite ist ein Ausdruck\n3 * x + 4  # ist ein arithmetischer Ausdruck\n\nIm letzten Beispiel ist die Zuweisung selbst kein Ausdruck, sondern nur die rechte Seite. In manchen Programmiersprachen sind aber auch Zuweisungen Ausdrücke: In C gibt die Zuweisung x=3 gleichzeitig den Wert 3 zurück und ist somit auch ein Ausdruck. Es sind dann auch solche Zuweisungen möglich: y = (x = 3). In Python geht das nicht!\n\n4 &gt; 5  # ist ein logischer Ausdruck\n1 == 1  # ist ein logischer Ausdruck\ncomparison = 99 &gt; 42  # nur die rechte Seite ist ein Ausdruck\n\nWeiterhin können Funktionsaufrufe einen Ausdruck darstellen, wie zum Beispiel:\n\nlen('Apfel')  # gibt den Wert 5 zurück\n\n5\n\n\nAuch Variablen selbst können als Ausdruck betrachtet werden, denn sie geben ihren Wert zurück:\n\nx  # ist ein Ausdruck, gibt den Wert von x zurück\n\n\n\n\n\n\n\nLiteral (vom lateinischen Wort für Buchstabe): Ein Literal ist ein fester, unveränderlicher Wert (wie eine Zahl, eine Zeichenkette oder ein Wahrheitswert), der direkt im Code verwendet wird. Da Literale ausgewertet werden können, um einen Wert zu liefern, gelten sie ebenfalls als Ausdrücke.\n\n\n\nEs folgen einige Beispiele (die Datentypen erklären wir später):\n\n\"Hello, World\"  # String-Literal (Zeichenkette)\n4.2  # Float-Literal (Gleitkommazahl)\n-3  # Integer-Literal (Ganzzahl)\nTrue  # Boolean-Literal (Wahrheitswert)\n\n# Alle diese Literale sind gleichzeitig Ausdrücke:\n# Sie geben sich selbst als Wert zurück.\n\nWarum sollte man diese Begriffe kennen?\nWenn Sie mit anderen Programmiererinnen und Programmierern sprechen, fallen diese Begriffe. Zum Beispiel, wenn man sich über verschiedene Programmiersprachen unterhält (“Wie sieht ein String-Literal in deiner Sprache aus?”, “Welche logischen Ausdrücke kennt deine Sprache?”). Für Sie sind das jetzt keine Fremdwörter mehr!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Einführung ins Programmieren</span>"
    ]
  },
  {
    "objectID": "notebooks/3-datatypes.html",
    "href": "notebooks/3-datatypes.html",
    "title": "5  Datentypen und ihre Repräsentation",
    "section": "",
    "text": "5.1 Grundlegende Datentypen\nBeim Programmieren arbeiten wir ständig mit Daten – Zahlen, Texte, Wahrheitswerte und mehr. Wie aus dieser Aufzählung hervorgeht, gibt es unterschiedliche Datentypen, und jeder Typ hat einen Einfluss darauf, wie Daten dargestellt, verarbeitet und gespeichert werden. In diesem Kapitel lernen wir die wichtigsten Datentypen kennen und werfen einen genaueren Blick darauf, wie diese Daten gespeichert und verwaltet werden.\nIm Speicher des Computers liegen Daten als sog. Instanzen. Wie wir sehen werden, fungieren Variablen als Referenzen auf diese Instanzen (man könnte sagen: Wegweiser zu den Instanzen).\nZuletzt wollen wir noch verstehen, wie Instanzen von unterschiedlichen Datentypen eigentlich für den Computer aussehen, denn dieser versteht nur eine Sprache: das Binärsystem! Für jeden Datentyp existieren daher Kodierungen, die die jeweilige Information (ob Zahl oder Text) als Binärzahl ausdrückt.\nZum Abschluss des Kapitels zeigen wir, wie Datentypen ineinander umgewandelt werden können.\nMit der Funktion type() können wir in Python den Datentyp einer Variablen oder eines Literals abfragen:\ntype(4)  # Typ einer ganzen Zahl\n\nint\ntype(3.2)  # Typ einer Dezimalzahl\n\nfloat\ntype(\"Hallo\")  # Typ eines Textes\n\nstr\ntype(True)  # Typ eines Wahrheitswertes\n\nbool\n# Beispiel mit einer Variable\nx = 5.4\ntype(x)\n\nfloat\nDie folgende Tabelle fasst die gefundenen Datentypen zusammen:\nDie genannten Datentypen gibt es auch in vielen anderen Programmiersprachen, oft mit leicht unterschiedlichen Bezeichnungen oder Eigenschaften:\nDie vorgestellten Datentypen sind die Grundbausteine einer Programmiersprache, aus denen komplexere Datenstrukturen zusammengesetzt werden können. Man nennt sie daher oft auch primitive Datentypen.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datentypen und ihre Repräsentation</span>"
    ]
  },
  {
    "objectID": "notebooks/3-datatypes.html#grundlegende-datentypen",
    "href": "notebooks/3-datatypes.html#grundlegende-datentypen",
    "title": "5  Datentypen und ihre Repräsentation",
    "section": "",
    "text": "Datentyp\nBedeutung\n\n\n\n\nint (Integer)\nganze Zahlen\n\n\nfloat (Floating-point)\nGleitkommazahlen\n\n\nstr (String)\nZeichenketten (Text)\n\n\nbool (Boolean)\nWahrheitswert\n\n\n\n\n\n\n\n\n\nWas sind Gleitkommazahlen?\n\n\n\nDezimalzahlen können sehr viele Nachkommastellen haben. Um sie effizient zu speichern, nutzt der Rechner intern die wissenschaftliche Schreibweise, z. B. 2.1e-4 statt 0.00021. Dadurch werden führende oder nachfolgende Nullen vermieden. Statt der vollständigen Zahl speichert man nur die signifikanten Stellen (hier: 2.1, genannt Mantisse) und den Exponenten (hier: -4), sowie das Vorzeichen der Zahl (hier: positiv).\nDas wird besonders bei extrem kleinen oder großen Zahlen deutlich: 3.23e10 statt 32300000000 oder 1.2e-9 statt 0.0000000012. Der Dezimalpunkt „gleitet“ dabei entsprechend dem Exponenten, woher der Name Gleitkommazahl (floating-point) stammt.\nIm Gegensatz dazu gibt es Festkommazahlen, bei denen der Dezimalpunkt immer an einer festen Stelle steht (z. B. Währungsbeträge wie 12.34 Euro). Diese sind in der Informatik seltener, weil sie eine feste Genauigkeit haben und weniger flexibel sind. Sie werden nur in speziellen Anwendungen genutzt.\n\n\n\n\nC arbeitet u.a. mit int, float, double (Gleitkommazahl mit doppelter Genauigkeit), char (für einzelne Zeichen; Strings werden als Zeichenarrays gespeichert, sog. C-Strings); bool kann seit C99 über einen Header eingebunden werden.\nC++ führt u.a. eine String-Klasse ein (das Wort Klasse erklären wir in der objektorientierten Programmierung).\nJava kennt primitive Datentypen wie int, double, char und boolean, sowie die Klasse String für Texte.\nJavaScript nutzt Number für Ganz- und Gleitkommazahlen, Boolean für Wahrheitswerte und String für Texte.\n\n\n\nStatisch oder dynamisch typisiert?\nProgrammiersprachen unterscheiden sich darin, wie flexibel sie mit Datentypen umgehen. Man kann grundsätzlich zwischen zwei Arten unterscheiden:\nStatisch typisierte Sprachen: Datentypen werden vor der Laufzeit durch den Programmierer oder die Programmiererin definiert (z. B. in C, Java). Typenfehler (man versucht im Code etwas mit einem Datentyp zu machen, was nicht erlaubt ist) werden beim Kompilieren erkannt, was Sicherheit und Geschwindigkeit bietet, aber weniger flexibel ist.\nBeispiel-Code in C: int zahl = 42; Bei der Deklaration der Variable zahl muss bereits ihr Typ angegeben werden, hier: Integer. Sie darf im gesamten Programm niemals für einen anderen Typen verwendet werden (in vielen Fällen würde die Zuweisung trotzdem gelingen, aber durch ein implizites Casting (siehe unten) ein evtl. unbeabsichtigter Datenverlust stattfinden).\nDynamisch typisierte Sprachen: Typen werden automatisch zur Laufzeit bestimmt (z. B. in Python, JavaScript). Das schenkt eine höhere Flexibilität: Wir können an einer Stelle zahl = 42 und an einer anderen Stelle zahl = \"Apfel\" schreiben. Allerdings können sich so auch leichter Fehler einschleichen. Einen exemplarischen Typenfehler in Python zeigt der folgende Code:\n\nx = \"42\"\ny = \"2\"\nz = x / y # diese Zeile führt zu einem Fehler!\n# Strings können nicht durcheinander dividiert werden. \n# Oder könnten Sie \"Auto\" durch \"Apfel\" teilen?!\n\n\n\nKurzer Ausblick auf weitere Datentypen in Python\nPython verfügt von Haus aus über weitere praktische Datentypen, von denen wir nur ein paar hier vorstellen möchten. Einige davon werden wir in späteren Kapiteln noch genauer untersuchen und verstärkt einsetzen:\n\nshopping_list = ['apples', 'bananas', 'bread']\ntype(shopping_list)\n\nlist\n\n\nDer Datentyp list wird für eine geordnete Ansammlung von Elementen verwendet. Die Elemente werden wie im Beispiel zwischen eckigen Klammern ([]) aufgelistet. ‘Geordnet’ heißt in diesem Zusammenhang, dass die Elemente eine feste Reihenfolge haben: In unserem Beispiel ist 'apples' das erste Element, 'bananas' das zweite, usw. Wir können über den sog. Indexzugriff auch gezielt auf das erste, zweite, dritte, … Element einer Liste zugreifen:\n\nshopping_list[0]  # immer bei 0 anfangen zu zählen!\n\n'apples'\n\n\n\nshopping_list[1]  # Index 1 entspricht dem zweiten Element\n\n'bananas'\n\n\n\nshopping_list[2]  # Index 2 entspricht dem dritten Element\n\n'bread'\n\n\nEs gibt auch ungeordnete Ansammlungen von Elementen:\n\nfavorite_colors = {'red', 'blue', 'green'}\ntype(favorite_colors)\n\nset\n\n\nMit den geschweiften Klammern haben wir ein set angelegt, das einer mathematischen Menge entspricht: Es gibt keine Reihenfolge (der Indexzugriff funktioniert nicht!), außerdem kommt jedes Element nur einmal vor. Fügt man der obigen Menge die Farbe 'red' ein zweites Mal hinzu, gibt es das Element trotzdem nur einmal:\n\nfavorite_colors.add('red')  # wir fügen ein bereits vorhandenes Element hinzu\nprint(favorite_colors)\n\n{'blue', 'green', 'red'}\n\n\n\nfavorite_colors.add('yellow')  # wir fügen ein neues Element hinzu\nprint(favorite_colors)\n\n{'blue', 'green', 'yellow', 'red'}\n\n\nListen und Sets können mit verschiedenen Datentypen gefüllt und auch verschachtelt werden. Wir demonstrieren es am Beispiel einer Liste:\n\n# in dieser Liste befinden sich Einträge vom Typ\n# int, float, str und wiederum list\ncrazy_list = [1, 0.5, \"Monty Python\", [42, True]]\nprint(crazy_list)\n\n[1, 0.5, 'Monty Python', [42, True]]\n\n\n\ncrazy_list[0]  # erstes Element: der Integer 1\n\n1\n\n\n\ncrazy_list[3]  # viertes Element: die Liste [42, True]\n\n[42, True]\n\n\n\ncrazy_list[3][0]  # Zugriff auf das erste Element der Liste [42, True]\n\n42\n\n\nEin besonderer Datentyp, den wir nicht in vielen Programmiersprachen finden, ist complex für die Darstellung komplexer Zahlen. Dabei stellt j die imaginäre Einheit dar:\n\ntype(1+2j)  # komplexe Zahl mit Realteil 1 und Imaginärteil 2\n\ncomplex\n\n\n\nprint(\"Das Quadrat von j ist: \",(1j)**2) \n\nDas Quadrat von j ist:  (-1+0j)\n\n\nDie letzte Ausgabe sieht auf den ersten Blick vielleicht etwas kryptisch aus, aber belegt, dass j die Wurzel aus -1 ist. Es ist nun besonders einfach mit komplexen Zahlen zu rechnen:\n\n(1+2j)*(-2+4j)  # rechnen mit komplexen Zahlen\n\n(-10+0j)\n\n\n\nÜbung: Recherchieren Sie zum Datentyp dict und legen Sie ein Dictionary aus Namen und Telefonnummern an.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datentypen und ihre Repräsentation</span>"
    ]
  },
  {
    "objectID": "notebooks/3-datatypes.html#instanzen-und-referenzen",
    "href": "notebooks/3-datatypes.html#instanzen-und-referenzen",
    "title": "5  Datentypen und ihre Repräsentation",
    "section": "5.2 Instanzen und Referenzen",
    "text": "5.2 Instanzen und Referenzen\nWir wollen jetzt verstehen, wie Daten gespeichert werden und was eine Variable genau ist. Dieser Absatz erscheint beim ersten Lesen womöglich etwas theoretisch, sein Verständnis hilft aber später enorm bei der Vermeidung vieler Missverständnisse und Fehler.\n\nEin vereinfachtes Speichermodell\nAn dieser Stelle benötigen wir ein einfaches Modell eines Speichers: Stellen wir uns vor, unser Programm hat Zugriff auf eine Reihe von Speicherstellen, in denen es Daten ablegen kann. Die kleinste Informationsmenge, die wir speichern können, ist ein Bit, das entweder den Wert 0 oder 1 annehmen kann. Um jedoch komplexere Informationen zu speichern, arbeiten wir in der Regel mit Gruppen aus 8 Bits, die wir als Byte bezeichnen. In unserem Modell stellen wir uns den Speicher als eine große Zahl freier Bytes vor, die alle hintereinander aufgereiht sind. Jedes Byte kann über eine eindeutige Adresse identifiziert werden (die Adressen sind in der C-Programmierung wichtig, nicht so sehr in Python). Das einfache Speichermodell ist in Abbildung 5.1 skizziert.\n\n\n\n\n\n\nAbbildung 5.1: Vereinfachtes Speichermodell\n\n\n\n\n\nInstanzen\nWenn wir einen bestimmten Wert speichern wollen (z.B. eine Zahl oder einen Text), brauchen wir in der Regel mehr als eine Speicherstelle. Die genaue Größe hängt davon ab, welcher Datentyp gespeichert wird und wie viel Information dieser enthält (ein einzelner Buchstabe ist sicherlich weniger Information als ein ganzer Satz). Daten werden also je nach Datentyp und Informationsgehalt in unterschiedlich vielen Speicherzellen gespeichert. Um die Verwaltung des Speichers kümmert sich der Python-Interpreter, er ermittelt also auch wie viele Zellen benötigt werden und speichert die Daten. Nun aber Schritt für Schritt: Was passiert, wenn wir folgende einfache Zeile programmieren?\n\ntext = \"Hi\"\n\nZunächst ermittelt der Interpreter den Speicherbedarf für den String-Wert \"Hi\", weist ihm einen freien Platz im Speicher zu und speichert dort die Daten ab (natürlich nicht in menschenlesbarer Form, sondern binär kodiert, wie wir später noch genauer erklären werden). Das Ergebnis nennt man eine Instanz: Eine Instanz ist ein konkretes Datenobjekt im Speicher, das nach den Vorgaben eines bestimmten Datentyps erzeugt und gespeichert wurde. Es kann sich dabei auch um eine Zahl handeln, z.B. -5.25. Wichtig an dieser Stelle: Zu einer Instanz gehört ein bestimmter Datentyp!\nBisher haben wir nur die rechte Seite der Zuweisung betrachtet: Das Literal erzeugt eine Instanz im Speicher. Was bewirkt die linke Seite der Zuweisung?\n\n\nReferenzen\nWenn wir den String \"Hi\" keiner Variable zugeordnet hätten, wäre die erzeugte Instanz für uns nicht mehr greifbar. Sie würde nutzlos im Speicher rumliegen! In Python würde ein Aufräummechanismus (der sog. Garbage Collector) diese Instanz wieder aus dem Speicher löschen. Glücklicherweise haben wir den Wert jedoch der Variable mit dem Namen text zugewiesen. Die Variable text referenziert die Instanz im Speicher, wodurch wir mit der Instanz arbeiten können. Eine Variable ist also eine bloße Referenz und von der eigentlichen Instanz (den “echten Daten”) zu unterscheiden. Referenzen können Sie sich wie Hinweisschilder oder Wegweiser vorstellen: Sie zeigen auf die Instanz, sind aber nicht selbst die Instanz.\nIn Abbildung 5.2 wird der Unterschied zwischen Instanzen und Referenzen bildlich dargestellt.\n\n\n\n\n\n\nAbbildung 5.2: Referenzen und Instanzen. Instanzen sind konkrete Datenobjekte im Speicher. Variablen verweisen auf diese Instanzen und werden deshalb auch Referenzen genannt. Im gezeigten Beispiel liegen eine String-Instanz und eine Float-Instanz im Speicher und werden jeweils von einer Variable referenziert. Eine Instanz kann aber auch mehrfach oder gar nicht referenziert werden (in letzterem Fall wird sie aber vom Garbage Collector wieder aufgeräumt)\n\n\n\n\n\n\n\n\n\nStrenggenommen ist es nicht korrekt, zu sagen, eine Variable hätte einen bestimmten Datentyp. Der Datentyp gehört immer zur referenzierten Instanz. Wenn wir in einer anderen Zeile text = 123 schreiben, zeigt die Variable text plötzlich auf eine Instanz vom Typ int. Dennoch ist es im alltäglichen Sprachgebrauch üblich zu sagen, “Die Variable text hat den Typ string.” Merken Sie sich jedoch, dass diese Formulierung ungenau ist!\n\n\n\n\n\nIdentität einer Instanz\nJede Instanz besitzt in Python eine eindeutige Identität, die durch die Funtkion id() abgefragt werden kann und wie ein Fingerabdruck der Instanz verstanden werden kann:\n\nid(text)  # mit id() erhält man die Identität\n\n2122758446064\n\n\nHier wurde die eindeutige ID der Instanz ausgegeben, die von text referenziert wird. Wenn wir die Variable auf eine andere Instanz zeigen lassen, ändert sich auch die Identität:\n\ntext = \"Guten Tag\"\nid(text)\n\n2122752622320\n\n\n\n\n\n\n\n\nKurze Zusammenfassung\n\n\n\nEine Instanz ist ein konkretes Objekt im Speicher. Es hat drei Merkmale: Eine eindeutige Identität, einen Datentyp und einen Wert. Eine Variable ist ein symbolischer Name, der eine Instanz referenziert (man sagt auch: auf eine Instanz zeigt).\n\n\n\n\nExkurs: Seiteneffekte - Wenn mehrere Referenzen auf dieselbe Instanz zeigen.\nEs kann vorkommen, dass mehrere Variablen auf ein und dieselbe Instanz zeigen und dadurch unerwartete Effekte passieren. Dazu betrachten wir zunächst ein Beispiel ohne Seiteneffekte und danach ein zweites mit solchen Effekten.\nErstes Beispiel (keine Seiteneffekte):\n\na = 12\nb = a  # a wird b zugewiesen\nprint(id(a), id(b))\n\n140715933117208 140715933117208\n\n\nAn dieser Stelle erhalten wir identische Identitäten, d.h. a und b referenzieren dieselbe Instanz! Python hat festgestellt, dass es keinen Grund gibt, eine zweite Instanz anzulegen und verhält sich ökonomisch (Speicher sparend und Laufzeit sparend, denn das Anlegen von Instanzen kostet Zeit). Wir führen unser Beispiel fort:\n\nb += 10  # b wird verändert\nprint(id(a),id(b))\n\n140715933117208 140715933117528\n\n\nWie wir sehen, zeigt b jetzt auf eine andere Instanz (eine mit Wert 22), während a immer noch unverändert auf die ursprüngliche verweist. In diesem Beispiel ist nichts unerwartetes geschehen. Damit wir nicht immer die Identitäten mühsam miteinander vergleichen müssen, können wir auch den Operator is verwenden:\n\na is b  # vergleicht die Identitäten der referenzierten Instanzen\n# True heißt: a und b zeigen auf dieselbe Instanz\n# False heißt: a und b zeigen auf unterschiedliche Instanzen\n\nFalse\n\n\nZweites Beispiel (mit Seiteneffekten):\nWir wiederholen das Experiment von oben, diesmal aber mit einem anderen Datentyp (einer Liste):\n\nmy_shopping_list = ['apples', 'oranges', 'paper']\nyour_shopping_list = my_shopping_list\nprint(id(my_shopping_list), id(your_shopping_list))\n\n3130323362688 3130323362688\n\n\nBis hierin verhalten sich die beiden Beispiele gleich. Jetzt manipulieren wir eine der Variablen:\n\nyour_shopping_list.append('shoes')\nprint(id(my_shopping_list), id(your_shopping_list))\n\n3130323362688 3130323362688\n\n\nDie Identitäten sind immer noch gleich! Das bestätigt auch der is-Operator:\n\nyour_shopping_list is my_shopping_list\n\nTrue\n\n\nAber was bedeutet das für die ursprüngliche Liste?\n\nprint(my_shopping_list)\n\n['apples', 'oranges', 'paper', 'shoes']\n\n\nDie ursprüngliche Liste wurde verändert, obwohl wir die Variable my_shopping_list gar nicht angefasst haben! Man spricht in diesem Zusammenhang von einem Seiteneffekt.\nSpäter gehen wir genauer auf dieses Phänomen ein (es tritt nur bei sog. mutable Datentypen auf, zu denen die Liste gehört: Instanzen dieser Datentypen sind veränderlich, während bei immutable Datentypen keine nachträgliche Veränderung von Instanzen erlaubt ist). An dieser Stelle soll es nur illustrieren, warum das Verständnis von Instanzen und Referenzen so wichtig für angehende Programmiererinnen und Programmierer ist. Vielleicht haben Sie auch bereits von Pointern in der Sprache C gehört: Obwohl sich das Konzept von den hier vorgestellten Referenzen unterscheidet, besteht dieselbe Gefahr: Mehrere Pointer können auf dasselbe Objekt zeigen; eine Code-Stelle kann Änderungen bewirken, mit denen man an einer anderen Stelle gar nicht rechnet.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datentypen und ihre Repräsentation</span>"
    ]
  },
  {
    "objectID": "notebooks/3-datatypes.html#binäre-darstellung-von-daten",
    "href": "notebooks/3-datatypes.html#binäre-darstellung-von-daten",
    "title": "5  Datentypen und ihre Repräsentation",
    "section": "5.3 Binäre Darstellung von Daten",
    "text": "5.3 Binäre Darstellung von Daten\nWir wissen nun, dass im Speicher eines Computers Instanzen der benötigten Daten erzeugt werden und wir über Referenzen auf diese zugreifen können. Wie aber sieht so eine Instanz im Speicher genau aus? Computer arbeiten auf einer fundamentalen Ebene mit binären Daten, also Zahlen, die nur aus den Ziffern 0 und 1 bestehen. Diese beiden Zustände repräsentieren die grundlegenden Bits (Binary Digits), mit denen alle Arten von Daten – wie Zahlen, Texte oder Bilder – gespeichert und verarbeitet werden. Mit anderen Worten: Eine Zahl (z.B. \\(-5.25\\)) oder ein Wort (z.B. “Apfel”) muss durch eine Transformation, genannt Kodierung, als Binärzahl dargestellt werden können (und umgekehrt). Die Art der Kodierung hängt davon ab, welcher Datentyp dargestellt werden soll.\n\n\n\n\n\n\nExkurs: Einführung ins Binärsystem\n\n\n\nDas Binärsystem (oder Dualsystem) ist ein Zahlensystem zur Basis 2, das nur zwei Ziffern verwendet: 0 und 1. Es ist die Grundlage aller digitalen Systeme, da Computer mit diesen beiden Zuständen (z.B. Strom an/aus) arbeiten. Die natürlichen Zahlen in aufsteigender Reihenfolge sehen binär so aus: 0, 1, 10, 11, 100, 101, usw. Zur Abgrenzung von Dezimalzahlen verwendet man gelegentlich eine tiefgestellte 2 (z.B. \\((100)_2\\)) oder das Präfix \\(0\\text{b}\\) (z.B. \\(0\\text{b}100\\)).\n\nUmwandlung von Binär- nach Dezimalsystem\nUm eine Binärzahl in eine Dezimalzahl umzuwandeln, multipliziert man jede Ziffer mit \\(2^{\\text{Position}}\\), beginnend von rechts mit der Position 0, und addiert die Ergebnisse.\nBeispiel: Binärzahl \\((1011)_2 = 1\\cdot 2^3+0\\cdot 2^2 + 1\\cdot 2^1+1\\cdot 2^0=8+0+2+1=11\\) (Dezimalzahl).\n\n\nUmwandlung von Dezimal- nach Binärsystem\nEine Dezimalzahl wird durch wiederholtes Teilen durch 2 in eine Binärzahl umgewandelt. Die Reste ergeben die Binärzahl (von unten nach oben lesen).\nBeispiel: Die Dezimalzahl 13 soll binär dargestellt werden. \n\\(13 : 2 = 6, \\text{ Rest: } 1\\) \\(6 : 2 = 3, \\text{ Rest: } 0\\) \\(3 : 2 = 1, \\text{ Rest: } 1\\) \\(1 : 2 = 0, \\text{ Rest: } 1\\)\nBinärzahl (Reste von unten nach oben lesen): \\(1101\\)\n\n\nStellen hinter dem Komma in binärer Schreibweise\nBei Kommazahlen entsprechen die Stellen hinter dem Komma negativen Exponenten. Wir kennen das vom Dezimalsystem: \\(0.243 = 2\\cdot 10^{-1} + 4\\cdot 10^{-2}+ 3\\cdot 10^{-3}.\\)\nAnalog im Binärsystem: \\((0.101)_2 = 1 \\cdot 2^{-1}+0\\cdot 2^{-2} + 1\\cdot 2^{-3} = 0.625\\) als Dezimalzahl.\n\n\n\n\nBinäre Darstellung von Ganzzahlen\nGanzzahlen (Integer) werden direkt im Binärsystem gespeichert. Dabei gibt es eine Unterscheidung:\n\nPositive Ganzzahlen: Sie werden als reine Binärzahlen dargestellt, z. B. ist die Dezimalzahl 5 im Binärsystem 101.\nNegative Ganzzahlen: Hier gibt es verschiedene Ansätze. In der Regel wird das höchste Bit als Vorzeichenbit verwendet, das angibt, ob die Zahl positiv (Vorzeichenbit = 0) oder negativ (Vorzeichenbit = 1) ist. Dann muss nur noch der Betrag der Zahl kodiert werden, wofür es wiederum verschiedene Methoden gibt, auf die wir im Rahmen dieser Einführung nicht näher eingehen (für Interessierte empfehlen wir: Zweierkomplement.)\n\nInteger können in Python mit dem Befehl bin() ganz einfach ins Binärsystem umgewandelt werden:\n\nprint(\"Dezimal:\", 11, \"Binär:\", bin(11))\nprint(\"Dezimal:\", 13, \"Binär:\", bin(13))\nprint(\"Dezimal:\", 423, \"Binär:\", bin(423))\n\nDezimal: 11 Binär: 0b1011\nDezimal: 13 Binär: 0b1101\nDezimal: 423 Binär: 0b110100111\n\n\nUmgekehrt geht es sogar noch viel einfacher, wie die folgenden Beispiele zeigen:\n\n# ein binäres Litera 0b... wird automatisch umgewandelt: \nprint(\"Binär:\", \"0b1011\", \"Dezimal:\", 0b1011) \nprint(\"Binär:\", \"0b1101\", \"Dezimal:\", 0b1101)\nprint(\"Binär:\", \"0b110100111\", \"Dezimal\", 0b110100111)\n\nBinär: 0b1011 Dezimal: 11\nBinär: 0b1101 Dezimal: 13\nBinär: 0b110100111 Dezimal 423\n\n\n\n\nBinäre Darstellung von Gleitkommazahlen\nGleitkommazahlen (wie 3.14 oder -0.001) werden durch den IEEE 754-Standard dargestellt, der folgende Struktur nutzt:\n\nVorzeichen (1 Bit): Gibt an, ob die Zahl positiv (Vorzeichenbit = 0) oder negativ (Vorzeichenbit = 1) ist.\nExponent: Bestimmt die Skalierung der Zahl.\nMantisse: Speichert die signifikanten Stellen der Zahl.\n\n\n\n\n\n\n\nBeispiel Gleitkommazahl-Darstellung\n\n\n\nDie Zahl -5.25 soll binär mit insgesamt 32 Bits dargestellt werden. Die Aufteilung der Bits soll so erfolgen: 1 Bit für das Vorzeichen, 8 Bits für den Exponenten und 23 Bits für die Mantisse.\nDas Vorzeichenbit ist offensichtlich 1 (für negativ), nun müssen wir noch Exponent und Mantisse kodieren. Dazu drücken wir den Betrag (das Vorzeichen interessiert uns nicht mehr) binär und wissenschaftlich notiert aus: \\(5.25 = (101.01)_2 = (\\textcolor{blue}{1.0101})_2 \\cdot 2^{\\textcolor{green}2}\\).\nDaraus ergibt sich:\n\nDer \\(\\textcolor{green}{\\text{Exponent}}\\) ist 2, allerdings noch im Zehnersystem ausgedrückt. Mit 8 Bits binär dargestellt wäre er \\((00000010)_2\\). Man verwendet aber noch einen Trick, um negative Exponenten nicht wieder mit einem Vorzeichenbit unterscheiden zu müssen, und addiert 127 zum eigentlichen Exponenten: Unser Exponent 2 wird also folgendermaßen kodiert: \\(127+2=129=(10000001)_2\\).\nDie \\(\\textcolor{blue}{\\text{Mantisse}}\\) im Binärsystem ist 1.0101. Beim Kodieren wird die führende 1 weggelassen, weil sie immer da ist – ein Trick zur Speicheroptimierung. Die Stellen hinter dem Komma werden in 23 Bits abgelegt: \\((01010000000000000000000)_2\\)\n\nDie komplette Kodierung lautet: \\(1\\ 10000001\\ 01010000000000000000000\\).\n\n\nGleitkommazahlen bieten durch diese Struktur eine große Reichweite und Präzision, allerdings entstehen dabei gelegentlich Rundungsfehler, da nicht alle Dezimalzahlen im Binärsystem mit endlich vielen Stellen exakt darstellbar sind. Ein wichtiger Merksatz lautet an dieser Stelle bereits: Vergleichen Sie niemals zwei Gleitkommazahlen auf exakte Gleichheit, sondern verwenden Sie immer eine kleine Toleranz für Rundungsfehler.\n\n\nBinäre Darstellung von Strings\nStrings bestehen aus einer Folge von Zeichen, die jeweils durch Zahlencodes repräsentiert werden:\n\nASCII: Jedes Zeichen wird durch eine 7-Bit-Zahl dargestellt (z. B. A = 65 = 0b01000001). Der Code deckt eine Auswahl von druckbaren Zeichen (lateinisches Alphabet in Groß- und Kleinschreibung, unsere 10 Ziffern, Interpunktions- und Sonderzeichen) und nicht-druckbare Zeichen (z.B. Tabulator oder Protokollzeichen für Übertragungsende oder Bestätigung) ab. Für englische Texte ist der Zeichensatz völlig ausreichend, er beinhaltet aber weder deutsche Umlaute (‘ä’,‘ü’,etc.), noch chinesische Schriftzeichen oder Emojis - um nur einige Beispiele von Zeichen zu nennen, die über ASCII hinausgehen. Aus diesem Grund gibt es erweiterte Zeichensätze. Durch Erweiterung um ein achtes Bit entstanden verschiedene Zeichensätze für unterschiedliche Sprachen (z.B. Latin-1 für westeuropäische Sprachen, inkl. der deutschen Umlaute).\nUnicode (UTF-8): Unicode ist ein universeller Zeichensatz, der mehrere Sprachen mit nur einem Zeichensatz umfassen soll. Es gibt mehrere Kodierungen für Unicode, von denen UTF-8 (UTF = Unicode Transformation Format) die am weitesten verbreite Variante darstellt. UTF-8 kodiert Zeichen mit variabler Byte-Anzahl: Dabei wird ein Unicodezeichen in 1 bis 4 Bytes kodiert. Die Codewerte 0 bis 127 entsprechen dem ASCII-Zeichensatz und werden in einem einzigen Byte kodiert, wobei das höchstwertige Bit stets 0 ist. Mithilfe des achten Bits kann ein längeres Unicode-Zeichen eingeleitet werden, das sich auf 2, 3 oder 4 Byte erstreckt. Beispiele: A → 01000001 (1 Byte), 😊 → 11110000 10011111 10011000 10000010 (4 Bytes).\n\nAbschließend stellen wir unser früheres Beispiel für Instanzen und Referenzen noch einmal dar, diesmal aber mit binär kodierten Werten (Abbildung 5.3).\n\n\n\n\n\n\nAbbildung 5.3: Instanzen und Referenzen revisited. Diesmal mit binär kodierten Werten.\n\n\n\nNoch ein paar Bemerkungen zum Speicherbedarf:\n\nIn C liegen im Speicher nur die rohen Daten, daher benötigt ein Float mit der oben dargestellten Kodierung tatsächlich nur vier Bytes odder ein ASCII-Zeichen nur ein Byte.\nPython speichert viel mehr ab: Zu jedem Wert werden Metadaten, wie Datentyp, Identität, Referenz-Zähler, etc. abgespeichert. Außerdem verwendet Python eigene Optimierungen, z.B. im Umgang mit Strings oder kleinen Integern. Daher stimmt die Größe einer Instanz nicht mit der Größe der “Rohdaten” überein.\nPython passt den Speicherbedarf automatisch an die Informationsmenge an, so werden für eine sehr große Ganzzahl automatisch mehr Bytes verwendet, als für eine kleine Ganzzahl. In C macht das niemand für Sie: Ein Datentyp stellt eine bestimmte Zahl an Bytes zur Verfügung, reicht diese nicht aus, müssen Sie selbst einen größeren Datentyp verwenden!\nMit der Funktion getsizeof() aus der Bibliothek sys können Sie die Zahl der Bytes abfragen. Beispiel:\n\n\nimport sys\nsys.getsizeof(\"42\")  # Antwort: Größe in Bytes\n\n51",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datentypen und ihre Repräsentation</span>"
    ]
  },
  {
    "objectID": "notebooks/3-datatypes.html#casting-typumwandlung",
    "href": "notebooks/3-datatypes.html#casting-typumwandlung",
    "title": "5  Datentypen und ihre Repräsentation",
    "section": "5.4 Casting (Typumwandlung)",
    "text": "5.4 Casting (Typumwandlung)\nCasting oder Typumwandlung bezeichnet das Konvertieren eines Wertes von einem Datentyp in einen anderen. Dies ist sowohl in statisch als auch dynamisch typisierten Sprachen nützlich, um unterschiedliche Datentypen zu kombinieren oder explizite Anforderungen zu erfüllen. Es gibt dabei implizites Casting durch die Programmiersprache und explizites Casting durch den Programmierer oder die Programmiererin.\n\nImplizites Casting\nDie Programmiersprache übernimmt die Typumwandlung automatisch bei kompatiblen Typen (z.B. Integer zu Float). Im folgenden Beispiel wird eine Integer-Zahl zu einer Float gecastet, um eine Summe zu bilden (das Ergebnis ist wieder ein Float):\n\nint_number = 4\nfloat_number = 3.2\nresult = int_number + float_number\ntype(result)\n\nfloat\n\n\nEin zweites Beispiel demonstriert das implizite Casting von Wahrheitswerten zu Integern:\n\nnumber = 11\nboolean = True\nresult = number + boolean  # implizites Casting von bool zu int\nprint(\"Result: \", result)\n\nResult:  12\n\n\n\n\n\n\n\n\nVorsicht\n\n\n\nUnbeabsichtigtes implizites Casting kann zu unerwarteten Fehlern führen!\nIn C kompiliert beispielsweise folgender Code:\nfloat x = 3.99;\nint y = x;\nAllerdings ist der Wert von y nicht 3.99 und auch nicht 4, sondern 3. Beim impliziten Casting von float nach int gehen alle Nachkommastellen verloren!\n\n\nHinweis: Python ist strenger beim impliziten Casting und erlaubt es oft nicht, damit sich keine ungewollten Effekte einschleichen. Eine Ausnahme stellen implizite Castings nach bool bei Bedingungen von Verzweigungen und Schleifen dar (siehe nächstes Kapitel). Hier wird alles, was ungleich 0 bzw. nicht-leer ist, implizit als True interpretiert. Im Umkehrschluss: 0 oder leer (z.B. ein leerer String) bedeutet False.\n\n\nExplizites Casting\nBeim expliziten Casting fordern wir beim Programmieren die Typumwandlung ausdrücklich an. Das ist z.B. dann erforderlich, wenn die Programmiersprache implizites Casting an einer Stelle nicht unterstützt, wir die Umwandlung aber bewusst durchführen wollen. Python bietet hierfür intuitive Funktionen an, die nach dem gewünschten Zieltyp benannt sind (float(), int(), str(), bool()). Diese Funktionen übernehmen einen Input-Wert, versuchen diesen in den gewünschten Zieltyp umzuwandeln und geben das gecastete Ergebnis zurück. Der zurückgegebene Wert kann z.B. wieder einer Variable zugewiesen werden.\nBeispiele:\n\ntext = \"Meine Glückszahl ist \" + str(11) # Int -&gt; Str\nprint(text)\nresult = \"Das Messergebnis beträgt \" + str(5.4e-2) + \" A.\"\nprint(result)\n\nMeine Glückszahl ist 11\nDas Messergebnis beträgt 0.054 A.\n\n\n\npi = 3.14\npi = int(pi)  # Float -&gt; Int\nprint(pi)  # alle Nachkommastellen gingen verloren!\n\n3\n\n\n\nnumber = 123\ncondition = bool(123)  # Int -&gt; Bool\nprint(condition)\n\nTrue\n\n\n\ncondition = False\nnumber = int(condition)  # Casting Bool -&gt; Int\nprint(number)\n\n0\n\n\n\ncondition = False\n\"The condition is \" + str(condition)  # Bool -&gt; String\n\n'The condition is False'\n\n\nWir haben bereits die input-Funktion kennengelernt und darauf hingewiesen, dass sie stets Strings zurückgibt. Wenn man aber mit einer User-Eingabe rechnen möchte, muss diese zunächst in einen Zahlentyp umgewandelt werden. Hierzu folgende Beispiele:\n\nage = int(input(\"Wie alt sind Sie? \"))  # Casting: str -&gt; int\nage += 10  # wäre mit str nicht möglich!\nprint(f\"In 10 Jahren sind Sie {age} Jahre alt.\")\n\nWie alt sind Sie?  22\n\n\nIn 10 Jahren sind Sie 32 Jahre alt.\n\n\n\nwidth = float(input(\"Breite: \"))  # Casting: str -&gt; float\nheight = float(input(\"Höhe: \"))  # Casting: str -&gt; float\narea = width * height  # wäre mit str nicht möglich\nprint(\"Fläche: \", area)\n\nBreite:  12.4\nHöhe:  7.8\n\n\nFläche:  96.72\n\n\nAber auch explizites Casting ist nicht in jedem Fall möglich und kann zu Fehlern führen. Z.B. weiß der Python-Interpreter nicht, wie er die folgenden Castings durchführen soll:\n\nfloat(\"Apfel\")  # Fehler! Wie soll \"Apfel\" als float interpretiert werden?\nint(\"Haus\")  # Fehler!\nint([1, 2, 3, 1.2]) # Fehler! Wie soll list -&gt; int gecastet werden?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datentypen und ihre Repräsentation</span>"
    ]
  },
  {
    "objectID": "notebooks/4-controls.html",
    "href": "notebooks/4-controls.html",
    "title": "6  Kontrollstrukturen",
    "section": "",
    "text": "6.1 Verzweigungen\nIn der Programmierung sind Kontrollstrukturen essenziell, um den Ablauf eines Programms zu steuern. Sie ermöglichen es, Entscheidungen zu treffen, Wiederholungen durchzuführen und den Programmfluss gezielt zu lenken. Ohne sie würden Programme einfach nur von oben nach unten ausgeführt werden, ohne auf Eingaben oder Bedingungen zu reagieren.\nWir unterscheiden zwischen zwei grundsätzlichen Arten von Kontrollstrukturen: Verzweigungen und Schleifen.\nVerzweigungen oder bedingte Anweisungen sind nichts anderes als Fallunterscheidungen: “Wenn eine bestimmte Bedingungen erfüllt ist, tue dies, andernfalls tue das.” In den meisten Programmiersprachen, wird dies durch eine if-Anweisungen realisiert (die genaue Syntax unterscheidet sich von Sprache zu Sprache). Das folgende Codebeispiel zeigt, wie es in Python funktioniert:\nnumber = 42\n\nif number &gt; 0:\n    print(\"Die Zahl ist positiv!\")\n\nDie Zahl ist positiv!\nIn diesem einfachen Beispiel, wird die Bedingung number &gt; 0 geprüft. Ist die Bedingung erfüllt, werden die eingerückten Anweisungen ausgeführt, in diesem Beispiel der print-Befehl.\nDie Funktionsweise einer if-Anweisung lässt sich mit einem Flussdiagramm (Abbildung 6.1) anschaulich darstellen.\nWichtig ist die korrekte Syntax: Die Anweisung wird mit dem Schlüsselwort if eingeleitet, gefolgt von der Bedingung und einem Doppelpunkt. Alle Anweisungen, die bei erfüllter Bedingung ausgeführt werden sollen, müssen darunter eingerückt sein. Wir betrachten ein zweites Beispiel:\nmax_load = 5000  # Maximale Belastung in Newton\ncurrent_load = float(input(\"Belastung in Newton: \"))  # z.B. ein Messergebnis\n\nif current_load &gt; max_load:\n    print(\"Warnung: Belastung überschritten!\")\n    factor = (current_load - max_load) / max_load\n    print(\"Maximale Belastung um \", round(100*factor,2),\"% überschritten!\")\n\nBelastung in Newton:  5200\n\n\nWarnung: Belastung überschritten!\nMaximale Belastung um  4.0 % überschritten!\nAktuell beschränken sich unsere Beispiele zu Zwecken der Illustration auf simple Ausgaben, aber natürlich gibt es keine Grenzen für die Komplexität, die in einem if-Block ausgeführt werden kann.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Kontrollstrukturen</span>"
    ]
  },
  {
    "objectID": "notebooks/4-controls.html#verzweigungen",
    "href": "notebooks/4-controls.html#verzweigungen",
    "title": "6  Kontrollstrukturen",
    "section": "",
    "text": "Abbildung 6.1: Flussdiagramm zur if-Anweisung\n\n\n\n\n\n\n\nVerzweigungen mit if und else\nIn den meisten Fällen verwendet man erweiterte Varianten der if-Anweisung. Zum Beispiel möchte man auch bestimmte Anweisungen ausführen, falls die Bedingung nicht erfüllt ist. Dafür ergänzt man einen else-Block:\n\nmax_load = 5000  # Maximale Belastung in Newton\ncurrent_load = float(input(\"Belastung in Newton: \"))\n\nif current_load &gt; max_load:\n    print(\"Warnung: Belastung überschritten!\")\n    factor = (current_load - max_load) / max_load\n    print(\"Maximale Belastung um \", round(100*factor,2),\"% überschritten!\")\nelse:\n    print(\"Alles im grünen Bereich!\")\n\nBelastung in Newton:  4600\n\n\nAlles im grünen Bereich!\n\n\nAuch diese Variante stellen wir im Flussdiagramm dar (Abbildung 6.2).\n\n\n\n\n\n\nAbbildung 6.2: Flussdiagramm zur Verzweigung mit if und else\n\n\n\nWir haben die Flussdiagramme bewusst so gezeichnet, dass die Einrückungen, wie sie von Python verlangt werden, auch im Diagramm ersichtlich sind: Die Schlüsselwörter if und else befinden sich auf selber Höhe, die jeweiligen Anweisungsblöcke sind darunter eingerückt.\n\n\nVerzweigungen mit if, elif und else\nSchließlich können wir unsere Verzweigung noch um sog. “else-if-Zweige” erweitern (das Python-Keyword heißt elif). Der Sinn davon: Wenn eine erste Bedingung falsch ist, möchte man vielleicht eine weitere Bedingung prüfen. Ist auch diese falsch, könnte noch eine dritte (vierte, fünfte, …) Bedingung interessant sein. In Worten: “Wenn Bedingung1 wahr ist, tue A, andernfalls prüfe Bedingung2. Ist Bedingung2 wahr, tue B, andernfalls prüfe Bedingung3 usw.” Wichtig zu verstehen ist, dass die Bedingungen nacheinander geprüft werden. Wenn eine frühere Bedingung bereits erfüllt ist, werden spätere Bedingungen gar nicht mehr angeschaut. Ein (optionales) finales else fängt den Fall auf, wenn keine Bedingung erfüllt ist. Das Flussdiagramm Abbildung 6.3 stellt die möglichen Fälle da. Es können beliebig viele elif-Blöcke verwendet werden und das finale else kann auch weggelassen werden. Damit steht uns eine sehr flexible Möglichkeit für Verzweigungen zur Verfügung.\n\n\n\n\n\n\nAbbildung 6.3: Flussdiagramm zur Verzweigung mit if, elif und else\n\n\n\n\n# Grenzwerte für die Motorüberwachung (in °C)\nnormal_temp = 80  # normale Betriebstemperatur\nwarning_temp = 100  # Warnschwelle\ndanger_temp = 120  # Kritische Temperatur\n\n# Eingabe: Gemessene Motortemperatur\ntemperature = float(input(\"Aktuelle Motortemperatur in °C: \"))\n\n# Bewertung der Temperatur\nif temperature &lt; 0:\n    print(\"Fehler: Ungültige Temperatur. Bitte Sensor prüfen.\")\nelif temperature &lt;= normal_temp:\n    print(\"Temperatur im sicheren Bereich.\")\nelif temperature &lt;= warning_temp:\n    print(\"Achtung: Temperatur erhöht. Kühlung überprüfen.\")\nelif temperature &lt;= danger_temp:\n    print(\"Kritische Warnung! Motor überhitzt!\")\n    #hier folgt Code, der eine zusätzliche Kühlung aktiviert\nelse:\n    print(\"Motor wird abgeschaltet!\")\n    #hier folgt Code, der den Motor sofort abschaltet\n\nAktuelle Motortemperatur in °C:  110\n\n\nKritische Warnung! Motor überhitzt!\n\n\n\n\n\n\n\n\nDie if-Anweisung in anderen Programmiersprachen\n\n\n\nDie if-Anweisung ist ein universelles Werkzeug der Programmierung, das Sie in vielen Programmiersprachen wiederfinden werden. Beim Wechsel zu einer anderen Programmiersprache müssen Sie sich mit der jeweiligen Syntax vertraut machen. Python verpflichtet Sie z.B. zu Einrückungen, was in anderen Programmiersprachen eher unüblich ist (zu Zwecken der Übersichtlichkeit aber trotzdem gemacht wird). In C verwendet man geschweifte Klammern, um die Blöcke voneinander abzugrenzen. Hier ein Beispiel:\n    int temperatur = 25;\n\n    if (temperatur &gt; 30) {\n        printf(\"Es ist heiß!\\n\");\n    } else if (temperatur &gt; 20) {\n        printf(\"Angenehmes Wetter.\\n\");\n    } else {\n        printf(\"Es ist kühl.\\n\");\n    }\nSie erkennen sicherlich die große Ähnlichkeit zu dem, was Sie in Python kennengelernt haben, aber auch Unterschiede. Zum Beispiel schreibt man in C else if statt des verkürzten elif.\n\n\n\n\n\n\n\n\nConditional Expressions\n\n\n\nEine Besonderheit von Python sind die sog. Conditional Expressions. Sie sind eine elegante Art, Code kompakt darzustellen, wenn eine Zuweisung abhängig von einer if-Bedingung stattfinden soll. Dazu betrachten wir zunächst ein Beispiel als traditionelle Verzweigung mit if und else:\nif voltage &gt; 1000:\n    classification = \"Hochspannung\" \nelse:\n    classification =\"Niederspannung\"\nDie kompakte Schreibweise als Conditional Expression sieht dagegen so aus:\nclassification = (\"Hochspannung\" if voltage &gt; 1000 else \"Niederspannung\")\nDie Conditional Expression ist leicht zu verstehen, da sie wie ein englischer Satz gelesen werden kann. Die Klammern sind optional, unterstützen aber die Übersicht.\n\n\n\nÜbungen:\n\nImplementieren Sie einen Türsteher vor einem Club. Er fragt die Besucher nach dem Alter und reagiert entsprechend.\nSchreiben Sie Code, der den BMI einer Person berechnet und professionelles Feedback gibt.\nSchreiben Sie ein Programm, das einen primitiven Taschenrechner darstellt: Der Benutzer gibt zwei Zahlen ein, wählt eine Grundrechenart aus und erhält das gewünschte Ergebnis.\n\n\n\n\n\nZusammengesetzte Bedingungen mit and, or und not\nMit den Operatoren and, or und not können komplexere logische Bedingungen aufgebaut werden. Die Bedeutung der Operatoren ist aus der Aussagenlogik bekannt:\n\nand: “A und B” ist wahr, wenn beide Bedingungen wahr sind.\nor: “A oder B” ist wahr, wenn mindestens eine der Bedingungen wahr ist.\nnot: “nicht A” kehrt den Wahrheitswert einer Bedingung um (wahr wird falsch und falsch wird wahr).\n\n\nage = 25\nhas_license = True\n\n# \"Führerschein und Fahrzeugpapiere bitte!\"\nif age &gt;= 18 and has_license:\n    print(\"Sie dürfen fahren!\")\nelse:\n    print(\"Steigen Sie mal bitte aus...\")\n\nSie dürfen fahren!\n\n\nBei der Verknüpfung von mehr als zwei Bedingungen empfiehlt sich die Verwendung von Klammern. Ohne Klammern gelten die Prioritätsregeln: * not hat die höchste Priorität. Es wird zuerst ausgewertet. * and hat eine mittlere Priorität. Es wird vor or ausgewertet. * or hat die niedrigste Priorität.\nIm folgenden Beispiel bräuchte man die Klammern nicht, aber sie unterstützen die Lesbarkeit und beugen Missverständnissen vor:\n\ntemperature = 25\nis_sunny = True\nis_holiday = False\n\nif (temperature &gt; 20 and is_sunny) or is_holiday:\n    print(\"Ich bin happy!\")\nelse:\n    print(\"Ein Tag wie jeder andere.\")\n\nIch bin happy!\n\n\nIm folgenden Beispiel wird not als erstes ausgewertet:\n\nis_guest = False\nis_admin = False\ndata_updated = True\n\nif not is_guest and (is_admin or data_updated):\n    print(\"Zugriff gewährt!\")\nelse:\n    print(\"Zugriff verweigert!\")\n\nZugriff gewährt!\n\n\nZugriff wird hier nur gewährt, wenn es sich nicht um einen Gast handelt. Darüber hinaus muss es ein Admin oder ein User mit aktualisierten Daten sein.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Kontrollstrukturen</span>"
    ]
  },
  {
    "objectID": "notebooks/4-controls.html#schleifen",
    "href": "notebooks/4-controls.html#schleifen",
    "title": "6  Kontrollstrukturen",
    "section": "6.2 Schleifen",
    "text": "6.2 Schleifen\nMit Schleifen können wir Anweisungen wiederholen, ohne sie erneut hinschreiben zu müssen. Die Anweisungen, die wiederholt ausgeführt werden sollen, stehen in einem eingerückten Schleifenkörper (so wie die Anweisungen in if- oder else-Blöcken). In Python gibt es zwei grundlegende Schleifentypen, die es in ähnlicher Weise auch in vielen anderen Programmiersprachen gibt.\n\nWhile-Loop\nBei der while-Schleife (engl. Loop) legen wir eine Bedingung fest. Nur, wenn diese Bedingung erfüllt ist, werden die Anweisungen im Schleifenkörper ausgeführt. Nach jedem Durchlauf wird die Bedingung erneut geprüft und der Schleifenkörper ggf. ein weiteres Mal durchlaufen. Sie ahnen vielleicht schon die Gefahr dieses Schleifentyps: Wenn die Bedingung immer wahr ist, kommt das Programm nie mehr aus der Schleife raus! Sie haben dann eine sog. Endlosschleife erschaffe, ein gefürchteter Schrecken in der Programmierung. Denken Sie daher gut über Ihre Schleifenbedingung nach!\nDas geschilderte Verhalten können Sie auch im Flussdiagramm der while-Schleife nachvollziehen (Abbildung 6.4).\n\n\n\n\n\n\nAbbildung 6.4: Flussdiagramm zur while-Loop\n\n\n\nBetrachten wir ein Beispiel, an dem Sie Syntax und Funktionsweise der while-Schleife lernen können:\n\nwater_level = 0  # Startfüllstand in Liter\nmax_water_level = 80  # Kapazität des Wassertanks in Liter\nflow_rate = 10  # Befüllung pro Schritt in Liter\n\nwhile water_level &lt; max_water_level:\n    water_level += flow_rate\n    print(\"Wassertank wird befüllt... Aktueller Stand:\", water_level)\n\n\nprint(\"Der Tank ist voll! Befüllung gestoppt.\")\n\nWassertank wird befüllt... Aktueller Stand: 10\nWassertank wird befüllt... Aktueller Stand: 20\nWassertank wird befüllt... Aktueller Stand: 30\nWassertank wird befüllt... Aktueller Stand: 40\nWassertank wird befüllt... Aktueller Stand: 50\nWassertank wird befüllt... Aktueller Stand: 60\nWassertank wird befüllt... Aktueller Stand: 70\nWassertank wird befüllt... Aktueller Stand: 80\nDer Tank ist voll! Befüllung gestoppt.\n\n\n\n\nFor-Loop\nDie for-Schleife hat einen anderen Charakter als die while-Schleife: Sie wird verwendet, um eine Sequenz (z. B. eine Liste, eine Zeichenkette oder eine Zahlenreihe) Schritt für Schritt zu durchlaufen. Für jedes Element der Sequenz wird der Schleifenkörper durchlaufen, bis schließlich das Ende der Sequenz erreicht ist und die Schleife verlassen wird.\nDie grundlegende Syntax sieht so aus:\nfor var in sequence:\n    # Codeblock, der für jedes Element der Sequenz ausgeführt wird.\n    # \n    # var ist beim ersten Druchlauf das erste Element,\n    # beim zweiten Durchlauf das zweite Element,\n    # ...\n    # beim letzten Durchlauf das letzte Element.\nBei einer for-Schleife wird beim ersten Eintritt in die Schleife das erste Element der Sequenz ausgewählt (Initialisierung). Nach jedem Durchlauf des Schleifenkörpers erfolgt automatisch der Übergang zum nächsten Element der Sequenz (Iteration), bis alle Elemente durchlaufen wurden. Das zugehörige Flussdiagramm (Abbildung 6.5) sieht daher etwas anders aus, als die bisherigen Beispiele.\n\n\n\n\n\n\nAbbildung 6.5: Flussdiagramm zur for-Loop\n\n\n\nAm besten wir betrachten ein paar Beispiele:\n\n# Wir buchstabieren ein Wort:\n# \"Apfel\" ist hierbei die Sequenz\nfor letter in \"Apfel\":  \n    print(letter)\n\nA\np\nf\ne\nl\n\n\n\n# Wir gehen eine Liste durch und prüfen eine Bedingung\nsensor_values = [12.4, 15.7, 19.3, 21.2, 13.5, 7.8]\ncritical_threshold = 20.0\n\nfor value in sensor_values:\n    if (value &gt; critical_threshold):\n        print(\"Kritischer Messwert gefunden:\", value, \"V\")\n\nKritischer Messwert gefunden: 21.2 V\n\n\nEine häufige Anwendung von for-Schleifen sind sog. Zählschleifen, bei denen eine feste Anzahl an Wiederholungen vorgeben wird. Dies erreicht man in Python durch die Funktion range():\n\n# range(5) erzeugt die Sequenz 0 - 4\nfor i in range(5): \n    print(i)\n\n0\n1\n2\n3\n4\n\n\nBeachten Sie, dass die von range(n) erzeugte Sequenz bei 0 beginnt und n-1 endet. Tatsächlich werden die Buchstaben i und j gerne als Zählvariablen verwendet. Die range()-Funktion bietet verschiedene Optionen, um die erzeugte Sequenz zu beeinflussen. So können Sie neben dem End-Wert auch einen Start-Wert angeben:\n\n# range(3,10) erzeugt die Sequenz 3 - 9\nfor i in range(3,10): \n    print(i)\n\n3\n4\n5\n6\n7\n8\n9\n\n\nUnd was macht der folgende Code?\n\nfor i in range(3,10,2):\n    print(i)\n\n3\n5\n7\n9\n\n\nWir fassen die drei Varianten von range() zusammen:\n\nrange(stop) Sequenz von 0 bis stop-1\nrange(start, stop) Sequenz von start bis stop-1\nrange(start, stop, step) Sequenz von start bis maximal stop-1 mit der Schrittweite step.\n\nIn der dritten Variante steht “bis maximal stop-1”, weil nicht mehr garantiert werden kann, dass stop-1 angenommen wird, da jeweils step hinzuaddiert wird und somit stop-1 übersprungen werden kann. Sobald der Zähler aber &gt;= stop ist, terminiert die Schleife.\nÜbrigens kann man mit range() auch rückwärts zählen:\n\nfor i in range(10, 0, -3):\n    print(i)\n\n10\n7\n4\n1\n\n\n\n\nFor-Schleifen in anderen Programmiersprachen\nIn den meisten anderen Programmiersprachen ähnelt die For-Schleife von vornherein eher einer Zählschleife. In C sieht das z.B. so aus:\nfor (int i = 0; i &lt; 10; i++) {\n    // Schleifenkörper für \n    // i von 0 bis 9\n}\nIn der runden Klammer erkennt man drei Anweisungen: * int i = 0 initialisiert die Zählvariable i * i &lt; 10 definiert die Bedingung, wie lange die Schleife ausgeführt werden soll * i++ bedeutet, dass die Zählvariable nach jedem Durchgang um eins erhöht wird.\nDas Python-Analogon wäre also:\nfor i in range(10):\n\n\nÜbungen: Gegeben sei eine Liste mit Messwerten data=[0.2, -1.3, 2.7, 0.6, 9.9, 8.2].\n\nImplementieren Sie eine For-Loop, die die Summe aller Messwerte berechnet.\nSchreiben Sie Code, der den Durchschnitt aller Messwerte berechnet.\nSchreiben Sie Code, der das Maximum der Messwerte findet.\n\n\nLösung (alle drei Aufgaben in einem Code):\n\n\nCode\ndata = [0.2, -1.3, 2.7, 0.6, 9.9, 8.2]\nsum_result = 0  # Summe initialisieren mit Null\nmax_value = data[0]  # Maximum initialisieren mit erstem Element\n\nfor value in data:\n    sum_result += value  # aufaddieren    \n    if(value &gt; max_value):  # Maximum suchen\n        max_value = value\n\n# Für den Durchschnitt brauchen wir noch\n# die Anzahl der Elemente. Diese erhält\n# man mit len(data):        \naverage = sum_result / len(data)  \n\nprint(\"Summe: \", sum_result,\"Durchschnitt: \", average, \"Maximum: \", max_value)\n    \n\n\n\nDen Schleifenfluss kontrollieren mit break und continue\n\nbreak - Schleife vorzeitig beenden\nSobald in einer Schleife das Keyword break verwendet wird, bricht die Schleife an Ort und Stelle ab. Das funktioniert sowohl in while- als auch in for-Schleifen. Betrachten Sie das folgende Ratespiel - können Sie den Nutzen von break nachvollziehen?\n\nimport random\nsecret_number = random.randint(0,100) #erzeugt eine Zufallszahl\nguess = -1\n\nwhile(guess != secret_number):\n   \n    guess = int(input(\"Raten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): \"))\n    \n    if (guess == -1):\n        print(\"Abbruch.\")\n        break  # Die Schleife wird abgebrochen\n    \n    # Falls das Spiel fortgesetzt wird, geben wir Tipps:\n    if(secret_number &lt; guess):\n        print(\"Zu groß!\")\n    elif (secret_number &gt; guess):\n        print(\"Zu klein!\")\n    else:\n        print(\"Gratulation!\")  # Geheime Zahl erraten!\n\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): 23\nZu klein!\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): 87\nZu groß!\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): -1\nAbbruch.\n\n\nEin Beispiel für break in einer for-Schleife:\n\nbag = [\"Schlüssel\", \"Handy\", \"Brille\", \"Geldbörse\", \"Stift\"]  # Dinge in der Tasche\nsearch_item = \"Geldbörse\"  # Der Gegenstand, den wir suchen\n\nfor item in bag:\n    print(\"Suche nach \", search_item, \" läuft. Aktueller Gegenstand: \", item)\n    \n    if item == search_item:\n        # Die Schleife wird abgebrochen, \n        # da der Gegenstand gefunden wurde:\n        print(search_item, \"gefunden!\")\n        break  \n\nSuche nach  Geldbörse  läuft. Aktueller Gegenstand:  Schlüssel\nSuche nach  Geldbörse  läuft. Aktueller Gegenstand:  Handy\nSuche nach  Geldbörse  läuft. Aktueller Gegenstand:  Brille\nSuche nach  Geldbörse  läuft. Aktueller Gegenstand:  Geldbörse\nGeldbörse gefunden!\n\n\n\n\ncontinue - Schleifendurchlauf vorzeitig beenden, weiter mit dem nächsten!\nDas Keyword continue bricht nur den aktuellen Schleifendurchlauf an Ort und Stelle ab, aber nicht die ganze Schleife. Es geht einfach direkt mit dem nächsten Durchlauf weiter. Wir erweitern das Ratespiel von oben durch ein continue bei ungültiger Eingabe:\n\nimport random\nsecret_number = random.randint(0,100)  # erzeugt eine Zufallszahl\nguess = -1\n\nwhile(guess != secret_number):\n   \n    guess = int(input(\"Raten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): \"))\n    \n    if (guess &gt; 100 or guess &lt; -1): \n        # Eingabe außerhalb gültiger Grenzen\n        print(\"Ungültig!\")\n        # Durchgang abbrechen und nächste Runde: \n        continue \n    \n    if (guess == -1):\n        # Die Schleife wird abgebrochen\n        print(\"Abbruch.\")\n        break \n    \n    # Falls das Spiel fortgesetzt wird, geben wir Tipps:\n    if(secret_number &lt; guess):\n        print(\"Zu groß!\")\n    elif (secret_number &gt; guess):\n        print(\"Zu klein!\")\n    else:\n        print(\"Gratulation!\")  # Geheime Zahl erraten!\n\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): 102\nUngültig!\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): -3\nUngültig!\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): 23\nZu klein!\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): 54\nZu groß!\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): -1\nAbbruch.\n\n\nAuch hierzu ein Beispiel mit for (es illustriert eine einfache Datenbereinigung):\n\nuser_inputs = [\"23\", \"abc\", \"45\", \"-1\", \"67\", \"150\", \"\", \"89\", \"0\", \"xyz\"]\ncleaned_data = []  # Liste für bereinigte Eingaben\n\nfor input_str in user_inputs:\n\n    # 1. Überspringe nicht-numerische Eingabe\n    if not input_str.isdigit():\n        continue\n\n    # 2. Wandle die Eingabe in eine Zahl um\n    input_number = int(input_str)  \n\n    # 3. Überspringe Werte außerhalb gültiger Grenzen\n    if input_number &lt; 10 or input_number &gt; 100:\n        continue\n\n    # Füge gültige Eingabe der Liste hinzu:\n    cleaned_data.append(input_number)  \n\nprint(\"Bereinigte Eingaben:\", cleaned_data)\n\nBereinigte Eingaben: [23, 45, 67, 89]",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Kontrollstrukturen</span>"
    ]
  },
  {
    "objectID": "notebooks/4-controls.html#anwendung-das-newton-verfahren",
    "href": "notebooks/4-controls.html#anwendung-das-newton-verfahren",
    "title": "6  Kontrollstrukturen",
    "section": "6.3 Anwendung: Das Newton-Verfahren",
    "text": "6.3 Anwendung: Das Newton-Verfahren\n\nAufgabe: Implementieren Sie das Newton-Verfahren (siehe Wikipedia), welches nach einer Nullstelle einer Funktion \\(f(x)\\) sucht. Testen Sie es für die Funktion \\(f(x)=x^3+x^2-2\\,x-1\\) und probieren Sie dabei verschiedene Startwerte aus.\n\nWir erzeugen zunächst einen Plot der Funktion (den Code hierzu müssen Sie noch nicht nachvollziehen können):\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nxs = np.arange(-3,3,0.1)\nys = xs**3 + xs**2 - 2*xs-1\nplt.axhline(0, color=\"black\", linewidth=1)  # x-Achse\nplt.axvline(0, color=\"black\", linewidth=1)  # y-Achse\nplt.xlabel(\"x\")\nplt.ylabel(\"f(x)\")\nplt.plot(xs,ys,label=\"$f(x)=x^3+x^2-2\\,x-3$\")\n\n\n\n\n\n\n\n\n\nJetzt implementieren wir das Verfahren:\n\n\nCode\nmax_iter = 100  # maximale Zahl der Iterationen\nx = 1.0  # Startwert\ntol = 1e-6  # Toleranz\n\nfor i in range(max_iter):    \n\n    # Funktion:\n    f = x**3+x**2-2*x-1 \n\n    # Ableitung:\n    fp = 3 * x**2 + 2*x - 2 \n    \n    if abs(f) &lt; tol:\n        # Funktionswert ist nahe genug bei Null\n        print(\"Konvergiert nach \", i, \"Iterationen.\")\n        break\n    \n    x = x - f / fp  # Iteration des Newton-Verfahrens\n    \nprint(\"x=\",x,\"f(x)=\",f)\n\n\nEine alternative Abbruchbedingung betrachtet die Änderung in \\(x\\) von Schritt zu Schritt. Sobald sich \\(x\\) nicht mehr signifikant ändert, bricht das Verfahren ab. Wir gehen an dieser Stelle nicht auf die Vor- und Nachteile der jeweiligen Abbruchbedingung ein.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Kontrollstrukturen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html",
    "href": "notebooks/5-functions.html",
    "title": "7  Funktionen",
    "section": "",
    "text": "7.1 Prozedurale Programmierung\nFunktionen sind ein zentrales Konzept der Programmierung, das es ermöglicht, Code in wiederverwendbare Einheiten zu gliedern. Sie tragen dazu bei, Programme übersichtlicher und wartbarer zu gestalten, vermeiden insbesondere redundanten Code. Wann immer man geneigt ist, eine Codezeile oder einen Block zu kopieren, sollte man darüber nachdenken, ob eine Funktion sinnvoll ist. In diesem Kapitel werden Funktionen allgemein und ihre Anwendung in Python im Speziellen vorgestellt.\nWir befinden uns noch immer in der sog. imperativen Programmierung: Dabei wird der Programmablauf durch eine Abfolge von Befehlen gesteuert, die der Reihe nach abgearbeitet werden (der Kontrollfluss wird insbesondere durch Verzweigungen und Schleifen beeinflusst).\nDie prozedurale Programmierung ist ein Ansatz innerhalb der imperativen Programmierung, bei dem das Programm als eine Reihe von Prozeduren oder Funktionen organisiert wird. Durch diese Aufteilung können komplexe Abläufe in einzelne, handhabbare Teile zerlegt werden, was zu einem klareren und besser wartbaren Code führt.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html#prozedurale-programmierung",
    "href": "notebooks/5-functions.html#prozedurale-programmierung",
    "title": "7  Funktionen",
    "section": "",
    "text": "Was ist eine Funktion?\nEine Funktion ist ein in sich geschlossener Block von Anweisungen, der eine bestimmte Aufgabe erfüllt. Vergleichen Sie eine Funktion mit einem Kochrezept: Das Rezept beschreibt eine schrittweise Anleitung zur Zubereitung eines Gerichts. Wann immer Sie das Gericht kochen, verwenden Sie dasselbe Rezept wieder und wieder. In der Programmierung würden wir sagen: “Sie rufen dieselbe Funktion immer wieder auf.” Von dem Rezept benötigen Sie aber nur ein einziges Exemplar (ganz egal, wie oft sie das Gericht kochen werden). So ist es auch mit dem Code, der in einer Funktion definiert wird: Sie schreiben ihn ein einziges Mal und verwenden ihn dann beliebig oft.\nManchmal wird auch eine Analogie zu mathematischen Funktionen \\(f(x)\\) gezogen. Diese Analogie hat aber einige Schwächen: Die mathematische Funktion bekommt immer einen Input (hier \\(x\\)) und gibt immer einen Wert als Output (\\(y = f(x)\\)) zurück. Das muss bei Funktionen in der Programmierung nicht sein! Eine Funktion in der Programmierung kommt auch ohne Input und Output aus, wie wir gleich sehen werden. Es liegt ganz in Ihrer Freiheit, ob Ihre Funktionen mit Inputs und Outputs arbeitet oder nicht.\nBevor wir konkret werden, fassen wir die Vorteile von Funktionen zusammen:\n\nModularisierung: Zerlegung des Codes in kleine, verständliche Einheiten.\nWiederverwendbarkeit: Einmal definierte Funktionen können mehrfach eingesetzt werden.\nLesbarkeit und Wartbarkeit: Klar strukturierter Code erleichtert das Verständnis und die Fehlersuche.\nVermeidung von Redundanz: Gleicher Code muss nicht mehrfach geschrieben werden, sondern kann über Funktionsaufrufe wiederverwendet werden. Insbesondere von Vorteil, wenn Sie etwas ändern müssen: Sie müssen nur eine Stelle korrigieren, egal wie oft die Funktion aufgerufen wird.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html#funktionen-in-python",
    "href": "notebooks/5-functions.html#funktionen-in-python",
    "title": "7  Funktionen",
    "section": "7.2 Funktionen in Python",
    "text": "7.2 Funktionen in Python\nPython bietet eine einfache und flexible Syntax zur Definition von Funktionen. Eine Funktion wird mit dem Schlüsselwort def eingeleitet. In runden Klammern werden optional Eingangsparameter definiert, dann folgt ein Doppelpunkt. Der eigentliche Funktionsblock muss eingerückt werden (das kennen Sie schon von Code-Blöcken in Verzweigungen und Schleifen). Hier ein einfaches Beispiel ohne Eingangsparameter:\n\ndef greeting():\n    print(\"Hello, world!\")\n\nWir haben eine sehr primitive Funktion definiert, die nichts anderes tut, als \"Hello, World\" auszugeben, wann immer wir sie aufrufen:\n\ngreeting()\n\nHello, world!\n\n\nBeachten Sie beim Aufruf der Funktion die runden Klammern, die gleich mehr Sinn ergeben werden.\n\nParameter und Argumente\nWie bereits erwähnt, können Funktionen Parameter entgegennehmen, um mit variablen Eingabewerten zu arbeiten. Zum Beispiel können wir unsere Begrüßungsfunktion so erweitern, dass Sie einen Namen als Parameter entgegennimmt und diesen für eine personalisierte Begrüßung verwendet:\n\ndef greeting(name):\n    print(\"Hallo,\",name)\n\n\ngreeting(\"Anna\")\n\nHallo, Anna\n\n\n\ngreeting(\"Tom\")\n\nHallo, Tom\n\n\n\n\n\n\n\n\nArgumente\n\n\n\nDen konkreten Wert, den man an eine Funktion übergibt, nennt man Argument. Wir haben in unseren Beispielen bereits verschiedene Argumente (“Anna”,“Tom”) für den Parameter name verwendet.\n\n\nWas jetzt nicht mehr funktioniert: Wir können die Funktion nicht mehr ohne ein Argument für den Parameter name aufrufen! Probieren Sie greeting() und Python wird sich beschweren, dass ein Argument fehlt! Eine besondere Möglichkeit, dieses Problem zu beheben, ist sog. Standardargumente für Parameter festzulegen. Diese werden verwendet, wenn der Anwender der Funktion kein Argument übergibt (ob das sinnvoll ist oder nicht, hängt ganz von Ihrer Anwendung ab). Wir demonstrieren die Begrüßungsfunktion mit einem Standardargument:\n\ndef greeting(name=\"Welt\"):\n    print(\"Hallo,\",name)\n\n\ngreeting(\"Lisa\")\n\nHallo, Lisa\n\n\n\ngreeting()\n\nHallo, Welt\n\n\nDer Parameter name wurde durch die Definition eines Standardarguments zu einem optionalen Parameter: Es ist nicht mehr zwingend erforderlich, ihn beim Funktionsaufruf festzulegen.\n### Mehrere Parameter {.unnumbered}\nSelbstverständlich können wir mehr als einen Parameter verwenden:\n\ndef greeting(name, age):\n    print(\"Hello,\", name)\n    if age &lt; 18:\n        print(\"Sie sind noch minderjährig!\")\n    else:\n        print(\"Willkommen im Club!\")\n\n\ngreeting(\"Tom\", 16)\ngreeting(\"Lisa\", 21)\n\nHello, Tom\nSie sind noch minderjährig!\nHello, Lisa\nWillkommen im Club!\n\n\nJetzt muss man allerdings aufpassen, wenn man Standardargumente verwenden will, denn es gibt eine wichtige Regel:\n\n\n\n\n\n\nOptionale Parameter immer hinter nicht-optionalen Parametern!\n\n\n\nFolgende Definition ist korrekt:\ndef greeting(name, age = 20):\n    # Funktionsblock\nFolgender Code ist falsch und wird nicht funktionieren:\ndef greeting(name=\"Peter\", age):\n    # Funktionsblock\n\n\n\n\nRückgabewerte\nFunktionen können einen Wert zurückgeben. Hierfür verwendet man (wie in C oder C++) das Keyword return:\n\ndef square(x):\n    return x * x\n\nresult = square(4)\nprint(result)\n\n16\n\n\nWir können die Funktion wieder beliebig oft mit verschiedenen Argumenten aufrufen:\n\nprint(square(3))\nprint(square(-2))\nprint(square(7.3))\n\n9\n4\n53.29\n\n\nEine Besonderheit in Python ist, dass wir sogar mehr als einen Wert zurückgeben können! Das geht in vielen anderen Programmiersprachen nicht ohne Weiteres, in C oder C++ würde man dafür z.B. Datenstrukturen (als Container für mehrere Werte) oder Zeiger verwenden (die auf einen Bereich im Speicher verweisen, wo die Werte hintereinander liegen). In Python geht das ganz einfach, wie das folgende Beispiel zeigt:\n\ndef divmod(a, b): \n    # Division mit Rest\n    # zwei Rückgabewerte durch Komma getrennt:\n    return a//b, a%b \n\na = 13\nb = 3\n\nquotient, remainder = divmod(a,b)\n\nprint(a, \" geteilt durch \", b ,\" ergibt:\")\nprint(quotient, \"mit Rest \", remainder)\n\n13  geteilt durch  3  ergibt:\n4 mit Rest  1\n\n\nDie Reihenfolge der Rückgabewerte ist natürlich zu beachten, sonst geschehen leicht Fehler (würde man versehentlich remainder, quotient = divmod(a,b) schreiben, stünde in quotient der Rest und in remainder der Quotient).\n\n\nKeyword-Argumente\nPython erlaubt uns, Funktionen mit sog. Keyword-Argumenten aufzurufen. Damit ist gemeint, dass die Argumente explizit benannt werden, anstatt sie anhand ihrer Reihenfolge zu identifizieren. Betrachten wir zunächst folgendes Beispiel, in dem wir eine Funktion wie gewohnt aufrufen:\n\ndef print_personal_details(name, age, city):\n    print(\"Name: \", name)\n    print(\"Alter: \", age)\n    print(\"Wohnort: \", city)\n\nprint_personal_details(\"Alice\", 23, \"London\") # wie gehabt\n\nName:  Alice\nAlter:  23\nWohnort:  London\n\n\nJetzt zeigen wir Varianten mit Keyword-Argumenten:\n\n# mit Verwendung von Keyword-Argumenten:\nprint_personal_details(name=\"John\", city=\"Birmingham\", age=32) \n\nName:  John\nAlter:  32\nWohnort:  Birmingham\n\n\n\n# teilweise mit Keyword-Argumenten:\nprint_personal_details(\"Marc\", city=\"Hamburg\", age=19)\n\nName:  Marc\nAlter:  19\nWohnort:  Hamburg\n\n\nWie Sie sehen, können Sie die Parameternamen explizit verwenden, um ein Argument zu definieren und dabei sogar von der Reihenfolge im Funktionskopf abweichen. Eine Regel gibt es allerdings auch hier wieder: Wenn Sie nur teilweise Keyword-Argumente verwenden (wie im Beispiel Marc oben), kommen die Keyword-Argumente immer am Schluss! So können alle Parameter eindeutig identifiziert werden und es kommt nicht zu Mehrdeutigkeiten.\nZur namentlichen Abgrenzung von den Keyword-Argumenten, bezeichnet man die Argumente, die anhand ihrer Reihenfolge identifiziert werden, als Positions-Argumente (engl.: keyword arguments and positional arguments).\n\nÜbungen:\n\nEin Körper werde aus seiner Ruhelage beschleunigt. Implementieren Sie eine Funktion accelerated_motion(a, t), die die Beschleunigung a und die Zeit t als Parameter erwartet und die zurückgelegte Strecke \\(s(t)=\\frac{1}{2}a\\,t^2\\) und die Geschwindigkeit \\(v(t)=a\\cdot t\\) zurückgibt.\nErweitern Sie die Funktion accelerated_motion um zwei optionale Parameter s0 und v0, die eine Anfangsposition bzw. eine Anfangsgeschwindigkeit zum Zeitpunkt \\(t=0\\) darstellen. Übergibt man keine Argumente, soll die Bewegung wie gehabt aus der Ruhelage beginnen.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html#dynamische-typisierung-und-mögliche-gefahren",
    "href": "notebooks/5-functions.html#dynamische-typisierung-und-mögliche-gefahren",
    "title": "7  Funktionen",
    "section": "7.3 Dynamische Typisierung und mögliche Gefahren",
    "text": "7.3 Dynamische Typisierung und mögliche Gefahren\nWir kennen bereits die dynamische Typisierung als besondere Eigenschaft von Python. Im Zusammenhang mit Funktionen erlaubt Sie uns, dieselbe Funktion mit unterschiedlichen Datentypen aufzurufen (wir haben das bereits oben einmal getan, finden Sie das Beispiel?). In anderen Programmiersprachen muss man dafür die Funktion in der Regel mehrfach implementieren (eine Variante für jeden Datentyp), man sagt auch: die Funktion wird überladen. Bei überladenen Funktionen in C oder C++ erkennt der Compiler anhand der übergebenen Datentypen, welche Version der Funktion gemeint ist.\nNicht so in Python, wo der Datentyp der Parameter und Rückgabewerte nicht vom Programmierer bzw. der Programmiererin festgelegt wird. Das kann sehr nützlich sein, aber auch zu Fehlern führen, wenn die Funktion mit inkompatiblen Datentypen aufgerufen wird. Hierzu ein Beispiel:\n\ndef multiply(x, y):\n    return x * y\n\nEine sehr einfache Funktion, die zwei Parameter miteinander multipliziert. Wir rufen sie jetzt mit unterschiedlichen Datentypen auf:\n\nprint(multiply(3,4)) # zwei Integer\nprint(multiply(2, 3.2)) # Integer und Float\nprint(multiply(2+2j, 3-1j)) # zwei komplexe Zahlen\nprint(multiply(\"hi\", 3)) # String und Integer\n\n12\n6.4\n(8+4j)\nhihihi\n\n\nHätten Sie geahnt, was alles mit dieser kleinen, unscheinbaren Funktion möglich ist?\nEs scheint fast alles möglich zu sein, aber eben nur fast! Rufen Sie die Funktion mit zwei Strings auf und Ihr Programm stürzt ab (wie sollen zwei Strings miteinander multipliziert werden?). Natürlich sind auch viele weitere Kombinationen nicht möglich (versuchen Sie z.B. zwei Listen miteinander zu multiplizieren oder eine Liste mit einem String). Manchmal ist es sogar noch schlimmer, wenn das Programm zwar nicht abstürzt, aber das Ergebnis völlig unerwartet ist (hätten Sie z.B. das Ergebnis der Multiplikation von String mit Integer in der Form erwartet?). Dann entstehen an einer anderen Stelle im Code womöglich überraschend Probleme und Sie müssen langwierig debuggen, bis Sie die Ursache finden.\nDaran erkennen Sie wieder: Python bietet große Flexibilität, aber Sie müssen damit verantwortungsbewusst umgehen!",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html#funktionen-mit-beliebig-vielen-parametern",
    "href": "notebooks/5-functions.html#funktionen-mit-beliebig-vielen-parametern",
    "title": "7  Funktionen",
    "section": "7.4 Funktionen mit beliebig vielen Parametern",
    "text": "7.4 Funktionen mit beliebig vielen Parametern\nWir kennen seit Beginn des Kurses eine Funktion, die beliebig viele Argumente entgegennehmen kann:\n\nprint()  # 0 Argumente\nprint(\"Hallo\")  # 1 Argument\nprint(\"Hallo, \", \"Welt\")  # 2 Argumente usw.\n\n\nHallo\nHallo,  Welt\n\n\nMit einem einfachen Trick, können Sie selbst solche Funktionen definieren: Stellen Sie vor ein Argument ein *, damit machen Sie deutlich, dass hier eine Sequenz von Argumenten übergeben werden kann. Innerhalb der Funktion können Sie über die Sequenz iterieren, z.B. mit der bekannten For-Schleife:\n\ndef sum_numbers(*numbers):\n    result = 0\n    \n    for number in numbers:\n        result += number\n\n    return result\n\nprint(sum_numbers(-2))\nprint(sum_numbers(5, 10))\nprint(sum_numbers(1, 2, 3, 4)) \n\n-2\n15\n10",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html#scope",
    "href": "notebooks/5-functions.html#scope",
    "title": "7  Funktionen",
    "section": "7.5 Scope",
    "text": "7.5 Scope\nIn Python – und generell in der Programmierung – bezieht sich der Scope (Gültigkeitsbereich) auf den Bereich des Codes, in dem eine Variable sichtbar und zugänglich ist. Es gibt dabei zwei Hauptarten von Scope:\n\nLokaler Scope: Eine Variable, die innerhalb einer Funktion definiert wird, ist nur in dieser Funktion sichtbar und außerhalb nicht zugänglich.\nGlobaler Scope: Eine Variable, die außerhalb einer Funktion definiert wird, ist im gesamten Programm sichtbar. Python schützt uns aber davor, diese Variablen unbeabsichtigt zu verändern, es sei denn wir machen unsere Absicht explizit deutlich. Dafür gibt es in Python das Keyword global.\n\nBeginnen wir mit einem Beispiel zum lokalen Scope:\n\ndef my_function(a, b):\n    c = a + b\n    return c**2\n\nmy_function(2,3)\nprint(c) # FEHLER!!!! c ist hier nicht bekannt. \n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[234], line 6\n      3     return c**2\n      5 my_function(2,3)\n----&gt; 6 print(c)\n\nNameError: name 'c' is not defined\n\n\n\nAuf die Variable c kann außerhalb der Funktion nicht zugegriffen werden, sie existiert nur im lokalen Scope der Funktion.\nNun versuchen wir umgekehrt innerhalb der Funktion auf eine Variable zuzugreifen, die außerhalb definiert wurde:\n\n\ndef greeting():\n    print(\"Hallo,\", name)  # name existiert nur außerhalb\n\nname = \"Peter\"\ngreeting()\n\nHallo, Peter\n\n\nDas Beispiel ist geglückt! Allerdings handelt es sich hierbei nicht um guten Programmierstil. Vielmehr sollte man name als Parameter der Funktion definieren. Was geschieht eigentlich, wenn es name im globalen und im lokalen Scope gibt?\n\n\ndef greeting(name):\n    print(\"Hallo,\", name)\n\nname = \"Peter\"\ngreeting(\"Tina\")\n\nHallo, Tina\n\n\nDer lokale Scope geht vor! Die Funktion sucht immer zuerst in ihrem lokalen Scope nach der Variable. Nur, wenn sie sie dort nicht findet, schaut sie im globalen Scope nach.\n\nDas Keyword global in Python\nWie bereits erwähnt, schützt uns Python davor, unbeabsichtigt eine Variable im globalen Scope zu verändern. Wir können zwar ohne weiteres lesend darauf zugreifen, nicht aber schreibend, wie dieses Beispiel zeigt:\n\ndef change_name(new_name):\n    name = new_name\n\nname = \"Peter\"\nchange_name(\"John\")\nprint(name)\n\nPeter\n\n\nHätten Sie die Ausgabe “John” erwartet? Python schützt uns: Beim Versuch die globale Variable zu verändern, hat Python eine Variable im lokalen Scope der Funktion angelegt. Diese bekam den Wert “John”, aber die Variable im globalen Scope wurde nicht angefasst. Machen wir das ruhig explizit:\n\ndef change_name(new_name):\n    name = new_name\n    print(\"name innerhalb der Funktion: \", name)\n\nname = \"Peter\"\nchange_name(\"John\")\nprint(\"name außerhalb: \" , name)\n\nname innerhalb der Funktion:  John\nname außerhalb:  Peter\n\n\nMan kann diesen Sicherheitsmechanismus mit dem Keyword global aushebeln:\n\ndef change_name(new_name):\n    global name  # hey Python, wir meinen die globale Variable!\n    name = new_name\n\nname = \"Peter\"\nchange_name(\"John\")\nprint(name)\n\nJohn\n\n\nMit der Zeile global name weisen wir Python explizit an, die Variable name aus dem globalen Scope zu verwenden!\n\n\n\n\n\n\nVerwendung globaler Variablen in Funktionen\n\n\n\nFinden Sie das alles noch ein wenig verwirrend? Gut so, denn Sie sollten von der Verwendung globaler Variablen in Funktionen sowieso besser absehen. Versuchen Sie stattdessen saubere Schnittstellen mithilfe von Parametern und Rückgabewerten zu definieren. Wann immer Sie geneigt sind, lesend auf einen globalen Wert zuzugreifen, übergeben Sie diesen lieber als Argument. Wann immer Sie geneigt sind, schreibend auf einen globalen Wert zuzugreifen, arbeiten Sie lieber mit einem Rückgabewert, den Sie im Hauptprogramm zuweisen können.\nBeispiel: Eine Zahl im globalen Scope soll durch ihre Quadratzahl ersetzt werden.\ndef square(x):\n    return x**2 # die Funktion führt die Rechnung durch\n\na = 42\na = square(a) # die eigentliche Veränderung geschieht außerhalb der Funktion",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html#docstrings-und-typ-annotationen-meine-funktion-für-andere-dokumentieren",
    "href": "notebooks/5-functions.html#docstrings-und-typ-annotationen-meine-funktion-für-andere-dokumentieren",
    "title": "7  Funktionen",
    "section": "7.6 Docstrings und Typ-Annotationen: Meine Funktion für andere dokumentieren",
    "text": "7.6 Docstrings und Typ-Annotationen: Meine Funktion für andere dokumentieren\nIn großen Software-Projekten sind Sie nicht die einzige Person, die Ihre Funktionen benutzt. Sie können durch verständliche Dokumentation, die Nutzbarkeit Ihrer Funktionen enorm erhöhen. Eine einfache Möglichkeit sind sog. Docstrings: Dabei handelt es sich um eine spezielle Dokumentierung, direkt nach der definierenden Zeile:\n\ndef bending_stress(moment, y, inertia):\n    \"\"\"\n    Berechnet die Biegespannung in einem Balken.\n\n    Formel: sigma = (M * y) / I\n\n    Args:\n        moment (float): Biegemoment in Newton-Meter (Nm).\n        y (float): Abstand von der Neutralachse in Meter (m).\n        inertia (float): Flächenträgheitsmoment in m^4.\n\n    Returns:\n        float: Biegespannung in Pascal (Pa).\n    \"\"\"\n    \n    return moment * y / inertia\n\nDer Docstring wird mit \"\"\" eingeleitet, es folgt eine kurze Erklärung der Funktion, anschließend eine Erklärung der Argumente und der Rückgabewerte, und zum Abschluss wieder \"\"\". Wie genau der Docstring formattiert wird, hängt von der gewählten Konvention ab (wir haben hier den Google-Style verwendet). Viele Editoren greifen Docstrings in unterstützenden Funktionen auf (Tooltips oder Autovervollständigungen). Insbesondere kann nun aber jeder Entwickler und jede Entwicklerin über die Funktion help()eine Hilfe zu Ihrer Funktion aufrufen:\n\nhelp(bending_stress)\n\nHelp on function bending_stress in module __main__:\n\nbending_stress(moment, y, inertia)\n    Berechnet die Biegespannung in einem Balken.\n    \n    Formel: sigma = (M * y) / I\n    \n    Args:\n        moment (float): Biegemoment in Newton-Meter (Nm).\n        y (float): Abstand von der Neutralachse in Meter (m).\n        inertia (float): Flächenträgheitsmoment in m^4.\n    \n    Returns:\n        float: Biegespannung in Pascal (Pa).\n\n\n\nEine weitere Unterstützung bieten Typ-Annotation, mit denen wir andere Entwickler bzw. Entwicklerinnen darüber informieren, welche Datentypen unsere Funktion erwartet bzw. zurückgibt. Aber Vorsicht: Diese Angaben sind rein informativ! Sie verhindern nicht, dass die Funktion mit anderen Datentypen aufgerufen wird! Unser Beispiel mit Typ-Annotationen:\n\ndef bending_stress(moment: float, y: float, inertia: float) -&gt; float:\n    # Rest wie oben\n    pass # pass ist nur ein Platzhalter\n\nDie Typ-Annotationen geben an: Wir erwarten den Datentyp float für die Parameter moment, y und inertia und geben auch eine Float als Ergebnis zurück (-&gt; float).\n\nÜbung:\nSchreiben Sie eine Funktion ohms_law(R, U, I): Der Anwender übergibt für jeweils zwei der drei Parameter Zahlenwerte und für den dritten den String \"*\". Daraufhin berechnet die Funktion den fehlenden Wert mithilfe des Ohmschen Gesetzes und gibt ihn zurück. Dokumentieren Sie die Funktion mit einem Docstring, der die Benutzung erklärt.\n\n\n\nCode\ndef ohms_law(R, U, I):\n    \"\"\"\n    Berechnet Widerstand, Spannung oder Strom mithilfe des Ohmschen Gesetzes. \n    Der fehlende Wert wird mit dem Argument \"*\" markiert; für die anderen beiden müssen Zahlen übergeben werden.\n    Args:\n        R (float oder string): El. Widerstand (Ohm) oder \"*\".\n        U (float oder string): El. Spannung (Volt) oder \"*\".\n        I (float oder string): El. Strom (A) oder \"*\".\n    Returns:\n        float: fehlender Wert\n    \"\"\"\n    \n    if (R==\"*\"):\n        return U/I\n    elif (U==\"*\"):\n        return R*I\n    elif (I ==\"*\"):\n        return U/R\n    else:\n        print(\"Ungültige Eingabe!\")",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html",
    "href": "notebooks/6-sequences.html",
    "title": "8  Datenstrukturen in Python",
    "section": "",
    "text": "8.1 Ein Sensor speichert stündlich Temperaturdaten – Anwendung der Liste\nDatenstrukturen und Datentypen sind zentrale Begriffe in der Informatik, die eng miteinander verbunden, aber dennoch voneinander zu unterscheiden sind:\nWährend Datentypen also die Bausteine sind, definieren Datenstrukturen den Bauplan, wie diese Bausteine miteinander in Beziehung stehen und verarbeitet werden. In diesem Kapitel fokussieren wir uns auf grundlegende Datenstrukturen und deren Anwendung in Python anhand eines praxisnahen Beispiels: der Organisation und Analyse von Sensordaten. Das Beispiel wird im Verlauf des Kapitels sukzessive komplexer und damit auch realistischer.\nSie sollen einen Eindruck davon gewinnen, wie verschiedene Datenstrukturen für bestimmte Fragstellungen und Anwendungen ihre Stärken ausspielen.\nEin Sensor misst stündlich die Temperatur (z.B. in einem Raum oder einer Maschine). Diese Daten speichern wir der Reihe nach in einer Liste, einer der einfachsten Datenstrukturen. Die Liste ist ideal für lineares Speichern (Messwert für Messwert hintereinander). Sie ermöglicht den einfachen Zugriff auf Elemente anhand ihrer Position, stellt aber auch nützliche Funktionen zum Arbeiten mit den Daten bereit. ### Speichern der Daten {.unnumbered}\n# eine Liste kann mit Werten initialisiert werden\ntemperatures = [22.5, 23.1, 21.8]\n\n# es kann aber auch nach und nach ein Wert hinten angefügt werden:\ntemperatures.append(24.0)\ntemperatures.append(22.5)\ntemperatures.append(21.8)\n\nprint(temperatures)\n\n[22.5, 23.1, 21.8, 24.0, 22.5, 21.8]\nIn der Praxis würde an einer bestimmten Stelle im Code (einmal pro Stunde) mithilfe von append der aktuelle Messwert in der Liste gespeichert werden. Auffällig ist, dass die Funktion append zu unserer Liste selbst gehört, beim Aufruf verwenden wir einen . zwischen der Referenz auf die Liste und der Funktion. Solche Funktionen werden auch Methoden genannt und sind ein wesentlicher Bestandteil der objektorientierten Programmierung: Die Instanz einer Liste bietet Benutzern diese Funktion an, um ihren Inhalt zu manipulieren.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#ein-sensor-speichert-stündlich-temperaturdaten-anwendung-der-liste",
    "href": "notebooks/6-sequences.html#ein-sensor-speichert-stündlich-temperaturdaten-anwendung-der-liste",
    "title": "8  Datenstrukturen in Python",
    "section": "",
    "text": "Sortieren der Messungen\nSortieren hilft, die Werte geordnet darzustellen und z.B. das Finden des höchsten oder niedrigsten Messwerts zu erleichtern. Auch hierfür steht eine Methode bereit:\n\n# Sortieren der Liste\ntemperatures.sort()\nprint(\"Sortierte Temperaturen:\", temperatures)\n\nSortierte Temperaturen: [21.8, 21.8, 22.5, 22.5, 23.1, 24.0]\n\n\nWir können nun direkt ablesen, dass der Wertebereich zwischen 21.8 und 24.0 liegt. Allerdings haben wir unsere Originalliste durch das Sortieren verändert! Das war womöglich gar nicht unsere Absicht, denn wir wollen weiterhin die Information besitzen, wann welcher Wert erhoben wurde. Für diesen Zweck gibt es eine Lösung: Anstelle der Methode .sort() verwenden wir die Funktion sorted(), die eine sortierte Liste zurückgibt ohne das Original zu verändern:\n\n# Wir stellen zunächst das Original wieder her\ntemperatures = [22.5, 23.1, 21.8, 24.0, 22.5, 21.8]\n\nsorted_data = sorted(temperatures)\nprint(\"Sortierte Liste: \", sorted_data)\nprint(\"Original: \", temperatures)\n\nSortierte Liste:  [21.8, 21.8, 22.5, 22.5, 23.1, 24.0]\nOriginal:  [22.5, 23.1, 21.8, 24.0, 22.5, 21.8]\n\n\nDie implemenmtierten Sortieralgorithmen sind übrigens sehr effizient (schneller als der früher vorgestellte Bubble Sort).\n\n\nWerte extrahieren - Indexzugriff und List Slicing\nWir können auf die Werte in einer Liste ganz einfach über ihren Index zugreifen und dabei ist besonders nützlich, dass Python auch negative Indizes erlaubt: der Index -1 entspricht immer dem letzten Element, -2 dem vorletzten usw. Wir demonstrieren die Verwendung von Indizes:\n\nprint(\"1. Messwert: \" , temperatures[0])\nprint(\"Letzter Messwert: \" , temperatures[-1])\nprint(\"Min: \" , sorted_data[0])\nprint(\"Max: \" , sorted_data[-1])\nprint(\"5. Messwert: \" , temperatures[4])\nprint(\"Vorletzter Messwert: \" , temperatures[-2])\n\n1. Messwert:  22.5\nLetzter Messwert:  21.8\nMin:  21.8\nMax:  24.0\n5. Messwert:  22.5\nVorletzter Messwert:  22.5\n\n\nOft interessiert man sich für Bereiche von Messwerten und kann diese in Python sehr effizient mit sog. “List Slicing” ausschneiden: Hierfür verwendet man einen Start- und Endindex, getrennt durch ein :. Zu beachten ist, dass der Anfangsindex inkludiert wird, das Slicing aber einen Schritt vor dem Endindex aufhört:\n\n# Slicing: Werte gesucht ...\n# ... mit Indizes: 0,1,2\nprint(temperatures[0:3])  \n\n# ... mit Indizes: 2,3,4\nprint(temperatures[2:5])  \n\n# ... mit Indizes: 1,2,3...,vorletztes\nprint(temperatures[1:-1])  \n\n[22.5, 23.1, 21.8]\n[21.8, 24.0, 22.5]\n[23.1, 21.8, 24.0, 22.5]\n\n\nMan kann auch Start- und Endindex weglassen und meint damit “von Anfang” oder “bis Ende”:\n\n# Slicing: Werte gesucht ...\n# ... von Anfang bis Index 2\nprint(temperatures[:3]) \n\n# ... von Index 4 bis Schluss\nprint(temperatures[4:]) \n\n# Die ganze Liste als großer Slice:\nprint(temperatures[:]) \n\n[22.5, 23.1, 21.8]\n[22.5, 21.8]\n[22.5, 23.1, 21.8, 24.0, 22.5, 21.8]\n\n\nPython erlaubt sogar noch präzisere Analysen, indem es Schrittweiten beim Slicing zulässt. Die Schrittweite ist standardmäßig 1, aber kann als dritter Parameter hinter einem weiteren : verändert werden:\n\n# von Index 0 bis 4 in 2er Schritten\nprint(temperatures[0:5:2]) \n\n# von Index 1 bis Schluss in 2er Schritten\nprint(temperatures[1::2]) \n\n# jeder dritte Messwert\nprint(temperatures[::3]) \n\n# auch rückwärts funktioniert!\nprint(temperatures[4:1:-1]) \n\n# komplette Liste rückwärts\nprint(temperatures[::-1]) \n\n[22.5, 21.8, 22.5]\n[23.1, 24.0, 21.8]\n[22.5, 24.0]\n[22.5, 24.0, 21.8]\n[21.8, 22.5, 24.0, 21.8, 23.1, 22.5]\n\n\nMan kann auch mit dem Operator in fragen, ob ein spezifischer Wert in der Liste enthalten ist:\n\n23.1 in temperatures\n\nTrue\n\n\nPraktisch sind auch die Funktionen min() und max():\n\nprint(\"Min: \", min(temperatures))\nprint(\"Max: \", max(temperatures))\n\nMin:  21.8\nMax:  24.0\n\n\nDabei muss intern aber jedes Element einzeln abgefragt werden, mit Pech also die gesamte Liste durchgegangen werden.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#analyse-der-einzigartigen-messwerte-anwendung-des-sets",
    "href": "notebooks/6-sequences.html#analyse-der-einzigartigen-messwerte-anwendung-des-sets",
    "title": "8  Datenstrukturen in Python",
    "section": "8.2 Analyse der einzigartigen Messwerte – Anwendung des Sets",
    "text": "8.2 Analyse der einzigartigen Messwerte – Anwendung des Sets\nWir möchten wissen, welche Temperaturwerte einzigartig sind. Hierfür ist ein Set ideal, da es automatisch doppelte Einträge entfernt. Würden wir weiter mit einer Liste arbeiten, müssten wir selbst die Daten filtern, z.B. mit den uns bekannten Schleifen. Das wäre allerdings deutlich ineffizienter. Das Set entspricht einer mathematischen Menge, in der jedes Element nur einmal vorkommen darf. Für die Umwandlung führen wir ein explizites Casting durch:\n\nunique_values = set(temperatures)\nprint(unique_values) # keine doppelten Werte mehr\n\n{24.0, 21.8, 22.5, 23.1}\n\n\nSyntaktisch erkennen Sie das Set an den geschweiften Klammern {}. Ein Set erlaubt alle bekannten Mengenoperationen, die Sie aus der Mathematik kennen (z.B. Durchschnitt oder Vereinigung). Nehmen wir an, wir wollen überprüfen, ob unser Sensor mit einer anderen Messreihe gemeinsame Werte hat. Hierfür können wir ganz einfach die Schnittmenge aus beiden Mengen untersuchen:\n\nsecond_temperatures = [22.0, 23.1, 25.0, 22.4, 20.8]\nsecond_set = set(second_temperatures)\nintersection = unique_values.intersection(second_set)\nprint(\"Gemeinsame Werte: \", intersection)\n\nGemeinsame Werte:  {23.1}\n\n\nDie Abfrage mit dem Operator in ist übrigens bei Sets viel effizienter als bei Listen. Das liegt an einem Trick: Zu jedem Element eines Sets berechnet Python einen sog. “Hash-Wert”, der angibt, wo das Element im Speicher liegt. Fragt man, ob ein Element im Set liegt, muss Python nur den Hash-Wert für dieses Element berechnen und checken, ob der entsprechende Speicherplatz zum Set gehört. Daher ist der Aufwand - anders als bei Listen - unabhängig von der Größe des Sets!\n\nÜbungen:\n\nErstellen Sie eine eigene Liste mit fünf Messwerten. Erweitern Sie Ihre Liste durch append() auf insgesamt 8 Elemente.\nGeben Sie mithilfe des Slicing-Operators folgende Messwerte aus: a) die ersten drei, b) jeden zweiten, c) alle zwischen dem 3. und 7. Messwert (ohne den 3. und ohne den 7. Messwert selbst) d) die letzten drei.\nFinden Sie den größten und den kleinsten Wert Ihrer Messreihe.\nSortieren Sie alle Messwerte der Größe nach von klein nach groß. Finden Sie auch heraus, wie Sie die umgekehrte Sortierung erhalten (also vom größten zum kleinsten Wert).\n\nReduzieren Sie Ihre Datenreihe auf ein Set, welches nur einzigartige Messwerte enthält.\n\n\n\nLösungsvarianten für die umgekehrte Sortierung in Aufgabe 4:\n\n\nCode\n# Variante 1\ndata = [1,3,5,2,3,4,0,-6]\ndata.sort(reverse=True)\nprint(data)\n\n# Variante 2\ndata = [1,3,5,2,3,4,0,-6]\nsorted_data = sorted(data, reverse=True)\nprint(sorted_data)\n\n# Variante 3\ndata = [1,3,5,2,3,4,0,-6]\nsorted_data = sorted(data)\nsorted_data.reverse()\nprint(sorted_data)\n\n# Variante 4\ndata = [1,3,5,2,3,4,0,-6]\nreverse_sorted_data = sorted(data)[::-1]\nprint(reverse_sorted_data)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#hinzufügen-von-zeitstempeln-anwendung-des-dictionaries",
    "href": "notebooks/6-sequences.html#hinzufügen-von-zeitstempeln-anwendung-des-dictionaries",
    "title": "8  Datenstrukturen in Python",
    "section": "8.3 Hinzufügen von Zeitstempeln – Anwendung des Dictionaries",
    "text": "8.3 Hinzufügen von Zeitstempeln – Anwendung des Dictionaries\nFür eine präzisere Darstellung ergänzen wir die Daten um Zeitstempel. Wir wären gerne in der Lage, folgende Frage zu beantworten: “Wie war die Temperatur am Tag xy zum Zeitpunkt z?”.\nHierzu speichern wir die Temperaturen als Werte (values) und die Zeitpunkte als Schlüssel (keys) in einem Dictionary. Bei einem Dictionary greift man über einen eindeutigen Schlüssel auf das entsprechende Element zu. Es bedarf keiner komplexen Suche nach dem passenden Element etc. Wir demonstrieren die Anwendung:\n\n# Dictionary für Zeitstempel und Temperaturen\ndata = {\n    \"2025-03-23 08:00\": 22.5,\n    \"2025-03-23 09:00\": 23.1,\n    \"2025-03-23 10:00\": 21.8,\n    \"2025-03-23 11:00\": 24.0,\n    \"2025-03-23 12:00\": 22.5,\n}\n\n# neue Werte können jederzeit einzeln hinzugefügt werden: \ndata[\"2025-03-23 13:00\"] = 21.8\n\nprint(data)\n\n{'2025-03-23 08:00': 22.5, '2025-03-23 09:00': 23.1, '2025-03-23 10:00': 21.8, '2025-03-23 11:00': 24.0, '2025-03-23 12:00': 22.5, '2025-03-23 13:00': 21.8}\n\n\nAchten Sie erneut auf die Syntax: Geschweifte Klammern (wie beim Set), aber darin befinden sich Auflistungen von Key:Value. Der Zugriff auf einzelne Elemente ähnelt syntaktisch dem Index-Zugriff bei einer Liste, aber anstelle eines Indizes verwendet man einen Schlüssel:\n\n# Zugriff auf bestimmte Temperatur\nprint(data[\"2025-03-23 09:00\"])\n\n23.1\n\n\nEine Gefahr besteht darin, dass man auf Schlüssel zugreifen möchte, die es nicht gibt. Dann würde das Programm abstürzen! Daher gibt es noch eine sicherere Zugriffsmethode über die Methode .get():\n\nprint(data.get(\"2025-03-23 09:00\"))\nprint(data.get(\"2025-03-23 22:00\")) # Key existiert nicht\nprint(data.get(\"2025-03-23 22:00\", \"Datensatz fehlt\")) # mit Alternativtext\n\n23.1\nNone\nDatensatz fehlt",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#speichern-einer-zweiten-messgröße---anwendung-des-tuples",
    "href": "notebooks/6-sequences.html#speichern-einer-zweiten-messgröße---anwendung-des-tuples",
    "title": "8  Datenstrukturen in Python",
    "section": "8.4 Speichern einer zweiten Messgröße - Anwendung des Tuples",
    "text": "8.4 Speichern einer zweiten Messgröße - Anwendung des Tuples\nNeben der Temperatur speichert der Sensor nun auch die relative Luftfeuchtigkeit. Wir speichern beide Messwerte als Tupel. Ein Tupel ist ähnlich wie eine Liste eine Kollektion von Elementen, aber mit dem Unterschied, dass diese unveränderlich sind. Man kann kein Element hinzufügen oder entfernen, auch keinen Wert überschreiben. Diese Einschränkungen machen das Tupel zu einem sehr effizienten und sicheren Datenformat. Syntaktisch erkennt man das Tupel an runden Klammern ():\n\nmeasurement = (23.4, 40) # Tupel mit zwei Werten\n\nMan kann die Werte eines Tupels über den Indexzugriff auslesen (aber nicht überschreiben!):\n\nprint(\"Temperatur: \", measurement[0])\nprint(\"Luftfeuchtigkeit: \", measurement[1])\n#measurement[0] = 25.0 ist nicht erlaubt!\n\nTemperatur:  23.4\nLuftfeuchtigkeit:  40\n\n\nUnser neues Dictionary sieht jetzt so aus:\n\n# Erweiterung: Values = Tupel aus Temperatur und Luftfeuchtigkeit\ndata = {\n    \"2025-03-23 08:00\": (22.5, 60),\n    \"2025-03-23 09:00\": (23.1, 55),\n    \"2025-03-23 10:00\": (21.8, 58),\n    \"2025-03-23 11:00\": (24.0, 61),\n    \"2025-03-23 12:00\": (22.5, 62)\n}\n\n# neuen Wert hinzufügen\ndata[\"2025-03-23 13:00\"] = (24.0, 58)\n\n# einen Zeitpunkt abfragen\nprint(data.get(\"2025-03-23 10:00\"))\n\n\n(21.8, 58)\n\n\nTatsächlich könnte man die beiden Messwerte natürlich auch als Liste mit zwei Elementen zusammenfassen, aber das Tupel hat in diesem Fall klare Vorteile: * Semantik: Ein Tupel repräsentiert eine feste Kombination von Werten, z. B. Temperatur und Luftfeuchtigkeit, die logisch zusammengehören. * Unveränderbarkeit: Tupel verhindern unbeabsichtigte Änderungen. (Will man bewusst einen Wert verändern, kann man in eine Liste umwandeln.) * Effizienz: Tupel benötigen weniger Speicherplatz und sind schneller zu verarbeiten als Listen.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#daten-mehrerer-sensoren---verschachtelte-dictionaries",
    "href": "notebooks/6-sequences.html#daten-mehrerer-sensoren---verschachtelte-dictionaries",
    "title": "8  Datenstrukturen in Python",
    "section": "8.5 Daten mehrerer Sensoren - verschachtelte Dictionaries",
    "text": "8.5 Daten mehrerer Sensoren - verschachtelte Dictionaries\nStellen Sie sich vor, wir hätten drei anstelle von einem Sensor und wollten die Daten aller Sensoren strukturiert erfassen. Hierzu können wir zwei Dictionaries ineinander verschachteln: Der erste Key ist der Name des Sensors, zugehöriger Value ist ein Dictionary, das wie bisher die Messwerte dieses einen Sensors sammelt (also Zeitstempel als Key, Messwert als Value). Im Code sieht das so aus:\n\n# Verschachtelte Dictionaries für drei Sensoren\ndata = {\n    \"Sensor1\": {\n        \"2025-03-23 08:00\": (22.5, 60),\n        \"2025-03-23 09:00\": (23.1, 55)\n    },\n    \"Sensor2\": {\n        \"2025-03-23 08:00\": (21.8, 57),\n        \"2025-03-23 09:00\": (22.0, 67)\n    },\n    \"Sensor3\": {\n        \"2025-03-23 08:00\": (24.0, 58),\n        \"2025-03-23 09:00\": (23.8, 57)\n    }\n}\n\n# So würde man Messwerte hinzufügen:\ndata[\"Sensor3\"][\"2025-03-23 10:00\"] = (25.2, 62) # Neuer Wert für Sensor 3",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#exkurs-mutable-und-immutable-datentypen-in-python",
    "href": "notebooks/6-sequences.html#exkurs-mutable-und-immutable-datentypen-in-python",
    "title": "8  Datenstrukturen in Python",
    "section": "8.6 Exkurs: Mutable und immutable Datentypen in Python",
    "text": "8.6 Exkurs: Mutable und immutable Datentypen in Python\nPython unterscheidet zwischen immutable (unveränderlichen) und mutable (veränderlichen) Datentypen. Diese Begriffe beziehen sich auf Instanzen eines bestimmten Datentyps:\n\nWenn eine Instanz immutable ist, kann sich ihr Wert nie verändern! Python wird deshalb denselben Wert nicht mehrmals speichern, sondern genau einmal. Wenn der Wert einer Variable, die auf eine immutable Instanz zeigt, sich verändert, zeigt die Variable hinterher auf eine andere Instanz! Integers, Floats, Bools, Strings und Tuples sind in Python immutable.\nAnders bei den mutable Datentypen: Hier kann die Instanz verändert werden. Dies führt zu Seiteneffekten, wenn mehrere Variablen dieselbe Instanz referenzieren. Listen, Dictionaries und Sets sind mutable.\n\nVielleicht können Sie jetzt schon ahnen, dass diese Unterschiede zu ungewolltem Verhalten führen können, wenn man sich ihrer nicht bewusst ist. Bei Unsicherheiten können Sie die Identitäten abfragen. Es gibt aber noch eine direktere Möglichkeit, nämlich den is-Operator: Er liefert True, wenn zwei Variablen auf dieselbe Instanz zeigen:\n\nmy_shopping_list = ['apples', 'oranges', 'paper']\nyour_shopping_list = my_shopping_list\n\n# Mit is auf identische \n# Instanzen prüfen:\nmy_shopping_list is your_shopping_list \n\nTrue\n\n\nWenn die Instanz in diesem Beispiel über eine der beiden Referenzen geändert wird, hat das auch Auswirkungen auf die zweite Referenz:\n\nmy_shopping_list.append('shoes')  # Instanz verändert sich!\nprint(your_shopping_list)\n\n['apples', 'oranges', 'paper', 'shoes']\n\n\nSeiteneffekte können auch durch den Aufruf von Funktionen auftreten: Wir übergeben an Funktionen eine Referenz auf eine Instanz. Wenn die Instanz mutable ist, kann die Funktion die Instanz verändern! Hierzu eine Demo:\n\ndef append_a(l:list, a:int):\n    l.append(a)\n\nmy_list = [1,2,3]\nappend_a(my_list, 100)\n\nprint(my_list)\n\n[1, 2, 3, 100]\n\n\nBehalten Sie stets im Hinterkopf, dass es um die Instanz geht. Natürlich können Sie die Variable, die auf eine immutable Instanz zeigt, ändern. Dann zeigt sie aber auf eine andere Instanz.\n\n\n\n\n\n\nWie ist das in anderen Sprachen?\n\n\n\nDas Konzept der Immutability, wie wir es in Python kennengelernt haben, existiert nicht genauso in anderen Sprachen. Auch der prinzipielle Umgang mit Speicher unterscheidet sich teils grundlegend. Sprachen wie Java oder C# sind Python ähnlicher, da sie Instanzen und Referenzen verwenden und teilweise Immutability durch Sprachmechanismen unterstützen, wie z. B. immutable Strings oder Klassen.\nIn C hingegen gibt es keine Sprachmechanismen für immutable Instanzen. Stattdessen operiert C als Low-Level-Sprache direkt mit Speicheradressen. Werte können überschrieben und mehrere Pointer auf denselben Speicherbereich angelegt werden, die den Wert dort verändern können. Es liegt in der Verantwortung der Programmierer, Speicher sicher zu verwalten, was anfällig für Fehler macht – etwa Speicherlecks oder unvorhergesehene Zustandsänderungen. Die Freiheit von C ist jedoch unverzichtbar, wenn es um Hardware-nahe Programmierung, Performance-Optimierung oder ressourcensparende Anwendungen geht.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#sicheres-kopieren-von-listen",
    "href": "notebooks/6-sequences.html#sicheres-kopieren-von-listen",
    "title": "8  Datenstrukturen in Python",
    "section": "8.7 Sicheres Kopieren von Listen",
    "text": "8.7 Sicheres Kopieren von Listen\nSeien Sie immer auf der Hut, wenn Sie eine Liste kopieren wollen. Da sie zu den mutable Datentypen gehört, erzeugen Sie schnell unbeabsichtigt nur eine zweite Referenz auf das Original mit den genannten Seiteneffekten als Gefahr. Eine einfache Möglichkeit, dies zu umgehen, ist eine Kopie mithilfe des Slicing-Operators:\n\noriginal = [\"apples\", \"oranges\", \"books\"]\n\n# Zuweisung erzeugt nur eine zweite Referenz:\nsecond_reference = original  # keine Kopie! \n\n# mit Slicing eine Kopie erzeugen:\ncopy = original[:] \n\n# Wir zeigen, dass copy keine Seiteneffekte hat: \ncopy.append(\"bananas\")\nprint(\"Original: \", original) # unverändert\nprint(\"Kopie: \", copy)\n\nOriginal:  ['apples', 'oranges', 'books']\nKopie:  ['apples', 'oranges', 'books', 'bananas']\n\n\nEs gibt allerdings noch eine Diffizilität: Der Trick mit dem Slicing-Operator funktioniert nur so lange, wie die Elemente der Liste immutable sind. Sollten sich darunter aber mutable Datentypen befinden, kann es immer noch zu Seiteneffekten kommen. Wir haben zwar eine Kopie erstellt, allerdings nur eine sog. “flache Kopie”. Um alle Mehrfachreferenzen aufzulösen und eine völlig unabhängige Kopie zu erhalten, braucht es eine sog. “tiefe Kopie”. Hierfür gibt es bestimmte Algorithmen aus dem Modul copy:\n\nimport copy\noriginal = [[1,2],3,4] # Liste mit einem mutable Element\n\ncopy1 = original[:] # flache Kopie\ncopy2 = copy.deepcopy(original) # tiefe Kopie\n\n# Demo der Seiteneffekte:\n# Das mutable erste Element wird in den Kopien verändert\ncopy1[0].append(3) \ncopy2[0].append(100)\n\nprint(\"Original: \", original)\nprint(\"flache Kopie: \", copy1)\nprint(\"tiefe Kopie: \", copy2)\n\nOriginal:  [[1, 2, 3], 3, 4]\nflache Kopie:  [[1, 2, 3], 3, 4]\ntiefe Kopie:  [[1, 2, 100], 3, 4]\n\n\nDie Änderungen an der flachen Kopie hatten noch Auswirkungen auf das Original, weil beide die Referenz auf das erste Element teilten, welches mutable war. Nur bei der tiefen Kopie handelt es sich um eine völlig autarke Kopie, die nichts mehr mit dem Original gemein hat.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/7-bibs.html",
    "href": "notebooks/7-bibs.html",
    "title": "9  Die Verwendung von Bibliotheken",
    "section": "",
    "text": "9.1 Einführung zu Bibliotheken",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Die Verwendung von Bibliotheken</span>"
    ]
  },
  {
    "objectID": "notebooks/7-bibs.html#nützliche-python-bibliotheken",
    "href": "notebooks/7-bibs.html#nützliche-python-bibliotheken",
    "title": "9  Die Verwendung von Bibliotheken",
    "section": "9.2 Nützliche Python-Bibliotheken",
    "text": "9.2 Nützliche Python-Bibliotheken\n\nNumPy\n\n\nMatplotlib\n\n\nPandas",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Die Verwendung von Bibliotheken</span>"
    ]
  }
]