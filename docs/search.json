[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmierung für Ingenieurinnen und Ingenieure",
    "section": "",
    "text": "Version: 2.3\nWillkommen zu dieser Einführung in die Programmierung! Dieses Skript bildet die Basis für die Vorlesungen „Ingenieurinformatik 1“ und „Grundlagen der Programmierung“ an der Hochschule Trier. Keine Sorge, Vorkenntnisse in Programmierung oder Informatik sind nicht erforderlich!\nWir werden die grundlegenden Konzepte und deren praktische Umsetzung in der Programmiersprache Python erkunden. Der Kurs richtet sich an Studierende der Ingenieurwissenschaften in den ersten beiden Semestern, ist aber auch für Interessierte mit anderen Hintergründen geeignet.\nObwohl Python unsere exemplarische Programmiersprache ist, handelt es sich nicht um einen reinen Python-Kurs. Unser Ziel ist es, ein umfassendes Grundverständnis der Programmierung zu vermitteln: Wie funktioniert sie? Welche fundamentalen Konzepte gibt es in nahezu allen Programmiersprachen und wie können diese genutzt werden, um Probleme zu lösen? Um den Blick für das große Ganze zu bewahren, ziehen wir immer wieder Vergleiche mit anderen Programmiersprachen und vermeiden es, zu tief in die spezifischen Details von Python einzutauchen.\nNach erfolgreichem Abschluss des Kurses werden Sie in der Lage sein, die Themen, die für Ihren persönlichen Weg von besonderer Bedeutung sind, eigenständig zu vertiefen. Das Gelernte wird Ihnen auch ein sicheres Fundament geben, wenn Sie eine andere Sprache als Python lernen müssen (oder wollen). Abschließend sei noch auf den Folgekurs “Ingenieurinformatik II” hingewiesen, der auf diesem Kurs aufbaut und den Fokus stärker auf Anwendung und Problemlösung legt.\nNo one is perfect: Das Skript befindet sich noch im Aufbau und es werden sich leider Fehler einschleichen (wie übrigens auch in jedem größeren Programm). Hinweise bitte an den Autor: m.weber@hochschule-trier.de\nViel Erfolg bei diesem Kurs – oder wie man unter Programmierer*innen sagt: Happy Coding!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Vorwort</span>"
    ]
  },
  {
    "objectID": "notebooks/0-einleitung.html",
    "href": "notebooks/0-einleitung.html",
    "title": "2  Einleitung",
    "section": "",
    "text": "2.1 Was ist Programmierung?\nProgrammierung ist die Kunst und Wissenschaft, Computer dazu zu bringen, bestimmte Aufgaben auszuführen. Dies geschieht, indem man ihnen genaue Anweisungen in Form von Code gibt. Dabei werden Logik, Problemlösungsfähigkeiten und technisches Know-how kombiniert, um Software-Anwendungen, Websites, Spiele und vieles mehr zu entwickeln. Programmieren ist nicht nur eine technische Fertigkeit, sondern auch ein kreativer Prozess, der neue Lösungen für reale Herausforderungen ermöglicht.\nIn der Praxis bedeutet Programmieren weit mehr als nur das Schreiben von Code. Es umfasst das Verstehen von Problemen, das Entwerfen effizienter Lösungen sowie das Testen und Optimieren von Programmen. Gerade in den angewandten Wissenschaften spielt Programmieren eine zentrale Rolle, um praxisnahe Lösungen zu entwickeln – sei es die Automatisierung eines Fertigungsprozesses, die Analyse komplexer Daten oder die Optimierung einer Maschine.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "notebooks/0-einleitung.html#was-ist-programmierung",
    "href": "notebooks/0-einleitung.html#was-ist-programmierung",
    "title": "2  Einleitung",
    "section": "",
    "text": "Exemplarische Anwendungsbereiche der Programmierung\nAutomatisierung: Vereinfachen von Routineaufgaben. \nRobotik: Steuern von Robotern und automatisierten Maschinen. \nDatenanalyse: Analysieren großer Datenmengen. \nKünstliche Intelligenz: Entwickeln von KI-Systemen, z.B. zur Klassifizierung oder Generierung von Bildern.\nCybersecurity: Schützen von Computersystemen und Netzwerken vor Angriffen.\nMedizinische Informatik: Entwickeln von Softwarelösungen für das Gesundheitswesen. \nE-Commerce: Erstellen von Online-Shops und Zahlungsplattformen. \nWebentwicklung: Erstellen und Gestalten von Websites und Webanwendungen. \nSpieleentwicklung: Entwickeln von Computerspielen.\nMobile Apps: Programmieren von Anwendungen für Smartphones und Tablets.\nProgrammieren zu lernen ist vergleichbar mit dem Erlernen einer neuen Sprache: Je mehr Sie üben, desto besser können Sie Ihre Ideen in funktionsfähige Programme umsetzen. Lassen Sie sich dabei nicht von der Vielzahl an Programmiersprachen abschrecken. Ähnlich wie beim Sprachenlernen erleichtert das Wissen über eine Sprache das Erlernen einer weiteren: Wer Spanisch beherrscht, wird sich leichter in Italienisch zurechtfinden. Und selbst bei einer völlig anderen Sprache wie Japanisch profitieren Sie von Ihrer allgemeinen Sprachlernerfahrung. Deshalb beginnt man mit einer ausgewählten Programmiersprache und baut auf diesem Wissen auf, wenn man weitere benötigt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "notebooks/0-einleitung.html#welche-bedeutung-hat-programmierung-für-ingenieurinnen-und-ingenieure",
    "href": "notebooks/0-einleitung.html#welche-bedeutung-hat-programmierung-für-ingenieurinnen-und-ingenieure",
    "title": "2  Einleitung",
    "section": "2.2 Welche Bedeutung hat Programmierung für Ingenieurinnen und Ingenieure?",
    "text": "2.2 Welche Bedeutung hat Programmierung für Ingenieurinnen und Ingenieure?\nProgrammieren ist längst kein reines IT-Thema mehr – es ist ein unverzichtbares Werkzeug für moderne Ingenieurinnen und Ingenieure. Ob Maschinenbau, Elektrotechnik, Mechatronik oder Bauingenieurwesen – in nahezu jedem ingenieurwissenschaftlichen Bereich spielen Software und Algorithmen eine zentrale Rolle. Eine Auswahl an Argumenten, warum Grundfertigkeiten der Programmierung für Ingenieurinnen und Ingenieure unverzichtbar sind:\n\nAutomatisierung und Effizienzsteigerung: Ingenieurinnen und Ingenieure nutzen Programmierung, um wiederkehrende Aufgaben zu automatisieren und somit die Effizienz zu steigern. Dies kann die Steuerung von Maschinen und Prozessen umfassen, aber auch die Erstellung von Berichten und Analysen. Durch Automatisierung können Fehler reduziert und Zeit gespart werden, was zu einer höheren Produktivität führt.\nSimulation als Schlüsselwerkzeug: Simulationen ermöglichen Ingenieurinnen und Ingenieuren, komplexe Prozesse oder Systeme virtuell nachzubilden, zu analysieren und zu optimieren. Programmierkenntnisse sind hier unverzichtbar, um leistungsfähige Simulationen zu entwickeln und anzupassen.\nDatenanalyse und Entscheidungsfindung: In der modernen Ingenieurpraxis fallen große Mengen an Daten an. Programmierkenntnisse ermöglichen es Ingenieurinnen und Ingenieuren, diese Daten zu sammeln, zu analysieren und daraus fundierte Entscheidungen zu treffen. Dies ist besonders wichtig in Bereichen wie der Qualitätskontrolle, der Forschung und Entwicklung sowie der Prozessoptimierung.\nEntwicklung von maßgeschneiderten Lösungen: Ingenieurinnen und Ingenieure stehen oft vor komplexen Problemen, die standardisierte Softwarelösungen nicht immer abdecken können. Durch Programmieren können sie individuelle Softwarelösungen entwickeln, die genau auf ihre spezifischen Anforderungen zugeschnitten sind. Mit Programmierkenntnissen können sie dabei auch auf OpenSource-Frameworks, globale Entwicklungscommunities und eine nahezu unbegrenzte Palette an modernen Tools zugreifen.\nInterdisziplinäre Zusammenarbeit: Die Fähigkeit zu programmieren erleichtert die Zusammenarbeit mit anderen Fachbereichen, wie der Informatik oder der Datenwissenschaft. Ingenieurinnen und Ingenieure können durch Programmierkenntnisse besser kommunizieren und gemeinsame Projekte effizienter umsetzen. Dies fördert den interdisziplinären Austausch und die Innovationskraft.\nKarrierechancen und berufliche Weiterentwicklung: Programmierkenntnisse sind in der heutigen Arbeitswelt sehr gefragt und eröffnen Ingenieurinnen und Ingenieuren vielfältige Karrierechancen. Sie können sich in Bereichen wie der Robotik, der künstlichen Intelligenz, der Automatisierungstechnik oder der Medizintechnik spezialisieren. Darüber hinaus verbessern Programmierkenntnisse die berufliche Flexibilität und die Fähigkeit, sich an neue technologische Entwicklungen anzupassen.\nEntscheidende Metakompetenzen: Programmieren fördert wichtige Metakompetenzen, die Ingenieurinnen und Ingenieuren helfen, in ihrer Arbeit erfolgreich zu sein. Dazu gehören:\n\nKritisches Denken: Die Fähigkeit, Probleme systematisch zu analysieren und fundierte Entscheidungen zu treffen.\nProblemlösungsfähigkeiten: Entwickeln kreativer und effektiver Lösungen für komplexe technische Herausforderungen.\nTeamarbeit: Zusammenarbeiten in interdisziplinären Teams und effektive Kommunikation mit Kolleginnen und Kollegen.\nAnpassungsfähigkeit: Schnell auf neue Technologien und Methoden reagieren und diese in die Arbeit integrieren.\nSelbstständiges Lernen: Kontinuierliches Lernen und Weiterentwickeln der eigenen Fähigkeiten, um immer auf dem neuesten Stand der Technik zu bleiben.\n\n\nIm Zusammenhang mit dem letzten Punkt ist eine Untersuchung des World Economic Forums (Link) interessant, welche versucht, die Schlüsselqualifikationen für den zukünftigen Arbeitsmarkt zu identifizieren:\n\n\n\n\n\n\nAbbildung 2.1: Wichtigste Zukunftsskills laut World Economic Forum.\n\n\n\n\nÜbungen:\n\nBetrachten Sie Abbildung 2.1, welche basierend auf einer Studie des World Economic Forums die wichtigsten Zukunftsskills auflistet. Welche dieser Skills könnten von einem Programmierkurs und weiteren Erfahrungen auf diesem Gebiet profitieren?\nKI ist in den letzten Jahren immer mächtiger geworden und kann selbständig Code schreiben. Diskutieren Sie vor diesem Hintergrund die Frage: Muss man heutzutage überhaupt noch programmieren lernen?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "notebooks/0-einleitung.html#grundbegriffe-algorithmus-und-programm",
    "href": "notebooks/0-einleitung.html#grundbegriffe-algorithmus-und-programm",
    "title": "2  Einleitung",
    "section": "2.3 Grundbegriffe: Algorithmus und Programm",
    "text": "2.3 Grundbegriffe: Algorithmus und Programm\n„In der Informatik geht es genauso wenig um Computer, wie in der Astronomie um Teleskope.“ ―Edsger W. Dijkstra (niederländischer Informatiker und Wegbereiter der Programmierung)\nDas Eingangszitat macht deutlich, dass Computer für die Informatik vor allem nützliche Werkzeuge sind. Werkzeuge wozu? Allgemein gesprochen: zur Lösung von Problemen. Hierzu werden Algorithmen entwickelt und in Programmen umgesetzt. Diese beiden Grundbegriffe möchten wir in diesem Abschnitt genauer definieren:\n\n\n\n\n\n\nAlgorithmus: Eine präzise, endliche Abfolge von Anweisungen zur Lösung eines Problems oder zur Durchführung einer Aufgabe.\n\n\n\nAlgorithmen bilden die Grundlage der Programmierung, indem sie die Logik und die Schritte definieren, die ein Computer ausführen muss, um ein gewünschtes Ergebnis zu erzielen. Sie sind aber unabhängig von einer Programmiersprache, müssen auch gar nicht auf einem Computer ausgeführt werden, sondern können theoretisch auch von Hand durchgeführt werden. Wir alle kennen Algorithmen für bestimmte Probleme aus der Schule, z.B. den Euklidischen Algorithmus, der den größten gemeinsamen Teiler (ggT) von zwei Zahlen berechnet. Eine wichtige Eigenschaft aller Algorithmen ist die Finitheit: Ein Algorithmus muss mit endlich vielen Schritten zu einem Ergebnis kommen (es können durchaus sehr viele Schritte sein, aber eben nicht unendlich viele). Oft wird behauptet, dass Algorithmen deterministisch seien, also bei gleicher Eingabe auch gleiche Ausgaben erzeugten. Das stimmt allerdings nicht immer, denn es gibt auch nicht-deterministische Algorithmen, die mit Zufallszahlen arbeiten und bei wiederholter Durchführung andere Ergebnisse liefern (ein Beispiel lernen wir in Ingenieurinformatik II kennen).\nBeispiel: Bubble-Sort einer Liste von Zahlen.\nProblem: Gegeben ist eine Liste von Zahlen, z.B. 42, 6, -7, 100, 3. Die Zahlen sollen der Größe nach aufsteigend sortiert werden.\nEin Algorithmus für dieses Problem ist der sog. “Bubble-Sort”:\n\nSchritt 1: Gehe zum ersten Element der Liste.\nSchritt 2: Vergleiche das aktuelle Element mit dem nächsten Element.\nSchritt 3: Wenn das aktuelle Element größer ist als das nächste Element, dann tausche die beiden.\nSchritt 4: Gehe zum nächsten Element und wiederhole die Schritte 2 und 3, bis du das Ende der Liste erreichst.\nSchritt 5: Gehe zurück zum Anfang der Liste und wiederhole die Schritte 1 bis 4, bis keine Vertauschungen mehr vorgenommen werden.\n\nProbieren Sie den Algorithmus einmal von Hand aus. An diesem Beispiel erkennen Sie bereits die wichtigsten Elemente vieler Algorithmen: Bedingungen (“Wenn…, dann…”) und Wiederholungen (“wiederhole die Schritte…, bis…”). Mit diesen Strukturen werden wir uns noch viel beschäftigen.\n\n\n\n\n\n\nProgramm: Eine Sammlung von Anweisungen, die ein Computer ausführt, um eine bestimmte Aufgabe zu erledigen.\n\n\n\nProgramme bestehen aus einem oder mehreren Algorithmen, die in der Regel mit zusätzlichen Anweisungen kombiniert werden, z.B. für die Ausgabe der Ergebnisse. Sie sind in einer Programmiersprache geschrieben (man sagt auch “implementiert” und spricht auch von einer “Implementierung” oder “Implementation” anstelle von einem Programm). Programme können von einfachen Skripten bis hin zu komplexen Softwareanwendungen reichen. Ein und derselbe Algorithmus kann je nach Wahl der Programmiersprache unterschiedlich aussehen und unterschiedlich schwer zu implementieren sein, da nicht jede Programmiersprache dieselben Funktionalitäten bietet. Manche Programmiersprachen bieten spezifische Funktionen und Bibliotheken, die die Implementierung erleichtern, während andere Sprachen möglicherweise mehr manuelle Arbeit erfordern.\nWie würde nun eine Implementierung von Bubble-Sort in Python aussehen? Hinweis: Sie müssen den folgenden Code selbstverständlich noch nicht verstehen, aber vielleicht können Sie bestimmte Parallelen zum Algorithmus bereits erkennen. Hinter dem Symbol # stehen übrigens Kommentare, die für Menschen zur Erläuterung gedacht sind und keine Auswirkung auf den Code haben.\n\n\nCode\n# Python-Code, der den Algorithmus \n# Bubble Sort implementiert:\n\ndef bubble_sort(numbers):    \n    # Vorbereitungen:\n    result = numbers[:]  # Input kopieren\n    n = len(numbers)  # Länge der Liste \n    swapped = True # merkt sich, ob getauscht wurde\n\n    # Es folgt eine Schleife, die\n    # den Algorithmus wiederholt, bis nicht\n    # mehr getauscht wurde\n    while swapped: \n        swapped = False    \n       \n        # alle Elemente durchlaufen:\n        for j in range(1, n): \n            if result[j-1] &gt; result[j]:\n                # Vorgänger ist größer als Nachfolger: tauschen!\n                result[j-1], result[j] = result[j], result[j-1]\n                swapped = True  # es wurde getauscht\n\n    # die sortierte Liste wird zurückgegeben:\n    return result\n\n\nNatürlich wollen wir unsere Implementierung testen:\n\nbubble_sort([42,6,-7,100,3])\n\n[-7, 3, 6, 42, 100]\n\n\n\nÜbungen:\n\nErinnern Sie sich an Algorithmen aus der Schulzeit und lassen Sie sich von einer KI (z.B. ChatGPT) eine Implementierung vorschlagen. Variieren Sie die Programmiersprache und vergleichen Sie!\nIst es bei Bubble Sort wirklich erforderlich jedes Mal durch die gesamte Liste zu gehen? Wie könnte man den Algorithmus optimieren?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "notebooks/0-einleitung.html#von-assembler-bis-python-ein-kurzer-überblick-über-programmiersprachen",
    "href": "notebooks/0-einleitung.html#von-assembler-bis-python-ein-kurzer-überblick-über-programmiersprachen",
    "title": "2  Einleitung",
    "section": "2.4 Von Assembler bis Python: Ein kurzer Überblick über Programmiersprachen",
    "text": "2.4 Von Assembler bis Python: Ein kurzer Überblick über Programmiersprachen\nProgrammiersprachen sind Werkzeuge, die es Entwicklern ermöglichen, Anweisungen zu schreiben, die ein Computer ausführen kann. Sie spielen eine zentrale Rolle in der Softwareentwicklung und haben sich in den letzten Jahrzehnten stark weiterentwickelt.\n\nHistorie der Programmiersprachen\nDie Geschichte der Programmiersprachen beginnt in den 1940er Jahren mit der Entwicklung der ersten maschinennahen Sprachen. Hier sind einige wichtige Meilensteine:\n\n1940er Jahre: Die ersten maschinennahen Sprachen (Assembler) werden entwickelt. Sie ermöglichen es, Prozessorbefehle zu schreiben, die der Computer direkt versteht (der Laie allerdings umso weniger).\n1950er Jahre: Die Entwicklung von höheren Programmiersprachen beginnt, darunter Fortran (1957) und COBOL (1959). Diese Sprachen erlauben es, Programme in einer für Menschen verständlicheren Form zu schreiben.\n1960er und 1970er Jahre: Sprachen wie ALGOL, BASIC und C werden entwickelt. C wird besonders einflussreich und bildet die Grundlage für viele moderne Sprachen.\n1980er und 1990er Jahre: Objektorientierte Sprachen wie C++ und Java werden populär. Objektorientierung hilft, den Code besser zu strukturieren und wiederverwendbare Module zu erstellen. Python, eine vielseitige und leicht verständliche Sprache, wird 1991 veröffentlicht.\n\n\n\nInterpretiert oder kompiliert - das ist hier die Frage!\nProgrammiersprachen können grob in zwei Kategorien eingeteilt werden: interpretierte und kompilierte Sprachen.\n\nInterpretierte Sprachen: Diese Sprachen werden zeilenweise zur Laufzeit (also während das Programm läuft) vom Computer interpretiert und ausgeführt. Beispiele sind Python, JavaScript und Ruby. Vorteile interpretierter Sprachen sind ihre Flexibilität und Einfachheit, da sie in der Regel keine separate Kompilierungsphase erfordern. Allerdings können die Programme langsamer sein als bei kompilierten Sprachen, da der Code während der Ausführung interpretiert werden muss. Im Hintergrund arbeitet also immer ein sog. “Interpreter”.\nKompilierte Sprachen: Diese Sprachen werden vor der Ausführung in Maschinencode übersetzt, den der Computer direkt ausführen kann. Beispiele sind C, C++ und Go. Kompilierte Sprachen bieten in der Regel eine höhere Ausführungsleistung, da der Code vor der Ausführung optimiert wird und nicht mehr während der Ausführung interpretiert werden muss. Sie müssen allerdings für jede Plattform eine eigene Kompilierung durchführen und erhalten jeweils ein plattformspezifisches Ergebnis: z.B. entstehen für Windows die bekannten .exe-Dateien, die für Linux- oder Mac-Benutzer unbrauchbar sind.\n\n\n\nWelche Programmiersprache darf es denn sein?\nVielleicht fragen Sie sich an dieser Stelle, welche Programmiersprache denn nun die beste ist. Es muss doch eine geben, die alle anderen schlägt, oder? Die Antwort lautet, wie so oft im Leben: it depends! Und zwar hängt es von vielen Faktoren ab, sowohl technischen, als auch menschlichen, welche die beste Programmiersprache für ein bestimmtes Projekt ist. Nennen wir einige Aspekte:\n\nProjektanforderungen:\nUnterschiedliche Projekte begünstigen unterschiedliche Sprachen. Webentwicklung, Datenanalyse, maschinelles Lernen, Spieleentwicklung und Systemprogrammierung haben jeweils bevorzugte Programmiersprachen. Benötigt man die höhere Leistung von kompilierten Sprachen wie C und C++ oder eher die Portabilität von interpretierten Sprachen wie Python? Auch der Umgang mit dem Speicher unterscheidet sich von Programmiersprache zu Programmiersprache und könnte ein wesentlicher Faktor sein. \nUnterstützung durch Bibliotheken und Frameworks:\nProgrammiererinnen und Programmierer erfinden das Rad nicht täglich neu, sondern verwenden “Bibliotheken” und “Frameworks” für ihre Projekte. Das sind frei verfügbare Funktionen, Programme und Tools, die für spezielle Anwendungen zur Verfügung gestellt werden und die Arbeit erheblich vereinfachen und beschleunigen. Jede Programmiersprache bietet ihre eigene Palette!\nBeispiele: NumPy und Pandas in Python, React und Angular in JavaScript, Spring und Hibernate in Java.\nLernkurve, Community und persönlicher Geschmack:\nFür Anfängerinnen und Anfänger sind Sprachen wie Python und Ruby aufgrund ihrer klaren und einfachen Syntax ideal zum Lernen. Eine starke Community und umfangreiche Dokumentation können den Lernprozess erheblich erleichtern, da es zahlreiche Ressourcen gibt (die passenden zu finden, kann dennoch eine Herausforderung sein). Nicht zu unterschätzen sind aber auch die persönlichen Präferenzen: Welche Sprache liegt mir und welche mag ich einfach nicht? Menschen sind verschieden.\n\nDie Wahl der passenden Programmiersprache ist daher nicht immer eine einfache Entscheidung. Es kommt in der Praxis aber auch oft vor, dass man sich über diese Frage gar keinen Kopf zerbrechen muss: Man stößt z.B. neu zu einem Projekt dazu, bei dem die Sprache längst gesetzt ist. Auch ist es nicht selten, dass man älteren Code für die eigenen Zwecke anpassen muss und sich mit der dort verwendeten Sprache arrangieren muss.\nWie auch immer: Die eine one-size-fits-all-Sprache gibt es leider nicht. Wichtig ist, dass man die Grundkonzepte des Programmierens mit einer Sprache richtig gut gelernt hat, gleichzeitig aber offen gegenüber anderen Sprachen und neuen Technologien ist.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "notebooks/1-prep.html",
    "href": "notebooks/1-prep.html",
    "title": "3  Vorbereitungen",
    "section": "",
    "text": "3.1 Anaconda installieren\nIn diesem Kapitel geht es um die konkreten Vorbereitungen für das Programmieren in Python: Wir legen unsere Werkzeuge bereit! Dafür installieren wir Anaconda (eine weit verbreitete Python-Distribution) und eine IDE. Alternativ können Sie auch in der Cloud programmieren, ohne etwas auf Ihrem Rechner installieren zu müssen. Hierfür empfehlen wir Google Colab (siehe unten).\nIm Grunde bräuchten wir nur eine Python-Installation und einen Texteditor zum Programmieren. Wir gönnen uns aber etwas mehr Komfort und installieren “Anaconda”, eine umfassende Python-Distribution, die viele nützliche Bibliotheken und Werkzeuge integriert. Mit Anaconda können wir Python und wichtige Pakete problemlos installieren, verwalten und aktualisieren. Die integrierte Benutzeroberfläche, der Anaconda Navigator, ermöglicht den einfachen Zugriff auf beliebte Entwicklungsumgebungen wie Jupyter Notebooks oder Visual Studio Code (siehe unten).\nInstallationsanweisungen für die Plattformen Win / macOS / Linux findet man hier.\nMit der Anaconda Installation wird auch der Anaconda Navigator installiert, der eine grafische Benutzeroberfläche zur Verfügung stellt, mit der man Conda-Umgebungen und Bibliotheken verwalten, sowie Programme (z.B. IDEs) starten kann. Eine Dokumentation des Navigators findet man hier, die Bedienung ist aber intuitiv, probieren Sie es aus!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vorbereitungen</span>"
    ]
  },
  {
    "objectID": "notebooks/1-prep.html#anaconda-installieren",
    "href": "notebooks/1-prep.html#anaconda-installieren",
    "title": "3  Vorbereitungen",
    "section": "",
    "text": "Was ist eine Umgebung in Anaconda?\n\n\n\nUmgebungen (engl. environments) sind isolierte Arbeitsbereiche, in denen man verschiedene Versionen von Python und Paketen installieren und verwalten kann, ohne dass diese sich gegenseitig beeinflussen. Dies ist besonders nützlich, wenn man an mehreren Projekten arbeitet, die unterschiedliche Abhängigkeiten und Versionen von Bibliotheken erfordern. Die Standardumgebung heißt “base” und wir benötigen in diesem Kurs keine weiteren Umgebungen. Zum Experimentieren können Sie sich aber eine weitere Umgebung anlegen und dort Pakete installieren und testen, ohne Sorge zu haben in Ihrer Standardumgebung etwas “kaputt zu machen”.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vorbereitungen</span>"
    ]
  },
  {
    "objectID": "notebooks/1-prep.html#die-ide---unsere-werkbank-fürs-programmieren",
    "href": "notebooks/1-prep.html#die-ide---unsere-werkbank-fürs-programmieren",
    "title": "3  Vorbereitungen",
    "section": "3.2 Die IDE - unsere Werkbank fürs Programmieren!",
    "text": "3.2 Die IDE - unsere Werkbank fürs Programmieren!\nBeim Programmieren ist eine integrierte Entwicklungsumgebung (IDE, engl.: integrated development environment) das wichtigste Werkzeug – vergleichbar mit der Werkbank eines Handwerkers. Eine IDE kombiniert verschiedene Funktionen, die das Coden effizienter und angenehmer machen. Über Anaconda können wir verschiedene IDEs einfach über den Navigator installieren. Aber auch IDEs, die außerhalb des Navigators installiert werden, können in Anaconda integriert und später über den Navigator gestartet werden.\n\nWas ist eine IDE?\nEine IDE ist eine Software, die mehrere Programmier-Tools in einer einzigen Oberfläche bündelt. Typische Bestandteile sind:\n\nCode-Editor mit Syntax-Highlighting und Autovervollständigung. Das ist das Herzstück: Ein Texteditor, mit dem wir unseren Quellcode schreiben.\nDebugger, um Fehler im Code zu finden. Beim “Debuggen” sucht man systematisch nach einem Fehler im Programm und nutzt hierzu verschiedene technische Hilfsmittel (z.B. “Break Points”, die das Programm an bestimmten Stellen anhalten, um Variablen gezielt auszulesen und das gewünschte Verhalten zu überprüfen).\nCompiler oder Interpreter, um den Code auszuführen.\nVersionskontrolle, um Änderungen am Code zu verwalten.\n\n\n\nVorteile einer IDE\nWarum sollte man eine IDE nutzen? Die Alternative zur IDE wäre ein einfacher Texteditor ohne spezielle Coding-Funktionalitäten. Hier sind einige Gründe, die stark für die IDE sprechen:\n✅ Produktivität: Schnelleres Schreiben, Testen und Debuggen von Code.\n✅ Fehlerminimierung: Automatische Code-Analyse und Debugging-Werkzeuge.\n✅ Komfort: Bessere Übersicht und Organisation durch Projektverwaltung.\n\n\nIDEs für die Python-Entwicklung\n\nPyCharm\nPyCharm ist eine der bekanntesten IDEs für Python und wird von JetBrains entwickelt. Es gibt eine kostenlose Community Edition sowie eine kostenpflichtige Professional Edition mit erweiterten Funktionen. Studierende können eine kostenfreie Educational Licence erwerben (siehe PyCharm education).Ein Vorteil der Professional Edition ist, dass sie auch Jupyter Notebooks anlegen und bearbeiten kann.\nGetting Started with PyCharm: Guide.\nVisual Studio Code\nVisual Studio Code (VS Code) von Microsoft ist ein beliebter, kostenloser Code-Editor, der durch eine Vielzahl von Erweiterungen leicht in eine vollwertige IDE verwandelt werden kann. Es handelt sich im engeren Sinne nicht um eine IDE, sondern einen Editor. Erst durch die Installation von Extensions, wird VS Code zu einer mächtigen IDE und kann für verschiedene Programmiersprachen verwendet werden. Für Python benötigen wir z.B. die Python Extensions von Microsoft. Es gibt außerdem Extensions für das Arbeiten mit Jupyter Notebooks (siehe unten). Hier geht es zur Dokumentation.\nJupyter Notebooks\nJupyter Notebooks ist eine webbasierte Entwicklungsumgebung, die besonders beliebt für interaktive Datenanalyse oder maschinelles Lernen ist. Das Besondere ist die Kombination aus Markdown- und Code-Zellen. Während in Code-Zellen programmiert wird, können in Markdown-Zellen Texte formatiert werden, aber auch Bilder oder Animationen eingebunden werden (Markdown-Zellen unterstützen auch Latex-Befehle zur Darstellung mathematischer Formeln). So entsteht ein interaktives Skript, welches mehr als reiner Quellcode ist. Wir werden in der Vorlesung oft Jupyter Notebooks verwenden, da die Kombination aus Text, Bildern und Code für die Lehre sehr vorteilhaft ist. Auch dieses Skript ist in Jupyter Notebooks entstanden. Mehr darüber gibt es hier.\nJupyterLab ist eine Weiterentwicklung von Jupyter Notebooks.\nCloud-Alternative: Google Colab\nGoogle Colab (Colaboratory) ist eine cloudbasierte Entwicklungsumgebung. Mit Google Colab kann Python-Code direkt im Browser geschrieben und ausgeführt werden, ohne dass eine lokale Installation erforderlich ist. Im Prinzip können wir somit auch von einem Tablet oder Smartphone aus programmieren (ein kleiner Bildschirm und eine fehlende Tastatur können dennoch sehr herausfordernd sein beim Coden). Außerdem erhalten wir Zugriff auf leistungsstarke GPUs und TPUs, ohne dass wir uns selbst Hardware anschaffen müssen. In Google Colab arbeitet man ebenfalls mit der beliebten Notebook-Struktur aus Markdown- und Code-Zellen. Wenn man diese nicht braucht, kann man den gesamten Code in eine einzelne Zelle schreiben. Google Colab ermöglicht auch das gemeinsame Arbeiten an einem Projekt oder die Freigabe von Notebooks für andere. Zur Nutzung der Online-IDE ist ein (kostenfreies) Google-Konto erforderlich. Zu Google Colab geht es hier.\nEine Alternative wäre PythonAnywhere (siehe Website), allerdings ohne GPU-Unterstützung in der kostenlosen Version.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vorbereitungen</span>"
    ]
  },
  {
    "objectID": "notebooks/2-basics.html",
    "href": "notebooks/2-basics.html",
    "title": "4  Einführung ins Programmieren",
    "section": "",
    "text": "4.1 Das erste Programm: Hello, World!\nJetzt geht’s los: Wir schreiben unser erstes Programm! Danach lernen wir die grundlegenden Konzepte der Programmierung kennen: Arithmetische Operationen (das Rechnen), Zuweisungen (wie man Ergebnisse in Variablen speichert) und logische Ausdrücke (was ist wahr und was ist falsch?).\nWann immer man eine neue Programmiersprache lernt oder eine Programmierumgebung neu einrichtet (z.B. eine neue IDE installiert und ausprobiert), fängt man mit dem berühmten “Hello, World”-Programm an. Aufgabe des Programms ist die Ausgabe des Textes “Hello, World” auf dem Bildschirm. Ist dies gelungen, weiß man, dass man eine arbeitsfähige Umgebung hat und kann sich komplizierteren Aufgaben zuwenden. Let’s do it:\nprint('Hello, World')\n\nHello, World\nIn Python benutzen wir den Befehl print für eine Bildschirmausgabe. Er ist gleichzeitig unser erstes Beispiel für eine Funktion, das erkennen wir an den runden Klammern nach dem Befehl: Hier erwartet die Funktion ein Argument oder mehrere Argumente. Das kennen wir aus der Mathematik: Die Funktion \\(f(x)\\) erwartet als Argument einen Wert \\(x\\). Funktionen in der Programmierung unterscheiden sich allerdings in einigen Punkten von Funktionen in der Mathematik, wir werden z.B. gleich sehen, dass print mit beliebig vielen Argumenten aufgerufen werden kann, während \\(f(x)\\) immer genau ein Argument erwartet.\nDie Funktion print(...) wird mit dem auszugebenden Text aufgerufen. Texte werden in Python in einfache (') oder doppelte (\") Anführungszeichen gesetzt. Wir hätten also auch diesen Befehl verwenden können:\nprint(\"Hello, World\")\n\nHello, World\nDer print-Befehl in Python ist ein grundlegender und oft verwendeter Befehl, der dazu dient, Texte oder andere Daten auf dem Bildschirm anzuzeigen. Das ist sehr nützlich, um Informationen während der Ausführung eines Programms zu überprüfen oder Ergebnisse von Berechnungen anzuzeigen.\nWie bereits erwähnt, kann man auch mehr als ein Argument übergeben (getrennt durch ein Komma):\nprint(\"Hello,\", \"World!\")\n\nHello, World!\nDas Ergebnis ist dasselbe, da die einzelnen Argumente standardmäßig durch ein Leerzeichen getrennt werden. Dieses Verhalten kann durch weitere Argumente geändert werden. Probieren Sie das folgende einmal aus:\nprint(\"It\", \"is\", \"a\", \"beautiful\", \"day.\", sep=\"-\")\nNun haben Sie schon ein sog. “Keyword-Argument” kennengelernt: sep. Ein Keyword-Argument erkennen Sie daran, dass es explizit einem Namen zugewiesen wird, in unserem Beispiel durch sep=.... (Das Gegenstück dazu heißt “Positionsargumente”, es sind alle Argumente, die ohne Zuweisung übergeben werden. Ohne das Keyword sep könnte die print-Funktion das Argument nicht von den vorherigen unterscheiden. Auf den Unterschied zwischen Positions- und Keywordargumenten werden wir natürlich später noch ausführlicher eingehen. Wir sind hier noch bei unseren ersten Gehversuchen in der Welt der Programmierung.)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Einführung ins Programmieren</span>"
    ]
  },
  {
    "objectID": "notebooks/2-basics.html#das-erste-programm-hello-world",
    "href": "notebooks/2-basics.html#das-erste-programm-hello-world",
    "title": "4  Einführung ins Programmieren",
    "section": "",
    "text": "Übungen: 1. Experimentieren Sie mit dem print-Befehl. Können Sie außer Text auch andere Argumente verwenden? 2. Der print-Befehl kennt noch ein weiteres Keyword-Argument: end=.... Finden Sie durch Experimentieren heraus, was dieses Argument bewirkt. Sie können anschließend auch im Netz recherchieren, ob Sie es richtig verstanden haben. 3. Recherchieren Sie, wie das “Hello, World”-Programm in anderen Programmiersprachen aussieht. Suchen Sie mindestens nach C, C++, Java und einer weiteren Programmiersprache Ihrer Wahl. Wo erkennen Sie Ähnlichkeiten zu unserem Beispiel in Python und wo sieht es ganz anders aus?",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Einführung ins Programmieren</span>"
    ]
  },
  {
    "objectID": "notebooks/2-basics.html#python-als-taschenrechner",
    "href": "notebooks/2-basics.html#python-als-taschenrechner",
    "title": "4  Einführung ins Programmieren",
    "section": "4.2 Python als Taschenrechner",
    "text": "4.2 Python als Taschenrechner\nProgramme können mächtige Berechnungen und Analysen durchführen. Die Grundlage aller Berechnungen sind die Basisoperationen, die wir alle in der Schule gelernt haben. Anhand der folgenden Beispiele sehen Sie, wie wir mit Python rechnen können (es wechseln sich zeilenweise Ein- und Ausgabe ab; hinter # steht einen Kommentar, der nur für Menschen gedacht ist und das Programm nicht beeinflusst):\n\n# Addition\n3 + 2  \n\n5\n\n\n\n# Subtraktion\n6 - 2 \n\n4\n\n\n\n# so funktioniert es auch:\n-2 + 6  \n\n4\n\n\n\n# Multiplikation\n3 * 2  \n\n6\n\n\n\n# Division\n3 / 2 \n\n1.5\n\n\n\n# Ganzzahl-Division \n# (alle Nachkommastellen werden verworfen)\n3 // 2  \n\n1\n\n\n\n# Zweites Beispiel für \n# die Ganzzahl-Division\n9 // 2 \n\n4\n\n\n\n# Modulo-Division: Division mit Rest \n# Gibt den Rest zurück.\n9 % 2 \n\n1\n\n\n\n# Zweites Beispiel für Modulo\n31 % 7 \n\n3\n\n\n\n# Potenz \n3 ** 2  # 3 hoch 2  \n\n9\n\n\n\n# Klammern\n3 * (2 + 4) \n# Ohne Klammern hält sich \n# Python an Punkt vor Strich!\n\n18\n\n\nSelbstverständlich können wir nicht nur mit ganzen Zahlen rechnen, sondern auch mit Dezimalzahlen. Wichtig: Diese verwenden immer einen Punkt als Dezimalzeichen!\n\n# Dezimalzahlen\n2.8 + 3.2 \n\n6.0\n\n\nMöglich ist auch die sog. Exponentialschreibweise:\n\n# Exponentialschreibweise\n# e4 bedeutet \"mal 10 hoch 4\": \n# Komma um 4 Stellen nach rechts verschieben \n2e4 \n\n20000.0\n\n\n\n# e-4 bedeutet \"mal 10 hoch -4\": \n# Komma um 4 Stellen nach links verschieben\n2e-4 \n\n0.0002\n\n\nDie Exponentialschreibweise ist besonders praktisch um sehr große oder sehr kleine Zahlen kompakt darzustellen (ohne viele Nullen). Sie wird auch wissenschaftliche Notation genannt, da sie in wissenschaftlichen Kontexten häufig verwendet wird. Es folgen noch ein paar Beispiele:\n\n5.34e5\n\n534000.0\n\n\n\n1.267e-4\n\n0.0001267\n\n\n\n8.11e9  # Erdbevölkerung in 2025\n\n8110000000.0\n\n\n\nÜbungen:\n\nMachen Sie sich mit allen Operationen vertraut. Achten Sie auf die korrekte Syntax, z.B. * für die Multiplikation anstelle eines Punktes.\nFühren Sie die folgenden Berechnungen in Python aus:\n\n\n\\(2\\cdot(3+4)^2\\)\n\\(\\frac{7}{8}\\cdot(1,2 - 5,3)\\)\n\\(-3\\cdot(\\frac{4}{3} - 2,1)^3\\)\n\n\nLösungen der Rechenaufgaben:\n\n\nCode\n2 * (3 + 4)**2\n\n\n98\n\n\n\n\nCode\n7 / 8 * (1.2 - 5.3)\n\n\n-3.5874999999999995\n\n\n\n\nCode\n-3 * (4 / 3 - 2.1)**3\n\n\n1.3518888888888898",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Einführung ins Programmieren</span>"
    ]
  },
  {
    "objectID": "notebooks/2-basics.html#zuweisungen",
    "href": "notebooks/2-basics.html#zuweisungen",
    "title": "4  Einführung ins Programmieren",
    "section": "4.3 Zuweisungen",
    "text": "4.3 Zuweisungen\nIn der Programmierung sind Zuweisungen ein grundlegendes Konzept, um Werte in Variablen zu speichern. Eine Zuweisung erfolgt in Python mit dem Gleichheitszeichen (=). Schauen wir uns Beispiele an:\n\n# Zuweisung:\n# Die Variable x erhält den Wert 5\nx = 5 \n\n\nprint(x)  # Überzeugen wir uns davon!\n\n5\n\n\n\n# Die Variable name erhält\n# den Wert \"Tina\"\nname = \"Tina\" \n\n\n# Die Variable y erhält \n# den Wert 1.3\ny = 1.3 \n\nMit Variablen können wir rechnen:\n\n# Die Variable z erhält \n# den Wert der Addition x + y\nz = x + y \n\n\nprint(z)  # Überzeugen wir uns davon!\n\n6.3\n\n\n\n\n\n\n\n\nVorsicht\n\n\n\nDas Gleichheitszeichen ist nicht mit dem mathematischen Gleichheitszeichen zu verwechseln: In der Mathematik sind beide Seiten einer Gleichung gleichberechtigt und die Gleichung x = 5 ist entweder wahr oder falsch. In der Programmierung führen wir aber eine Operation durch, nämlich eine Zuweisung: Der Wert auf der rechten Seite wird der Variable auf der linken Seite zugewiesen!\n\n\nMachen Sie sich an dem folgenden Beispiel klar, dass x = y und y = x nicht dasselbe sind in der Programmierung!\n\n# Beispiel:\nx = 5\ny = 7\nx = y # was würde y = x am Ergebnis ändern?\nprint(x, y) \n\n7 7\n\n\nDie bisherigen Beispiele waren sog. Einfach-Zuweisungen: Einer Variable wurde ein Wert zugewiesen. In Python sind aber auch Mehrfach-Zuweisungen erlaubt (das ist eine Besonderheit, die es in anderen Programmiersprachen wie C oder C++ nicht gibt):\n\n# Zwei Variablen \n# gleichzeitig zuweisen:\nname, age = \"Tina\", 25 \n\n\nprint(\"Ich heiße\", name, \"und bin\", age, \"Jahre alt.\")\n\nIch heiße Tina und bin 25 Jahre alt.\n\n\nEinschub: Die letzte Ausgabe geht deutlich leichter, wie das folgende Beispiel zeigt.\n\n# Achten Sie auf das kleine f und die geschweiften\n# Klammern:\nprint(f\"Ich heiße {name} und bin {age} Jahre alt.\")\n# Hier verwenden wir einen sog. f-String. \n# Das f steht für formatiert bzw. formatted.\n# Es sagt Python, dass die Variablen in den geschweiften \n# Klammern durch ihre Werte ersetzt werden sollen.\n\nIch heiße Tina und bin 25 Jahre alt.\n\n\nSelbstverständlich kann sich der Wert einer Variable nach der ersten Zuweisung noch verändern, indem ein neuer Wert zugewiesen wird. Das demonstrieren wir anhand verschiedener Beispiele:\n\nBeispiel mit einer einzelnen Variable.\n\n\nx = 20  # x hat den Wert 20\nx = 21  # x hat den Wert 21\nx = 22  # x hat den Wert 22\nprint(x)  # Überzeugen wir uns!\n\n22\n\n\n\nBeispiel mit zwei Variablen.\n\n\nx = 1.2  # x hat den Wert 1.2\ny = 42  # y hat den Wert 42\nx = y  # x bekommt den Wert von y, also 42\ny = 0  # y bekommt den Wert 0, x bleibt unverändert\nprint(x, y)\n\n42 0\n\n\n\nBeispiel, welches den Unterschied zur mathematischen Gleichung noch einmal deutlich hervorhebt.\n\n\nx = 2\nx = x + 2 # Das Ergebnis von x+2 wird der Variable x zugewiesen.\nprint(x)\n\n4\n\n\n\n\n\n\n\n\nErweiterte Zuweisungen\n\n\n\nMit +=, -=, *=, /= können Zuweisungen wie im letzten Beispiel verkürzt werden. Dabei steht x += 5 für x = x + 5 (die anderen analog). Es wird also eine mathematische Operation mit der Variable durchgeführt (z.B. “addiere 5”) und das Ergebnis derselben Variablen als neuer Wert zugewiesen. Es handelt sich lediglich um eine kürzere Schreibweise.\n\n\n\nBeispiel mit erweiterten Zuweisungen.\n\n\nx,y,z = 1, 2, 3\nx += 10\ny -= 10\nz *= 10\nprint(x, y, z)\n\n11 -8 30\n\n\nWichtig: Python-Code wird vom Interpreter der Reihe nach abgearbeitet. Wenn Sie eine Variable z.B. erst nach einem Aufruf von print verändern, so bekommt der print-Befehl das nicht mit. Beispiel:\n\nx = 5\nprint(x)\nx += 10  # für das print darüber unerheblich!\nprint(x) # jetzt sieht man die Veränderung!\n\n5\n15\n\n\n\nEinschub: Benutzereingaben\nIn Python wird die Funktion input() verwendet, um Benutzereingaben zu erfassen. Sie wartet, bis der Benutzer eine Eingabe macht und mit Enter bestätigt. Der eingegebene Wert wird immer als Zeichenkette (also Text) zurückgegeben, kann aber bei Bedarf in andere Datentypen umgewandelt werden (mehr dazu im nächsten Kapitel). Die Eingabe des Benutzers wird häufig einer Variable zugewiesen, damit sie weiter verarbeitet werden kann. Als Argument können Sie der Funktion eine Aufforderung oder Frage übergeben:\n\nname = input(\"Wie heißen Sie? \")  # fragt nach dem Namen; speichert die Eingabe in name\ncity = input(\"Wo wohnen Sie? \")  # fragt nach dem Wohnort; speichert die Eingabe in city\nage = input(\"Bitte Alter eingeben: \")  # Variante mit Aufforderung statt Frage\n\nprint(f\"Sie heißen {name}, sind {age} Jahre alt und wohnen in {city}.\")\n\nWie heißen Sie?  John\nWo wohnen Sie?  New York\nBitte Alter eingeben:  40\n\n\nSie heißen John, sind 40 Jahre alt und wohnen in New York.\n\n\n\n\n\n\n\n\nGute Variablennamen\n\n\n\nObwohl Python im Vergleich zu anderen Programmiersprachen mehr Freiheiten bei der Benennung von Variablen zulässt (z.B. die Verwendung von Umlauten und anderen spezielle Buchstaben), sollte man sich auf das lateinische Alphabet beschränken. Der offizielle Python-Style-Guide (PEP) empfiehlt mit einem kleinen Buchstaben anzufangen und mehrere Wörter mit einem Unterstrich (_) zu trennen (das nennt man snake_case). Es sind auch Ziffern erlaubt (allerdings nicht am Anfang). Wichtig ist eine gute Verständlichkeit, damit auch andere Menschen Ihren Code nachvollziehen können. Daher empfehlen sich kurze, aber aussagekräftige Namen. Es folgen eine paar Beispiele:\ncustomer_name = \"Markus\"\nuser_age = 32\ntotal_price = 3.4e3\ncoordinate_1, coordinate_2, coordinate_3 = 3.1, -2.0, 0.0\nx_coordinate, y_coordinate, z_coordinate = -1.0, -1.0, 1.0\nIm Style-Guide wird außerdem davor gewarnt, dass die Buchstaben ‘l’ (kleines L), ‘O’ (großes o) oder ‘I’ (großes i) leicht mit den Zahlen ‘1’ bzw. ‘0’ verwechselt werden können (in manchen Schriftarten werden sie identisch dargestellt!). Immer darauf achten, ob es aus dem Kontext eindeutig zu erkennen ist.\nViele Organisationen oder Teams definieren übrigens eigene Style-Guides, die weitere Details festlegen. In internationalen Projekten legt man z.B. häufig fest, dass die englische Sprache im Code zu verwenden ist. Andere Unternehmen verwenden deutsche Wörter. Wenn Sie Teil eines Teams werden, fragen Sie nach den internen Konventionen (explizit niedergeschrieben oder implizit von allen befolgt).\nAbschließend sei an dieser Stelle darauf hingewiesen, dass Sie natürlich keine Schlüsselwörter von Python für Ihre Variablennamen verwenden dürfen. Bsp.: Ein Variable namens print ist nicht erlaubt, da dieser Begriff eine Funktion von Python bezeichnet. Verboten sind auch if, else, class, return, usw.\n\n\n\nÜbungen:\n\nBetrachten Sie das folgende Code-Beispiel und überlegen Sie sich, welche Werte am Schluss ausgegeben werden. Überprüfen Sie Ihr Ergebnis anschließend, indem Sie den Code implementieren:\n x = 5\n x += 10\n y = 2 * x + 10\n y -= 15\n x /= 2 \n print (x, y) \nBetrachten Sie die folgenden Variablennamen und schlagen Sie bessere vor:\nX = 10           # Anzahl der Äpfel im Korb\nCLIENTnum = 1440 # Kundennummer\nZähler = 0       # zählt etwas\ntxt = \"Hallo\"    # Begrüßungstext\nisLoggedIn = True  # Ob ein Benutzer angemeldet ist\nlO = 10.0       # Koordinate links oben",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Einführung ins Programmieren</span>"
    ]
  },
  {
    "objectID": "notebooks/2-basics.html#vergleiche",
    "href": "notebooks/2-basics.html#vergleiche",
    "title": "4  Einführung ins Programmieren",
    "section": "4.4 Vergleiche",
    "text": "4.4 Vergleiche\nIn Programmen wird viel gerechnet, wofür die arithmetischen Operationen, die wir bisher betrachtet haben, die Grundlage bilden. Ein weiteres grundlegendes Element von Programmen ist die Logik: Dabei geht es um die Entscheidung, ob etwas wahr oder falsch ist. Je nach Ergebnis kann ein Programm unterschiedliche Wege einschlagen: Ist eine Bedingung wahr, wird eine bestimmte Aktion ausgeführt. Ist sie falsch, passiert etwas anderes.\nSchauen wir uns nun die grundlegenden logischen Ausdrücke an, mit denen wir solche Entscheidungen treffen können. Vergleichen wir zunächst zwei Zahlen:\n\n1 &lt; 42  # Ist 1 kleiner als 42?\n\nTrue\n\n\n\n1 &gt; 42  # Ist 1 größer als 42?\n\nFalse\n\n\n\n2 &lt;= 3  # Ist 2 kleiner oder gleich 3?\n\nTrue\n\n\n\n2 &gt;= 3  # Ist 2 größer oder gleich 3?\n\nFalse\n\n\n\n2 == 3  # Ist 2 gleich 3?\n\nFalse\n\n\n\n2 != 3  # Ist 2 ungleich 3?\n\nTrue\n\n\n\n\n\n\n\n\nVorsicht\n\n\n\nFür den logischen Vergleich verwendet man das doppelte Gleichheitszeichen ==, welches nicht mit dem Zuweisungsoperator = verwechselt werden darf!\n\n\nWie Sie festgestellt haben, liefern logische Vergleiche als Ergebnis einen Wahrheitswert: True für wahr oder False für falsch. Wahrheitswerte können genauso wie andere Werte einer Variable zugewiesen werden:\n\nx = 3\ny = 0\ncomparison = x &gt; y  # Zuweisung\nprint(comparison)\n\nTrue\n\n\nDie Variable comparison speichert das Ergebnis des Vergleichs und kann an anderer Stelle im Programm verwendet werden. Es folgt ein Beispiel, welches auf die If-else-Verzweigung vorgreift (Sie können es sicher trotzdem schon verstehen):\n\nif (comparison):\n    print(x, 'ist größer als', y)\nelse:\n    print(x, 'ist kleiner oder gleich', y)\n\n3 ist größer als 0\n\n\n\n# Zur Erinnerung: Wir legen unsere\n# Variablennamen selbst fest. Hier zur Demo dasselbe\n# Beispiel erneut mit einem Quatsch-Namen:\nx = 3\ny = 0\ndagobert_duck = x &gt; y  # Zuweisung\nprint(dagobert_duck)\n# Wir könnten jetzt mit dagobert_duck\n# alles tun, was wir zuvor mit comparison\n# getan haben.\n\nTrue\n\n\nWahrheitswerte tauchen nicht nur bei Vergleichen von Zahlen auf, sondern auch in vielen anderen Situationen, wie zum Beispiel bei der Suche nach einem Buchstaben in einem Wort. Das würde in Python so aussehen:\n\n# Suche nach einem 'a' in 'apple':\n'a' in 'apple' \n\nTrue\n\n\n\n# Suche nach einem 'a' in 'lemon'\n'a' in 'lemon' \n\nFalse\n\n\n\n# Achtung: Kleinbuchstaben != Großbuchstaben\n'a' in 'YOGA'\n\nFalse\n\n\nMit der Negation not kehren wir einen Wahrheitswert in sein Gegenteil um, wie die folgenden Beispiele illustrieren:\n\nnot (4 &lt; 3)\n\nTrue\n\n\n\nnot ('a' in 'apple')\n\nFalse\n\n\nEinfache logische Ausdrücke können durch die Verknüpfungen or und and zu komplexeren Bedingungen kombiniert werden. Wenn zwei Bedingungen mit and verknüpft werden, ist die kombinierte Bedingung genau dann wahr, wenn beide Einzelbedingungen wahr sind:\n\n5 &gt; 4 and 4 &gt; 3 \n\nTrue\n\n\n\n5 &gt; 4 and 4 &gt; 6\n\nFalse\n\n\nVerknüpft man hingegen mit or, so genügt es, dass eine der beiden Einzelbedingungen wahr ist:\n\n5 &gt; 4 or 4 &gt; 6 # mindestens eine Bedingung wahr.\n\nTrue\n\n\n\n5 &gt; 4 or 4 &gt; 3 # beide wahr\n\nTrue\n\n\nProbieren Sie eigene Beispiele mit and, or und not aus!\n\n\n\n\n\n\nWahrheitswerte in anderen Programmiersprachen\n\n\n\nIn vielen Programmiersprachen werden Wahrheitswerte als True (wahr) und False (falsch) dargestellt. Die Schreibweise variiert aber je nach Sprache: * In Python: True, False * In C++ und PHP: true, false * In SQL: TRUE, FALSE (oder klein geschrieben)\nIntern werden Wahrheitswerte oft wie Zahlen behandelt: True entspricht dann einer 1 und False einer 0. Probieren Sie in Python Vergleiche der folgenden Art aus: True == 1, False == 0. Kleiner Vorgriff: An vielen Stellen (siehe Verzweigungen, Schleifen) werden in Python alle Zahlen ungleich 0 als True interpretiert.\n\n\n\nÜbungen:\n\nDefinieren Sie eine Variable age und weisen ihr das Alter einer Person zu. Schreiben Sie einen Vergleich, der True zurückgibt, wenn die Person erwachsen ist. Schreiben Sie einen weiteren Vergleich, der überprüft, ob die Person exakt 25 Jahre alt ist. Implementieren Sie einen dritten Vergleich, der überprüft, ob die Person jünger als 67 ist.\nRecherchieren Sie, wie der BMI (‘Body Mass Index’) definiert ist. Legen Sie Variablen für die benötigten Parameter einer Person an und berechnen Sie den BMI. Definieren Sie anschließend eine Variable, die True ist, wenn der BMI ein Normalgewicht anzeigt. Tipp: Verwenden Sie and, um zwei Bedingungen miteinander zu verknüpfen. (Lösung siehe unten.)\n\n\n\n\n\nCode\nlength = 1.80  # Größe in m\nweight = 75  # Gewicht in kg\nbmi = weight / length**2\nis_normal_weight = bmi &gt;= 18.5 and bmi &lt;= 24.9  # laut Wikipedia\n\n# Hinweis: Wir verwenden in der Ausgabe \n# round(), um das Ergebnis auf eine Stelle zu runden\nprint('BMI:',round(bmi,1),'Normalgewicht?', is_normal_weight)\n\n\n\n\n\n\n\n\nComparison Chains in Python\n\n\n\nEs gibt in Python eine Möglichkeit, mehrere Vergleiche miteinander zu verketten, wie man es z.B. aus der Mathematik kennt. Die Vergleiche in der Kette werden einzeln ausgewertet und mit and verknüpft:\n\n\n\nComparison Chain\nBedeutung\n\n\n\n\n18.5 &lt;= x &lt;= 24.9\n18.5 &lt;= x and x &lt;= 24.9\n\n\nx &lt; y &gt; z\nx &lt; y and y &gt; z\n\n\nx == y == z\nx == y and y == z\n\n\nx != y != z\nx != y and y != z\n\n\n\nWährend das erste Beispiel genauso aussieht, wie man es aus der Mathematik kennt, sieht das zweite Beispiel vielleicht etwas seltsam aus. Die Vergleiche werden aber einfach der Reihe nach abgearbeitet, unabhängig davon, welche Vergleichsoperatoren verwendet werden. Das dritte Beispiel prüft, ob alle Variablen gleich sind. Trügerisch ist das vierte Beispiel x != y != z, da es nicht feststellt, ob alle Variablen ungleich sind (x und z werden nicht miteinander verglichen!).\nTipp: Setzen Sie Comparison Chains mit Bedacht ein. Am intuitivsten sind sie, wenn die Ausdrücke so aussehen, wie man es aus der Mathematik kennt (vgl. erste Zeile in der Tabelle).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Einführung ins Programmieren</span>"
    ]
  },
  {
    "objectID": "notebooks/2-basics.html#zum-abschluss-des-kapitels-ein-wenig-fachsprache",
    "href": "notebooks/2-basics.html#zum-abschluss-des-kapitels-ein-wenig-fachsprache",
    "title": "4  Einführung ins Programmieren",
    "section": "4.5 Zum Abschluss des Kapitels: ein wenig Fachsprache",
    "text": "4.5 Zum Abschluss des Kapitels: ein wenig Fachsprache\nWir können bereits eine Menge tun in Python. An dieser Stelle wollen wir kurz auf das bisher Gelernte zurückschauen und dabei zwei wichtige Fachtermini einführen, die Ihnen immer wieder begegnen werden. Es handelt sich um die Begriffe “Ausdruck” und “Literal”.\n\n\n\n\n\n\nAusdruck (engl. expression): Ein Ausdruck in der Programmierung ist eine Kombination von Werten, Variablen und Operatoren, die zusammen ein Ergebnis berechnen. Ein Ausdruck wird ausgewertet und liefert immer einen Wert, der in einer Variablen gespeichert oder direkt weiterverwendet werden kann.\n\n\n\nWir haben bereits verschiedene Ausdrücke kennengelernt: Arithmetische und logische Ausdrücke.\n\n5 + 3  # ist ein arithmetischer Ausdruck. Wert: 8\nx = 5 + 3 # nur die rechte Seite ist ein Ausdruck\n3 * x + 4  # ist ein arithmetischer Ausdruck\n\nIm letzten Beispiel ist die Zuweisung selbst kein Ausdruck, sondern nur die rechte Seite. In manchen Programmiersprachen sind aber auch Zuweisungen Ausdrücke: In C gibt die Zuweisung x=3 gleichzeitig den Wert 3 zurück und ist somit auch ein Ausdruck. Es sind dann auch solche Zuweisungen möglich: y = (x = 3). In Python geht das nicht!\n\n4 &gt; 5  # ist ein logischer Ausdruck\n1 == 1  # ist ein logischer Ausdruck\ncomparison = 99 &gt; 42  # nur die rechte Seite ist ein Ausdruck\n\nWeiterhin können Funktionsaufrufe einen Ausdruck darstellen, wie zum Beispiel:\n\nlen('Apfel')  # gibt den Wert 5 zurück\n\n5\n\n\nAuch Variablen selbst können als Ausdruck betrachtet werden, denn sie geben ihren Wert zurück:\n\nx  # ist ein Ausdruck, gibt den Wert von x zurück\n\n\n\n\n\n\n\nLiteral (vom lateinischen Wort für Buchstabe): Ein Literal ist ein fester, unveränderlicher Wert (wie eine Zahl, eine Zeichenkette oder ein Wahrheitswert), der direkt im Code verwendet wird. Da Literale ausgewertet werden können, um einen Wert zu liefern, gelten sie ebenfalls als Ausdrücke.\n\n\n\nEs folgen einige Beispiele (die Datentypen erklären wir später):\n\n\"Hello, World\"  # String-Literal (Zeichenkette)\n4.2  # Float-Literal (Gleitkommazahl)\n-3  # Integer-Literal (Ganzzahl)\nTrue  # Boolean-Literal (Wahrheitswert)\n\n# Alle diese Literale sind gleichzeitig Ausdrücke:\n# Sie geben sich selbst als Wert zurück.\n\nWarum sollte man diese Begriffe kennen?\nWenn Sie mit anderen Programmiererinnen und Programmierern sprechen, fallen diese Begriffe. Zum Beispiel, wenn man sich über verschiedene Programmiersprachen unterhält (“Wie sieht ein String-Literal in deiner Sprache aus?”, “Welche logischen Ausdrücke kennt deine Sprache?”). Für Sie sind das jetzt keine Fremdwörter mehr!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Einführung ins Programmieren</span>"
    ]
  },
  {
    "objectID": "notebooks/3-datatypes.html",
    "href": "notebooks/3-datatypes.html",
    "title": "5  Datentypen und ihre Repräsentation",
    "section": "",
    "text": "5.1 Grundlegende Datentypen\nBeim Programmieren arbeiten wir ständig mit Daten – Zahlen, Texte, Wahrheitswerte und mehr. Wie aus dieser Aufzählung hervorgeht, gibt es unterschiedliche Datentypen, und jeder Typ hat einen Einfluss darauf, wie Daten dargestellt, verarbeitet und gespeichert werden. In diesem Kapitel lernen wir die wichtigsten Datentypen kennen und werfen einen genaueren Blick darauf, wie diese Daten gespeichert und verwaltet werden.\nIm Speicher des Computers liegen Daten als sog. Instanzen. Wie wir sehen werden, fungieren Variablen als Referenzen auf diese Instanzen (man könnte sagen: Wegweiser zu den Instanzen).\nZuletzt wollen wir noch verstehen, wie Instanzen von unterschiedlichen Datentypen eigentlich für den Computer aussehen, denn dieser versteht nur eine Sprache: das Binärsystem! Für jeden Datentyp existieren daher Kodierungen, die die jeweilige Information (ob Zahl oder Text) als Binärzahl ausdrücken.\nZum Abschluss des Kapitels zeigen wir, wie Datentypen ineinander umgewandelt werden können.\nMit der Funktion type() können wir in Python den Datentyp einer Variablen oder eines Literals abfragen:\ntype(4)  # Typ einer ganzen Zahl\n\nint\ntype(3.2)  # Typ einer Dezimalzahl\n\nfloat\ntype(\"Hallo\")  # Typ eines Textes\n\nstr\ntype(True)  # Typ eines Wahrheitswertes\n\nbool\n# Beispiel mit einer Variable\nx = 5.4\ntype(x)\n\nfloat\nDie folgende Tabelle fasst die gefundenen Datentypen zusammen:\nDie genannten Datentypen gibt es auch in vielen anderen Programmiersprachen, oft mit leicht unterschiedlichen Bezeichnungen oder Eigenschaften:\nDie vorgestellten Datentypen sind die Grundbausteine einer Programmiersprache, aus denen komplexere Datenstrukturen zusammengesetzt werden können. Man nennt sie daher oft auch primitive Datentypen.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datentypen und ihre Repräsentation</span>"
    ]
  },
  {
    "objectID": "notebooks/3-datatypes.html#grundlegende-datentypen",
    "href": "notebooks/3-datatypes.html#grundlegende-datentypen",
    "title": "5  Datentypen und ihre Repräsentation",
    "section": "",
    "text": "Datentyp\nBedeutung\n\n\n\n\nint (Integer)\nganze Zahlen\n\n\nfloat (Floating-point)\nGleitkommazahlen\n\n\nstr (String)\nZeichenketten (Text)\n\n\nbool (Boolean)\nWahrheitswert\n\n\n\n\n\n\n\n\n\nWas sind Gleitkommazahlen?\n\n\n\nDezimalzahlen können sehr viele Nachkommastellen haben. Um sie effizient zu speichern, nutzt der Rechner intern die wissenschaftliche Schreibweise, z. B. 2.1e-4 statt 0.00021. Dadurch werden führende oder nachfolgende Nullen vermieden. Statt der vollständigen Zahl speichert man nur die signifikanten Stellen (hier: 2.1, genannt Mantisse) und den Exponenten (hier: -4), sowie das Vorzeichen der Zahl (hier: positiv).\nDas wird besonders bei extrem kleinen oder großen Zahlen deutlich: 3.23e10 statt 32300000000 oder 1.2e-9 statt 0.0000000012. Der Dezimalpunkt „gleitet“ dabei entsprechend dem Exponenten, woher der Name Gleitkommazahl (floating-point) stammt.\nIm Gegensatz dazu gibt es Festkommazahlen, bei denen der Dezimalpunkt immer an einer festen Stelle steht (z. B. Währungsbeträge wie 12.34 Euro). Diese sind in der Informatik seltener, weil sie eine feste Genauigkeit haben und weniger flexibel sind. Sie werden nur in speziellen Anwendungen genutzt.\n\n\n\n\nC arbeitet u.a. mit int, float, double (Gleitkommazahl mit doppelter Genauigkeit), char (für einzelne Zeichen; Strings werden als Zeichenarrays gespeichert, sog. C-Strings); bool kann seit C99 über einen Header eingebunden werden.\nC++ führt u.a. eine String-Klasse ein (das Wort Klasse erklären wir in der objektorientierten Programmierung).\nJava kennt primitive Datentypen wie int, double, char und boolean, sowie die Klasse String für Texte.\nJavaScript nutzt Number für Ganz- und Gleitkommazahlen, Boolean für Wahrheitswerte und String für Texte.\n\n\n\nStatisch oder dynamisch typisiert?\nProgrammiersprachen unterscheiden sich darin, wie flexibel sie mit Datentypen umgehen. Man kann grundsätzlich zwischen zwei Arten unterscheiden:\nStatisch typisierte Sprachen: Datentypen werden vor der Laufzeit durch den Programmierer oder die Programmiererin definiert (z. B. in C, Java). Typenfehler (man versucht im Code etwas mit einem Datentyp zu machen, was nicht erlaubt ist) werden beim Kompilieren erkannt, was Sicherheit und Geschwindigkeit bietet, aber weniger flexibel ist.\nBeispiel-Code in C: int zahl = 42; Bei der Deklaration der Variable zahl muss bereits ihr Typ angegeben werden, hier: Integer. Sie darf im gesamten Programm niemals für einen anderen Typen verwendet werden (in vielen Fällen würde die Zuweisung trotzdem gelingen, aber durch ein implizites Casting (siehe unten) ein evtl. unbeabsichtigter Datenverlust stattfinden).\nDynamisch typisierte Sprachen: Typen werden automatisch zur Laufzeit bestimmt (z. B. in Python, JavaScript). Das schenkt eine höhere Flexibilität: Wir können an einer Stelle zahl = 42 und an einer anderen Stelle zahl = \"Apfel\" schreiben. Allerdings können sich so auch leichter Fehler einschleichen. Einen exemplarischen Typenfehler in Python zeigt der folgende Code:\n\nx = \"42\"\ny = \"2\"\nz = x / y # diese Zeile führt zu einem Fehler!\n# Strings können nicht durcheinander dividiert werden. \n# Oder könnten Sie \"Auto\" durch \"Apfel\" teilen?!\n\n\n\nKurzer Ausblick auf weitere Datentypen in Python\nPython verfügt von Haus aus über weitere praktische Datentypen, von denen wir nur ein paar hier vorstellen möchten. Einige davon werden wir in späteren Kapiteln noch genauer untersuchen und verstärkt einsetzen:\n\nshopping_list = ['apples', 'bananas', 'bread']\ntype(shopping_list)\n\nlist\n\n\nDer Datentyp list wird für eine geordnete Ansammlung von Elementen verwendet. Die Elemente werden wie im Beispiel zwischen eckigen Klammern ([]) aufgelistet. ‘Geordnet’ heißt in diesem Zusammenhang, dass die Elemente eine feste Reihenfolge haben: In unserem Beispiel ist 'apples' das erste Element, 'bananas' das zweite, usw. Wir können über den sog. Indexzugriff auch gezielt auf das erste, zweite, dritte, … Element einer Liste zugreifen:\n\nshopping_list[0]  # immer bei 0 anfangen zu zählen!\n\n'apples'\n\n\n\nshopping_list[1]  # Index 1 entspricht dem zweiten Element\n\n'bananas'\n\n\n\nshopping_list[2]  # Index 2 entspricht dem dritten Element\n\n'bread'\n\n\nEs gibt auch ungeordnete Ansammlungen von Elementen:\n\nfavorite_colors = {'red', 'blue', 'green'}\ntype(favorite_colors)\n\nset\n\n\nMit den geschweiften Klammern haben wir ein set angelegt, das einer mathematischen Menge entspricht: Es gibt keine Reihenfolge (der Indexzugriff funktioniert nicht!), außerdem kommt jedes Element nur einmal vor. Fügt man der obigen Menge die Farbe 'red' ein zweites Mal hinzu, gibt es das Element trotzdem nur einmal:\n\nfavorite_colors.add('red')  # wir fügen ein bereits vorhandenes Element hinzu\nprint(favorite_colors)\n\n{'blue', 'green', 'red'}\n\n\n\nfavorite_colors.add('yellow')  # wir fügen ein neues Element hinzu\nprint(favorite_colors)\n\n{'blue', 'green', 'yellow', 'red'}\n\n\nListen und Sets können mit verschiedenen Datentypen gefüllt und auch verschachtelt werden. Wir demonstrieren es am Beispiel einer Liste:\n\n# in dieser Liste befinden sich Einträge vom Typ\n# int, float, str und wiederum list\ncrazy_list = [1, 0.5, \"Monty Python\", [42, True]]\nprint(crazy_list)\n\n[1, 0.5, 'Monty Python', [42, True]]\n\n\n\ncrazy_list[0]  # erstes Element: der Integer 1\n\n1\n\n\n\ncrazy_list[3]  # viertes Element: die Liste [42, True]\n\n[42, True]\n\n\n\ncrazy_list[3][0]  # Zugriff auf das erste Element der Liste [42, True]\n\n42\n\n\nEin besonderer Datentyp, den wir nicht in vielen Programmiersprachen finden, ist complex für die Darstellung komplexer Zahlen. Dabei stellt j die imaginäre Einheit dar:\n\ntype(1+2j)  # komplexe Zahl mit Realteil 1 und Imaginärteil 2\n\ncomplex\n\n\n\nprint(\"Das Quadrat von j ist: \",(1j)**2) \n\nDas Quadrat von j ist:  (-1+0j)\n\n\nDie letzte Ausgabe sieht auf den ersten Blick vielleicht etwas kryptisch aus, aber belegt, dass j die Wurzel aus -1 ist. Es ist nun besonders einfach mit komplexen Zahlen zu rechnen:\n\n(1+2j)*(-2+4j)  # rechnen mit komplexen Zahlen\n\n(-10+0j)\n\n\n\nÜbung: Recherchieren Sie zum Datentyp dict und legen Sie ein Dictionary aus Namen und Telefonnummern an.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datentypen und ihre Repräsentation</span>"
    ]
  },
  {
    "objectID": "notebooks/3-datatypes.html#instanzen-und-referenzen",
    "href": "notebooks/3-datatypes.html#instanzen-und-referenzen",
    "title": "5  Datentypen und ihre Repräsentation",
    "section": "5.2 Instanzen und Referenzen",
    "text": "5.2 Instanzen und Referenzen\nWir wollen jetzt verstehen, wie Daten gespeichert werden und was eine Variable genau ist. Dieser Absatz erscheint beim ersten Lesen womöglich etwas theoretisch, sein Verständnis hilft aber später enorm bei der Vermeidung vieler Missverständnisse und Fehler.\n\nEin vereinfachtes Speichermodell\nAn dieser Stelle benötigen wir ein einfaches Modell eines Speichers: Stellen wir uns vor, unser Programm hat Zugriff auf eine Reihe von Speicherstellen, in denen es Daten ablegen kann. Die kleinste Informationsmenge, die wir speichern können, ist ein Bit, das entweder den Wert 0 oder 1 annehmen kann. Um jedoch komplexere Informationen zu speichern, arbeiten wir in der Regel mit Gruppen aus 8 Bits, die wir als Byte bezeichnen. In unserem Modell stellen wir uns den Speicher als eine große Zahl freier Bytes vor, die alle hintereinander aufgereiht sind. Jedes Byte kann über eine eindeutige Adresse identifiziert werden (die Adressen sind in der C-Programmierung wichtig, nicht so sehr in Python). Das einfache Speichermodell ist in Abbildung 5.1 skizziert.\n\n\n\n\n\n\nAbbildung 5.1: Vereinfachtes Speichermodell\n\n\n\n\n\nInstanzen\nWenn wir einen bestimmten Wert speichern wollen (z.B. eine Zahl oder einen Text), brauchen wir in der Regel mehr als eine Speicherstelle. Die genaue Größe hängt davon ab, welcher Datentyp gespeichert wird und wie viel Information dieser enthält (ein einzelner Buchstabe ist sicherlich weniger Information als ein ganzer Satz). Daten werden also je nach Datentyp und Informationsgehalt in unterschiedlich vielen Speicherzellen gespeichert. Um die Verwaltung des Speichers kümmert sich der Python-Interpreter, er ermittelt also auch wie viele Zellen benötigt werden und speichert die Daten. Nun aber Schritt für Schritt: Was passiert, wenn wir folgende einfache Zeile programmieren?\n\ntext = \"Hi\"\n\nZunächst ermittelt der Interpreter den Speicherbedarf für den String-Wert \"Hi\", weist ihm einen freien Platz im Speicher zu und speichert dort die Daten ab (natürlich nicht in menschenlesbarer Form, sondern binär kodiert, wie wir später noch genauer erklären werden). Das Ergebnis nennt man eine Instanz: Eine Instanz ist ein konkretes Datenobjekt im Speicher, das nach den Vorgaben eines bestimmten Datentyps erzeugt und gespeichert wurde. Es kann sich dabei auch um eine Zahl handeln, z.B. -5.25. Wichtig an dieser Stelle: Zu einer Instanz gehört ein bestimmter Datentyp!\nBisher haben wir nur die rechte Seite der Zuweisung betrachtet: Das Literal erzeugt eine Instanz im Speicher. Was bewirkt die linke Seite der Zuweisung?\n\n\nReferenzen\nWenn wir den String \"Hi\" keiner Variable zugeordnet hätten, wäre die erzeugte Instanz für uns nicht mehr greifbar. Sie würde nutzlos im Speicher rumliegen! In Python würde ein Aufräummechanismus (der sog. Garbage Collector) diese Instanz wieder aus dem Speicher löschen. Glücklicherweise haben wir den Wert jedoch der Variable mit dem Namen text zugewiesen. Die Variable text referenziert die Instanz im Speicher, wodurch wir mit der Instanz arbeiten können. Eine Variable ist also eine bloße Referenz und von der eigentlichen Instanz (den “echten Daten”) zu unterscheiden. Referenzen können Sie sich wie Hinweisschilder oder Wegweiser vorstellen: Sie zeigen auf die Instanz, sind aber nicht selbst die Instanz.\nIn Abbildung 5.2 wird der Unterschied zwischen Instanzen und Referenzen bildlich dargestellt.\n\n\n\n\n\n\nAbbildung 5.2: Referenzen und Instanzen. Instanzen sind konkrete Datenobjekte im Speicher. Variablen verweisen auf diese Instanzen und werden deshalb auch Referenzen genannt. Im gezeigten Beispiel liegen eine String-Instanz und eine Float-Instanz im Speicher und werden jeweils von einer Variable referenziert. Eine Instanz kann aber auch mehrfach oder gar nicht referenziert werden (in letzterem Fall wird sie aber vom Garbage Collector wieder aufgeräumt)\n\n\n\n\n\n\n\n\n\nStrenggenommen ist es nicht korrekt, zu sagen, eine Variable hätte einen bestimmten Datentyp. Der Datentyp gehört immer zur referenzierten Instanz. Wenn wir in einer anderen Zeile text = 123 schreiben, zeigt die Variable text plötzlich auf eine Instanz vom Typ int. Dennoch ist es im alltäglichen Sprachgebrauch üblich zu sagen, “Die Variable text hat den Typ string.” Merken Sie sich jedoch, dass diese Formulierung ungenau ist!\n\n\n\n\n\nIdentität einer Instanz\nJede Instanz besitzt in Python eine eindeutige Identität, die durch die Funtkion id() abgefragt werden kann und wie ein Fingerabdruck der Instanz verstanden werden kann:\n\nid(text)  # mit id() erhält man die Identität\n\n2122758446064\n\n\nHier wurde die eindeutige ID der Instanz ausgegeben, die von text referenziert wird. Wenn wir die Variable auf eine andere Instanz zeigen lassen, ändert sich auch die Identität:\n\ntext = \"Guten Tag\"\nid(text)\n\n2122752622320\n\n\n\n\n\n\n\n\nKurze Zusammenfassung\n\n\n\nEine Instanz ist ein konkretes Objekt im Speicher. Es hat drei Merkmale: Eine eindeutige Identität, einen Datentyp und einen Wert. Eine Variable ist ein symbolischer Name, der eine Instanz referenziert (man sagt auch: auf eine Instanz zeigt).\n\n\n\n\nExkurs: Seiteneffekte - Wenn mehrere Referenzen auf dieselbe Instanz zeigen.\nEs kann vorkommen, dass mehrere Variablen auf ein und dieselbe Instanz zeigen und dadurch unerwartete Effekte passieren. Dazu betrachten wir zunächst ein Beispiel ohne Seiteneffekte und danach ein zweites mit solchen Effekten.\nErstes Beispiel (keine Seiteneffekte):\n\na = 12\nb = a  # a wird b zugewiesen\nprint(id(a), id(b))\n\n140715933117208 140715933117208\n\n\nAn dieser Stelle erhalten wir identische Identitäten, d.h. a und b referenzieren dieselbe Instanz! Python hat festgestellt, dass es keinen Grund gibt, eine zweite Instanz anzulegen und verhält sich ökonomisch (Speicher sparend und Laufzeit sparend, denn das Anlegen von Instanzen kostet Zeit). Wir führen unser Beispiel fort:\n\nb += 10  # b wird verändert\nprint(id(a),id(b))\n\n140715933117208 140715933117528\n\n\nWie wir sehen, zeigt b jetzt auf eine andere Instanz (eine mit Wert 22), während a immer noch unverändert auf die ursprüngliche verweist. In diesem Beispiel ist nichts unerwartetes geschehen. Damit wir nicht immer die Identitäten mühsam miteinander vergleichen müssen, können wir auch den Operator is verwenden:\n\na is b  # vergleicht die Identitäten der referenzierten Instanzen\n# True heißt: a und b zeigen auf dieselbe Instanz\n# False heißt: a und b zeigen auf unterschiedliche Instanzen\n\nFalse\n\n\nZweites Beispiel (mit Seiteneffekten):\nWir wiederholen das Experiment von oben, diesmal aber mit einem anderen Datentyp (einer Liste):\n\nmy_shopping_list = ['apples', 'oranges', 'paper']\nyour_shopping_list = my_shopping_list\nprint(id(my_shopping_list), id(your_shopping_list))\n\n3130323362688 3130323362688\n\n\nBis hierin verhalten sich die beiden Beispiele gleich. Jetzt manipulieren wir eine der Variablen:\n\nyour_shopping_list.append('shoes')\nprint(id(my_shopping_list), id(your_shopping_list))\n\n3130323362688 3130323362688\n\n\nDie Identitäten sind immer noch gleich! Das bestätigt auch der is-Operator:\n\nyour_shopping_list is my_shopping_list\n\nTrue\n\n\nAber was bedeutet das für die ursprüngliche Liste?\n\nprint(my_shopping_list)\n\n['apples', 'oranges', 'paper', 'shoes']\n\n\nDie ursprüngliche Liste wurde verändert, obwohl wir die Variable my_shopping_list gar nicht angefasst haben! Man spricht in diesem Zusammenhang von einem Seiteneffekt.\nSpäter gehen wir genauer auf dieses Phänomen ein (es tritt nur bei sog. mutable Datentypen auf, zu denen die Liste gehört: Instanzen dieser Datentypen sind veränderlich, während bei immutable Datentypen keine nachträgliche Veränderung von Instanzen erlaubt ist). An dieser Stelle soll es nur illustrieren, warum das Verständnis von Instanzen und Referenzen so wichtig für angehende Programmiererinnen und Programmierer ist. Vielleicht haben Sie auch bereits von Pointern in der Sprache C gehört: Obwohl sich das Konzept von den hier vorgestellten Referenzen unterscheidet, besteht dieselbe Gefahr: Mehrere Pointer können auf dasselbe Objekt zeigen; eine Code-Stelle kann Änderungen bewirken, mit denen man an einer anderen Stelle gar nicht rechnet.\n\n\n\n\n\n\nNicht verwechseln: Gleichheit und Identität\n\n\n\nx == y (Gleichheit) prüft, ob die Instanzen von x und y denselben Wert haben.\nx is y (Identität) prüft, ob x und y auf dieselbe Instanz zeigen. In diesem Fall gilt selbstverständlich auch x == y, die Umkehrung ist falsch.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datentypen und ihre Repräsentation</span>"
    ]
  },
  {
    "objectID": "notebooks/3-datatypes.html#binäre-darstellung-von-daten",
    "href": "notebooks/3-datatypes.html#binäre-darstellung-von-daten",
    "title": "5  Datentypen und ihre Repräsentation",
    "section": "5.3 Binäre Darstellung von Daten",
    "text": "5.3 Binäre Darstellung von Daten\nWir wissen nun, dass im Speicher eines Computers Instanzen der benötigten Daten erzeugt werden und wir über Referenzen auf diese zugreifen können. Wie aber sieht so eine Instanz im Speicher genau aus? Computer arbeiten auf einer fundamentalen Ebene mit binären Daten, also Zahlen, die nur aus den Ziffern 0 und 1 bestehen. Diese beiden Zustände repräsentieren die grundlegenden Bits (Binary Digits), mit denen alle Arten von Daten – wie Zahlen, Texte oder Bilder – gespeichert und verarbeitet werden. Mit anderen Worten: Eine Zahl (z.B. \\(-5.25\\)) oder ein Wort (z.B. “Apfel”) muss durch eine Transformation, genannt Kodierung, als Binärzahl dargestellt werden können (und umgekehrt). Die Art der Kodierung hängt davon ab, welcher Datentyp dargestellt werden soll.\n\n\n\n\n\n\nEinführung ins Binärsystem\n\n\n\nDas Binärsystem (oder Dualsystem) ist ein Zahlensystem zur Basis 2, das nur zwei Ziffern verwendet: 0 und 1. Es ist die Grundlage aller digitalen Systeme, da Computer mit diesen beiden Zuständen (z.B. Strom an/aus) arbeiten. Die natürlichen Zahlen in aufsteigender Reihenfolge sehen binär so aus: 0, 1, 10, 11, 100, 101, usw. Zur Abgrenzung von Dezimalzahlen verwendet man gelegentlich eine tiefgestellte 2 (z.B. \\((100)_2\\)) oder das Präfix \\(0\\text{b}\\) (z.B. \\(0\\text{b}100\\)).\n\nUmwandlung von Binär- nach Dezimalsystem\nUm eine Binärzahl in eine Dezimalzahl umzuwandeln, multipliziert man jede Ziffer mit \\(2^{\\text{Position}}\\), beginnend von rechts mit der Position 0, und addiert die Ergebnisse.\nBeispiel: Binärzahl \\((1011)_2 = 1\\cdot 2^3+0\\cdot 2^2 + 1\\cdot 2^1+1\\cdot 2^0=8+0+2+1=11\\) (Dezimalzahl).\n\n\nUmwandlung von Dezimal- nach Binärsystem\nEine Dezimalzahl wird durch wiederholtes Teilen durch 2 in eine Binärzahl umgewandelt. Die Reste ergeben die Binärzahl (von unten nach oben lesen).\nBeispiel: Die Dezimalzahl 13 soll binär dargestellt werden. \n\\(13 : 2 = 6, \\text{ Rest: } 1\\) \\(6 : 2 = 3, \\text{ Rest: } 0\\) \\(3 : 2 = 1, \\text{ Rest: } 1\\) \\(1 : 2 = 0, \\text{ Rest: } 1\\)\nBinärzahl (Reste von unten nach oben lesen): \\(1101\\)\n\n\nStellen hinter dem Komma in binärer Schreibweise\nBei Kommazahlen entsprechen die Stellen hinter dem Komma negativen Exponenten. Wir kennen das vom Dezimalsystem: \\(0.243 = 2\\cdot 10^{-1} + 4\\cdot 10^{-2}+ 3\\cdot 10^{-3}.\\)\nAnalog im Binärsystem: \\((0.101)_2 = 1 \\cdot 2^{-1}+0\\cdot 2^{-2} + 1\\cdot 2^{-3} = 0.625\\) als Dezimalzahl.\n\n\n\n\nBinäre Darstellung von Ganzzahlen\nGanzzahlen (Integer) werden direkt im Binärsystem gespeichert. Dabei gibt es eine Unterscheidung:\n\nPositive Ganzzahlen: Sie werden als reine Binärzahlen dargestellt, z. B. ist die Dezimalzahl 5 im Binärsystem 101.\nNegative Ganzzahlen: Hier gibt es verschiedene Ansätze. In der Regel wird das höchste Bit als Vorzeichenbit verwendet, das angibt, ob die Zahl positiv (Vorzeichenbit = 0) oder negativ (Vorzeichenbit = 1) ist. Dann muss nur noch der Betrag der Zahl kodiert werden, wofür es wiederum verschiedene Methoden gibt, auf die wir im Rahmen dieser Einführung nicht näher eingehen (für Interessierte empfehlen wir: Zweierkomplement.)\n\nInteger können in Python mit dem Befehl bin() ganz einfach ins Binärsystem umgewandelt werden:\n\nprint(\"Dezimal:\", 11, \"Binär:\", bin(11))\nprint(\"Dezimal:\", 13, \"Binär:\", bin(13))\nprint(\"Dezimal:\", 423, \"Binär:\", bin(423))\n\nDezimal: 11 Binär: 0b1011\nDezimal: 13 Binär: 0b1101\nDezimal: 423 Binär: 0b110100111\n\n\nUmgekehrt geht es sogar noch viel einfacher, wie die folgenden Beispiele zeigen:\n\n# ein binäres Litera 0b... wird automatisch umgewandelt: \nprint(\"Binär:\", \"0b1011\", \"Dezimal:\", 0b1011) \nprint(\"Binär:\", \"0b1101\", \"Dezimal:\", 0b1101)\nprint(\"Binär:\", \"0b110100111\", \"Dezimal\", 0b110100111)\n\nBinär: 0b1011 Dezimal: 11\nBinär: 0b1101 Dezimal: 13\nBinär: 0b110100111 Dezimal 423\n\n\n\n\nBinäre Darstellung von Gleitkommazahlen\nGleitkommazahlen (wie 3.14 oder -0.001) werden durch den IEEE 754-Standard dargestellt, der folgende Struktur nutzt:\n\nVorzeichen (1 Bit): Gibt an, ob die Zahl positiv (Vorzeichenbit = 0) oder negativ (Vorzeichenbit = 1) ist.\nExponent: Bestimmt die Skalierung der Zahl.\nMantisse: Speichert die signifikanten Stellen der Zahl.\n\n\n\n\n\n\n\nBeispiel Gleitkommazahl-Darstellung\n\n\n\nDie Zahl -5.25 soll binär mit insgesamt 32 Bits dargestellt werden. Die Aufteilung der Bits soll so erfolgen: 1 Bit für das Vorzeichen, 8 Bits für den Exponenten und 23 Bits für die Mantisse.\nDas Vorzeichenbit ist offensichtlich 1 (für negativ), nun müssen wir noch Exponent und Mantisse kodieren. Dazu drücken wir den Betrag (das Vorzeichen interessiert uns nicht mehr) binär und wissenschaftlich notiert aus: \\(5.25 = (101.01)_2 = (\\textcolor{blue}{1.0101})_2 \\cdot 2^{\\textcolor{green}2}\\).\nDaraus ergibt sich:\n\nDer \\(\\textcolor{green}{\\text{Exponent}}\\) ist 2, allerdings noch im Zehnersystem ausgedrückt. Mit 8 Bits binär dargestellt wäre er \\((00000010)_2\\). Man verwendet aber noch einen Trick, um negative Exponenten nicht wieder mit einem Vorzeichenbit unterscheiden zu müssen, und addiert 127 zum eigentlichen Exponenten: Unser Exponent 2 wird also folgendermaßen kodiert: \\(127+2=129=(10000001)_2\\).\nDie \\(\\textcolor{blue}{\\text{Mantisse}}\\) im Binärsystem ist 1.0101. Beim Kodieren wird die führende 1 weggelassen, weil sie immer da ist – ein Trick zur Speicheroptimierung. Die Stellen hinter dem Komma werden in 23 Bits abgelegt: \\((01010000000000000000000)_2\\)\n\nDie komplette Kodierung lautet: \\(1\\ 10000001\\ 01010000000000000000000\\).\n\n\nGleitkommazahlen bieten durch diese Struktur eine große Reichweite und Präzision, allerdings entstehen dabei gelegentlich Rundungsfehler, da nicht alle Dezimalzahlen im Binärsystem mit endlich vielen Stellen exakt darstellbar sind. Ein wichtiger Merksatz lautet an dieser Stelle bereits: Vergleichen Sie niemals zwei Gleitkommazahlen auf exakte Gleichheit, sondern verwenden Sie immer eine kleine Toleranz für Rundungsfehler.\n\n\nBinäre Darstellung von Strings\nStrings bestehen aus einer Folge von Zeichen, die jeweils durch Zahlencodes repräsentiert werden:\n\nASCII: Jedes Zeichen wird durch eine 7-Bit-Zahl dargestellt (z. B. A = 65 = 0b01000001). Der Code deckt eine Auswahl von druckbaren Zeichen (lateinisches Alphabet in Groß- und Kleinschreibung, unsere 10 Ziffern, Interpunktions- und Sonderzeichen) und nicht-druckbare Zeichen (z.B. Tabulator oder Protokollzeichen für Übertragungsende oder Bestätigung) ab. Für englische Texte ist der Zeichensatz völlig ausreichend, er beinhaltet aber weder deutsche Umlaute (‘ä’,‘ü’,etc.), noch chinesische Schriftzeichen oder Emojis - um nur einige Beispiele von Zeichen zu nennen, die über ASCII hinausgehen. Aus diesem Grund gibt es erweiterte Zeichensätze. Durch Erweiterung um ein achtes Bit entstanden verschiedene Zeichensätze für unterschiedliche Sprachen (z.B. Latin-1 für westeuropäische Sprachen, inkl. der deutschen Umlaute).\nUnicode (UTF-8): Unicode ist ein universeller Zeichensatz, der mehrere Sprachen mit nur einem Zeichensatz umfassen soll. Es gibt mehrere Kodierungen für Unicode, von denen UTF-8 (UTF = Unicode Transformation Format) die am weitesten verbreite Variante darstellt. UTF-8 kodiert Zeichen mit variabler Byte-Anzahl: Dabei wird ein Unicodezeichen in 1 bis 4 Bytes kodiert. Die Codewerte 0 bis 127 entsprechen dem ASCII-Zeichensatz und werden in einem einzigen Byte kodiert, wobei das höchstwertige Bit stets 0 ist. Mithilfe des achten Bits kann ein längeres Unicode-Zeichen eingeleitet werden, das sich auf 2, 3 oder 4 Byte erstreckt. Beispiele: A → 01000001 (1 Byte), 😊 → 11110000 10011111 10011000 10000010 (4 Bytes).\n\nAbschließend stellen wir unser früheres Beispiel für Instanzen und Referenzen noch einmal dar, diesmal aber mit binär kodierten Werten (Abbildung 5.3).\n\n\n\n\n\n\nAbbildung 5.3: Instanzen und Referenzen revisited. Diesmal mit binär kodierten Werten.\n\n\n\nNoch ein paar Bemerkungen zum Speicherbedarf:\n\nIn C liegen im Speicher nur die rohen Daten, daher benötigt ein Float mit der oben dargestellten Kodierung tatsächlich nur vier Bytes odder ein ASCII-Zeichen nur ein Byte.\nPython speichert viel mehr ab: Zu jedem Wert werden Metadaten, wie Datentyp, Identität, Referenz-Zähler, etc. abgespeichert. Außerdem verwendet Python eigene Optimierungen, z.B. im Umgang mit Strings oder kleinen Integern. Daher stimmt die Größe einer Instanz nicht mit der Größe der “Rohdaten” überein.\nPython passt den Speicherbedarf von Integern automatisch an die benötigte Informationsmenge an, so werden für eine sehr große Ganzzahl automatisch mehr Bytes verwendet, als für eine kleine Ganzzahl. In C macht das niemand für Sie: Ein Datentyp stellt eine bestimmte Zahl an Bytes zur Verfügung, reicht diese nicht aus, müssen Sie selbst einen größeren Datentyp verwenden!\nMit der Funktion getsizeof() aus der Bibliothek sys können Sie die Zahl der Bytes abfragen. Beispiel:\n\n\nimport sys\nsys.getsizeof(\"42\")  # Antwort: Größe in Bytes\n\n51",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datentypen und ihre Repräsentation</span>"
    ]
  },
  {
    "objectID": "notebooks/3-datatypes.html#casting-typumwandlung",
    "href": "notebooks/3-datatypes.html#casting-typumwandlung",
    "title": "5  Datentypen und ihre Repräsentation",
    "section": "5.4 Casting (Typumwandlung)",
    "text": "5.4 Casting (Typumwandlung)\nCasting oder Typumwandlung bezeichnet das Konvertieren eines Wertes von einem Datentyp in einen anderen. Dies ist sowohl in statisch als auch dynamisch typisierten Sprachen nützlich, um unterschiedliche Datentypen zu kombinieren oder explizite Anforderungen zu erfüllen. Es gibt dabei implizites Casting durch die Programmiersprache und explizites Casting durch den Programmierer oder die Programmiererin.\n\nImplizites Casting\nDie Programmiersprache übernimmt die Typumwandlung automatisch bei kompatiblen Typen (z.B. Integer zu Float). Im folgenden Beispiel wird eine Integer-Zahl zu einer Float gecastet, um eine Summe zu bilden (das Ergebnis ist wieder ein Float):\n\nint_number = 4\nfloat_number = 3.2\nresult = int_number + float_number\ntype(result)\n\nfloat\n\n\nEin zweites Beispiel demonstriert das implizite Casting von Wahrheitswerten zu Integern:\n\nnumber = 11\nboolean = True\nresult = number + boolean  # implizites Casting von bool zu int\nprint(\"Result: \", result)\n\nResult:  12\n\n\n\n\n\n\n\n\nVorsicht\n\n\n\nUnbeabsichtigtes implizites Casting kann zu unerwarteten Fehlern führen!\nIn C kompiliert beispielsweise folgender Code:\nfloat x = 3.99;\nint y = x;\nAllerdings ist der Wert von y nicht 3.99 und auch nicht 4, sondern 3. Beim impliziten Casting von float nach int gehen alle Nachkommastellen verloren!\n\n\nHinweis: Python ist strenger beim impliziten Casting und erlaubt es oft nicht, damit sich keine ungewollten Effekte einschleichen. Eine Ausnahme stellen implizite Castings nach bool bei Bedingungen von Verzweigungen und Schleifen dar (siehe nächstes Kapitel). Hier wird alles, was ungleich 0 bzw. nicht-leer ist, implizit als True interpretiert. Im Umkehrschluss: 0 oder leer (z.B. ein leerer String) bedeutet False.\n\n\nExplizites Casting\nBeim expliziten Casting fordern wir beim Programmieren die Typumwandlung ausdrücklich an. Das ist z.B. dann erforderlich, wenn die Programmiersprache implizites Casting an einer Stelle nicht unterstützt, wir die Umwandlung aber bewusst durchführen wollen. Python bietet hierfür intuitive Funktionen an, die nach dem gewünschten Zieltyp benannt sind (float(), int(), str(), bool()). Diese Funktionen übernehmen einen Input-Wert, versuchen diesen in den gewünschten Zieltyp umzuwandeln und geben das gecastete Ergebnis zurück. Der zurückgegebene Wert kann z.B. wieder einer Variable zugewiesen werden.\nBeispiele:\n\ntext = \"Meine Glückszahl ist \" + str(11) # Int -&gt; Str\nprint(text)\nresult = \"Das Messergebnis beträgt \" + str(5.4e-2) + \" A.\"\nprint(result)\n\nMeine Glückszahl ist 11\nDas Messergebnis beträgt 0.054 A.\n\n\n\npi = 3.14\npi = int(pi)  # Float -&gt; Int\nprint(pi)  # alle Nachkommastellen gingen verloren!\n\n3\n\n\n\nnumber = 123\ncondition = bool(123)  # Int -&gt; Bool\nprint(condition)\n\nTrue\n\n\n\ncondition = False\nnumber = int(condition)  # Casting Bool -&gt; Int\nprint(number)\n\n0\n\n\n\ncondition = False\n\"The condition is \" + str(condition)  # Bool -&gt; String\n\n'The condition is False'\n\n\nWir haben bereits die input-Funktion kennengelernt und darauf hingewiesen, dass sie stets Strings zurückgibt. Wenn man aber mit einer User-Eingabe rechnen möchte, muss diese zunächst in einen Zahlentyp umgewandelt werden. Hierzu folgende Beispiele:\n\nage = int(input(\"Wie alt sind Sie? \"))  # Casting: str -&gt; int\nage += 10  # wäre mit str nicht möglich!\nprint(f\"In 10 Jahren sind Sie {age} Jahre alt.\")\n\nWie alt sind Sie?  22\n\n\nIn 10 Jahren sind Sie 32 Jahre alt.\n\n\n\nwidth = float(input(\"Breite: \"))  # Casting: str -&gt; float\nheight = float(input(\"Höhe: \"))  # Casting: str -&gt; float\narea = width * height  # wäre mit str nicht möglich\nprint(\"Fläche: \", area)\n\nBreite:  12.4\nHöhe:  7.8\n\n\nFläche:  96.72\n\n\nAber auch explizites Casting ist nicht in jedem Fall möglich und kann zu Fehlern führen. Z.B. weiß der Python-Interpreter nicht, wie er die folgenden Castings durchführen soll:\n\nfloat(\"Apfel\")  # Fehler! Wie soll \"Apfel\" als float interpretiert werden?\nint(\"Haus\")  # Fehler!\nint([1, 2, 3, 1.2]) # Fehler! Wie soll list -&gt; int gecastet werden?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datentypen und ihre Repräsentation</span>"
    ]
  },
  {
    "objectID": "notebooks/4-controls.html",
    "href": "notebooks/4-controls.html",
    "title": "6  Kontrollstrukturen",
    "section": "",
    "text": "6.1 Verzweigungen\nIn der Programmierung sind Kontrollstrukturen essenziell, um den Ablauf eines Programms zu steuern. Sie ermöglichen es, Entscheidungen zu treffen, Wiederholungen durchzuführen und den Programmfluss gezielt zu lenken. Ohne sie würden Programme einfach nur von oben nach unten ausgeführt werden, ohne auf Eingaben oder Bedingungen zu reagieren.\nWir unterscheiden zwischen zwei grundsätzlichen Arten von Kontrollstrukturen: Verzweigungen und Schleifen.\nVerzweigungen oder bedingte Anweisungen sind nichts anderes als Fallunterscheidungen: “Wenn eine bestimmte Bedingungen erfüllt ist, tue dies, andernfalls tue das.” In den meisten Programmiersprachen, wird dies durch eine if-Anweisungen realisiert (die genaue Syntax unterscheidet sich von Sprache zu Sprache). Das folgende Codebeispiel zeigt, wie es in Python funktioniert:\nnumber = 42\n\nif number &gt; 0:\n    print(\"Die Zahl ist positiv!\")\n\nDie Zahl ist positiv!\nIn diesem einfachen Beispiel, wird die Bedingung number &gt; 0 geprüft. Ist die Bedingung erfüllt, werden die eingerückten Anweisungen ausgeführt, in diesem Beispiel der print-Befehl.\nDie Funktionsweise einer if-Anweisung lässt sich mit einem Flussdiagramm (Abbildung 6.1) anschaulich darstellen.\nWichtig ist die korrekte Syntax: Die Anweisung wird mit dem Schlüsselwort if eingeleitet, gefolgt von der Bedingung und einem Doppelpunkt. Alle Anweisungen, die bei erfüllter Bedingung ausgeführt werden sollen, müssen darunter eingerückt sein. Wir betrachten ein zweites Beispiel:\nmax_load = 5000  # Maximale Belastung in Newton\ncurrent_load = float(input(\"Belastung in Newton: \"))  # z.B. ein Messergebnis\n\nif current_load &gt; max_load:\n    print(\"Warnung: Belastung überschritten!\")\n    factor = (current_load - max_load) / max_load\n    print(\"Maximale Belastung um \", round(100*factor,2),\"% überschritten!\")\n\nBelastung in Newton:  5200\n\n\nWarnung: Belastung überschritten!\nMaximale Belastung um  4.0 % überschritten!\nAktuell beschränken sich unsere Beispiele zu Zwecken der Illustration auf simple Ausgaben, aber natürlich gibt es keine Grenzen für die Komplexität, die in einem if-Block ausgeführt werden kann.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Kontrollstrukturen</span>"
    ]
  },
  {
    "objectID": "notebooks/4-controls.html#verzweigungen",
    "href": "notebooks/4-controls.html#verzweigungen",
    "title": "6  Kontrollstrukturen",
    "section": "",
    "text": "Abbildung 6.1: Flussdiagramm zur if-Anweisung\n\n\n\n\n\n\n\nVerzweigungen mit if und else\nIn den meisten Fällen verwendet man erweiterte Varianten der if-Anweisung. Zum Beispiel möchte man auch bestimmte Anweisungen ausführen, falls die Bedingung nicht erfüllt ist. Dafür ergänzt man einen else-Block:\n\nmax_load = 5000  # Maximale Belastung in Newton\ncurrent_load = float(input(\"Belastung in Newton: \"))\n\nif current_load &gt; max_load:\n    print(\"Warnung: Belastung überschritten!\")\n    factor = (current_load - max_load) / max_load\n    print(\"Maximale Belastung um \", round(100*factor,2),\"% überschritten!\")\nelse:\n    print(\"Alles im grünen Bereich!\")\n\nBelastung in Newton:  4600\n\n\nAlles im grünen Bereich!\n\n\nAuch diese Variante stellen wir im Flussdiagramm dar (Abbildung 6.2).\n\n\n\n\n\n\nAbbildung 6.2: Flussdiagramm zur Verzweigung mit if und else\n\n\n\nWir haben die Flussdiagramme bewusst so gezeichnet, dass die Einrückungen, wie sie von Python verlangt werden, auch im Diagramm ersichtlich sind: Die Schlüsselwörter if und else befinden sich auf selber Höhe, die jeweiligen Anweisungsblöcke sind darunter eingerückt.\n\n\nVerzweigungen mit if, elif und else\nSchließlich können wir unsere Verzweigung noch um sog. “else-if-Zweige” erweitern (das Python-Keyword heißt elif). Der Sinn davon: Wenn eine erste Bedingung falsch ist, möchte man vielleicht eine weitere Bedingung prüfen. Ist auch diese falsch, könnte noch eine dritte (vierte, fünfte, …) Bedingung interessant sein. In Worten: “Wenn Bedingung1 wahr ist, tue A, andernfalls prüfe Bedingung2. Ist Bedingung2 wahr, tue B, andernfalls prüfe Bedingung3 usw.” Wichtig zu verstehen ist, dass die Bedingungen nacheinander geprüft werden. Wenn eine frühere Bedingung bereits erfüllt ist, werden spätere Bedingungen gar nicht mehr angeschaut. Ein (optionales) finales else fängt den Fall auf, wenn keine Bedingung erfüllt ist. Das Flussdiagramm Abbildung 6.3 stellt die möglichen Fälle dar. Es können beliebig viele elif-Blöcke verwendet werden und das finale else kann auch weggelassen werden. Damit steht uns eine sehr flexible Möglichkeit für Verzweigungen zur Verfügung.\n\n\n\n\n\n\nAbbildung 6.3: Flussdiagramm zur Verzweigung mit if, elif und else\n\n\n\n\n# Grenzwerte für die Motorüberwachung (in °C)\nnormal_temp = 80  # normale Betriebstemperatur\nwarning_temp = 100  # Warnschwelle\ndanger_temp = 120  # Kritische Temperatur\n\n# Eingabe: Gemessene Motortemperatur\ntemperature = float(input(\"Aktuelle Motortemperatur in °C: \"))\n\n# Bewertung der Temperatur\nif temperature &lt; 0:\n    print(\"Fehler: Ungültige Temperatur. Bitte Sensor prüfen.\")\nelif temperature &lt;= normal_temp:\n    print(\"Temperatur im sicheren Bereich.\")\nelif temperature &lt;= warning_temp:\n    print(\"Achtung: Temperatur erhöht. Kühlung überprüfen.\")\nelif temperature &lt;= danger_temp:\n    print(\"Kritische Warnung! Motor überhitzt!\")\n    #hier folgt Code, der eine zusätzliche Kühlung aktiviert\nelse:\n    print(\"Motor wird abgeschaltet!\")\n    #hier folgt Code, der den Motor sofort abschaltet\n\nAktuelle Motortemperatur in °C:  110\n\n\nKritische Warnung! Motor überhitzt!\n\n\n\n\n\n\n\n\nDie if-Anweisung in anderen Programmiersprachen\n\n\n\nDie if-Anweisung ist ein universelles Werkzeug der Programmierung, das Sie in vielen Programmiersprachen wiederfinden werden. Beim Wechsel zu einer anderen Programmiersprache müssen Sie sich mit der jeweiligen Syntax vertraut machen. Python verpflichtet Sie z.B. zu Einrückungen, was in anderen Programmiersprachen eher unüblich ist (zu Zwecken der Übersichtlichkeit aber trotzdem gemacht wird). In C verwendet man geschweifte Klammern, um die Blöcke voneinander abzugrenzen. Hier ein Beispiel:\n    int temperatur = 25;\n\n    if (temperatur &gt; 30) {\n        printf(\"Es ist heiß!\\n\");\n    } else if (temperatur &gt; 20) {\n        printf(\"Angenehmes Wetter.\\n\");\n    } else {\n        printf(\"Es ist kühl.\\n\");\n    }\nSie erkennen sicherlich die große Ähnlichkeit zu dem, was Sie in Python kennengelernt haben, aber auch Unterschiede. Zum Beispiel schreibt man in C else if statt des verkürzten elif.\n\n\n\n\n\n\n\n\nConditional Expressions\n\n\n\nEine Besonderheit von Python sind die sog. Conditional Expressions. Sie sind eine elegante Art, Code kompakt darzustellen, wenn eine Zuweisung abhängig von einer if-Bedingung stattfinden soll. Dazu betrachten wir zunächst ein Beispiel als traditionelle Verzweigung mit if und else:\nif voltage &gt; 1000:\n    classification = \"Hochspannung\" \nelse:\n    classification = \"Niederspannung\"\nDie kompakte Schreibweise als Conditional Expression sieht dagegen so aus:\nclassification = (\"Hochspannung\" if voltage &gt; 1000 else \"Niederspannung\")\nDie Conditional Expression ist leicht zu verstehen, da sie wie ein englischer Satz gelesen werden kann. Die Klammern sind optional, unterstützen aber die Übersicht.\n\n\n\nÜbungen:\n\nImplementieren Sie einen Türsteher vor einem Club. Er fragt die Besucher nach dem Alter und reagiert entsprechend.\nSchreiben Sie Code, der den BMI einer Person berechnet und professionelles Feedback gibt.\nSchreiben Sie ein Programm, das einen primitiven Taschenrechner darstellt: Der Benutzer gibt zwei Zahlen ein, wählt eine Grundrechenart aus und erhält das gewünschte Ergebnis.\n\n\n\n\n\nZusammengesetzte Bedingungen mit and, or und not\nWir wiederholen: Mit den Operatoren and, or und not können komplexere logische Bedingungen aufgebaut werden. Die Bedeutung der Operatoren ist aus der Aussagenlogik bekannt:\n\nand: “A und B” ist wahr, wenn beide Bedingungen wahr sind.\nor: “A oder B” ist wahr, wenn mindestens eine der Bedingungen wahr ist.\nnot: “nicht A” kehrt den Wahrheitswert einer Bedingung um (wahr wird falsch und falsch wird wahr).\n\n\nage = 25\nhas_license = True\n\n# \"Führerschein und Fahrzeugpapiere bitte!\"\nif age &gt;= 18 and has_license:\n    print(\"Sie dürfen fahren!\")\nelse:\n    print(\"Steigen Sie mal bitte aus...\")\n\nSie dürfen fahren!\n\n\nBei der Verknüpfung von mehr als zwei Bedingungen empfiehlt sich die Verwendung von Klammern. Ohne Klammern gelten die Prioritätsregeln: * not hat die höchste Priorität. Es wird zuerst ausgewertet. * and hat eine mittlere Priorität. Es wird vor or ausgewertet. * or hat die niedrigste Priorität.\nIm folgenden Beispiel bräuchte man die Klammern nicht, aber sie unterstützen die Lesbarkeit und beugen Missverständnissen vor:\n\ntemperature = 25\nis_sunny = True\nis_holiday = False\n\nif (temperature &gt; 20 and is_sunny) or is_holiday:\n    print(\"Ich bin happy!\")\nelse:\n    print(\"Ein Tag wie jeder andere.\")\n\nIch bin happy!\n\n\nIm folgenden Beispiel wird not als erstes ausgewertet:\n\nis_guest = False\nis_admin = False\ndata_updated = True\n\nif not is_guest and (is_admin or data_updated):\n    print(\"Zugriff gewährt!\")\nelse:\n    print(\"Zugriff verweigert!\")\n\nZugriff gewährt!\n\n\nZugriff wird hier nur gewährt, wenn es sich nicht um einen Gast handelt. Darüber hinaus muss es ein Admin oder ein User mit aktualisierten Daten sein.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Kontrollstrukturen</span>"
    ]
  },
  {
    "objectID": "notebooks/4-controls.html#schleifen",
    "href": "notebooks/4-controls.html#schleifen",
    "title": "6  Kontrollstrukturen",
    "section": "6.2 Schleifen",
    "text": "6.2 Schleifen\nMit Schleifen können wir Anweisungen wiederholen, ohne sie erneut hinschreiben zu müssen. Die Anweisungen, die wiederholt ausgeführt werden sollen, stehen in einem eingerückten Schleifenkörper (so wie die Anweisungen in if- oder else-Blöcken). In Python gibt es zwei grundlegende Schleifentypen, die es in ähnlicher Weise auch in vielen anderen Programmiersprachen gibt.\n\nWhile-Loop\nBei der while-Schleife (engl. while-loop) legen wir eine Bedingung fest. Nur, wenn diese Bedingung erfüllt ist, werden die Anweisungen im Schleifenkörper ausgeführt. Nach jedem Durchlauf wird die Bedingung erneut geprüft und der Schleifenkörper ggf. ein weiteres Mal durchlaufen. Sie ahnen vielleicht schon die Gefahr dieses Schleifentyps: Wenn die Bedingung immer wahr ist, kommt das Programm nie mehr aus der Schleife raus! Sie haben dann eine sog. Endlosschleife erschaffen, ein gefürchteter Schrecken in der Programmierung. Denken Sie daher gut über Ihre Schleifenbedingungen nach!\nDas geschilderte Verhalten können Sie auch im Flussdiagramm der while-Schleife nachvollziehen (Abbildung 6.4).\n\n\n\n\n\n\nAbbildung 6.4: Flussdiagramm zur while-Loop\n\n\n\nBetrachten wir ein Beispiel, an dem Sie Syntax und Funktionsweise der while-Schleife lernen können:\n\nwater_level = 0  # Startfüllstand in Liter\nmax_water_level = 80  # Kapazität des Wassertanks in Liter\nflow_rate = 10  # Befüllung pro Schritt in Liter\n\nwhile water_level &lt; max_water_level:\n    water_level += flow_rate\n    print(\"Wassertank wird befüllt... Aktueller Stand:\", water_level)\n\n\nprint(\"Der Tank ist voll! Befüllung gestoppt.\")\n\nWassertank wird befüllt... Aktueller Stand: 10\nWassertank wird befüllt... Aktueller Stand: 20\nWassertank wird befüllt... Aktueller Stand: 30\nWassertank wird befüllt... Aktueller Stand: 40\nWassertank wird befüllt... Aktueller Stand: 50\nWassertank wird befüllt... Aktueller Stand: 60\nWassertank wird befüllt... Aktueller Stand: 70\nWassertank wird befüllt... Aktueller Stand: 80\nDer Tank ist voll! Befüllung gestoppt.\n\n\n\n\nFor-Loop\nDie for-Schleife hat einen anderen Charakter als die while-Schleife: Sie wird verwendet, um eine Sequenz (z. B. eine Liste, eine Zeichenkette oder eine Zahlenreihe) Schritt für Schritt zu durchlaufen. Für jedes Element der Sequenz wird der Schleifenkörper abgearbeitet, bis schließlich das Ende der Sequenz erreicht ist und die Schleife verlassen wird.\nDie grundlegende Syntax sieht so aus:\nfor var in sequence:\n    # Codeblock, der für jedes Element der Sequenz ausgeführt wird.\n    # \n    # var ist beim ersten Druchlauf das erste Element,\n    # beim zweiten Durchlauf das zweite Element,\n    # ...\n    # beim letzten Durchlauf das letzte Element.\nBei einer for-Schleife wird beim ersten Eintritt in die Schleife das erste Element der Sequenz ausgewählt (Initialisierung). Nach jedem Durchlauf des Schleifenkörpers erfolgt automatisch der Übergang zum nächsten Element der Sequenz (Iteration), bis alle Elemente durchlaufen wurden. Das zugehörige Flussdiagramm (Abbildung 6.5) sieht daher etwas anders aus, als die bisherigen Beispiele.\n\n\n\n\n\n\nAbbildung 6.5: Flussdiagramm zur for-Loop\n\n\n\nAm besten wir betrachten ein paar Beispiele:\n\n# Wir buchstabieren ein Wort:\n# \"Apfel\" ist hierbei die Sequenz\nfor letter in \"Apfel\":  \n    print(letter)\n\nA\np\nf\ne\nl\n\n\n\n# Wir gehen eine Liste durch und prüfen eine Bedingung\nsensor_values = [12.4, 15.7, 19.3, 21.2, 13.5, 7.8, 23.2]\ncritical_threshold = 20.0\n\nfor value in sensor_values:\n    if value &gt; critical_threshold:\n        print(\"Kritischer Messwert gefunden:\", value, \"V\")\n\nKritischer Messwert gefunden: 21.2 V\nKritischer Messwert gefunden: 23.2 V\n\n\nEine häufige Anwendung von for-Schleifen sind sog. Zählschleifen, bei denen eine feste Anzahl an Wiederholungen vorgeben wird. Dies erreicht man in Python durch die Funktion range():\n\n# range(5) erzeugt die Sequenz 0 - 4\nfor i in range(5): \n    print(i)\n\n0\n1\n2\n3\n4\n\n\nBeachten Sie, dass die von range(n) erzeugte Sequenz bei 0 beginnt und n-1 endet. Die Buchstaben i und j werden gerne als Zählvariablen in Kombination mit range verwendet. Die range()-Funktion bietet verschiedene Optionen, um die erzeugte Sequenz zu beeinflussen. So können Sie neben dem End-Wert auch einen Start-Wert angeben:\n\n# range(3,10) erzeugt die Sequenz 3 - 9\nfor i in range(3, 10): \n    print(i)\n\n3\n4\n5\n6\n7\n8\n9\n\n\nUnd was macht der folgende Code?\n\nfor i in range(3, 10, 2):\n    print(i)\n\n3\n5\n7\n9\n\n\nWir fassen die drei Varianten von range() zusammen:\n\nrange(stop) Sequenz von 0 bis stop-1\nrange(start, stop) Sequenz von start bis stop-1\nrange(start, stop, step) Sequenz von start bis maximal stop-1 mit der Schrittweite step.\n\nIn der dritten Variante steht “bis maximal stop-1”, weil nicht mehr garantiert werden kann, dass stop-1 angenommen wird: Es wird jeweils step hinzuaddiert und damit könnte auch stop-1 übersprungen werden. Sobald der Zähler &gt;= stop ist, terminiert die Schleife.\nÜbrigens kann man mit range() auch rückwärts zählen:\n\nfor i in range(10, 0, -3):\n    print(i)\n\n10\n7\n4\n1\n\n\n\n\n\n\n\n\nFor-Schleifen in anderen Programmiersprachen\n\n\n\nIn den meisten anderen Programmiersprachen ähnelt die For-Schleife von vornherein eher einer Zählschleife. In C sieht das z.B. so aus:\nfor (int i = 0; i &lt; 10; i++) {\n    // Schleifenkörper für \n    // i von 0 bis 9\n}\nIn der runden Klammer erkennt man drei Anweisungen:\n\nint i = 0 initialisiert die Zählvariable i\ni &lt; 10 definiert die Bedingung, wie lange die Schleife ausgeführt werden soll\ni++ bedeutet, dass die Zählvariable nach jedem Durchgang um eins erhöht wird.\n\nDas Python-Analogon wäre also:\nfor i in range(10):\n\n\n\nÜbungen: Gegeben sei eine Liste mit Messwerten data=[0.2, -1.3, 2.7, 0.6, 9.9, 8.2].\n\nImplementieren Sie eine For-Loop, die die Summe aller Messwerte berechnet.\nSchreiben Sie Code, der den Durchschnitt aller Messwerte berechnet.\nSchreiben Sie Code, der das Maximum der Messwerte findet.\n\n\nLösung (alle drei Aufgaben in einem Code):\n\n\nCode\ndata = [0.2, -1.3, 2.7, 0.6, 9.9, 8.2]\nsum_result = 0  # Summe initialisieren mit Null\nmax_value = data[0]  # Maximum initialisieren mit erstem Element\n\nfor value in data:\n    sum_result += value  # aufaddieren    \n    if value &gt; max_value:  # Maximum suchen\n        max_value = value\n\n# Für den Durchschnitt brauchen wir noch\n# die Anzahl der Elemente. Diese erhält\n# man mit len(data):        \naverage = sum_result / len(data)  \n\nprint(\"Summe: \", sum_result,\"Durchschnitt: \", average, \"Maximum: \", max_value)\n    \n\n\n\n\nDen Schleifenfluss kontrollieren mit break und continue\n\nbreak - Schleife vorzeitig beenden\nSobald in einer Schleife das Keyword break verwendet wird, bricht die Schleife an Ort und Stelle ab. Das funktioniert sowohl in while- als auch in for-Schleifen. Betrachten Sie das folgende Ratespiel - können Sie den Nutzen von break nachvollziehen?\n\nimport random\nsecret_number = random.randint(0,100) #erzeugt eine Zufallszahl\n\nguess = -1  # guess wird auf -1 initialisiert\n\nwhile guess != secret_number:\n   \n    guess = int(input(\"Raten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): \"))\n    \n    if guess == -1:\n        print(\"Abbruch.\")\n        break  # Die Schleife wird abgebrochen\n    \n    # Falls das Spiel fortgesetzt wird, geben wir Tipps:\n    if secret_number &lt; guess:\n        print(\"Zu groß!\")\n    elif secret_number &gt; guess:\n        print(\"Zu klein!\")\n    else:\n        print(\"Gratulation!\")  # Geheime Zahl erraten!\n\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch):  34\n\n\nZu klein!\n\n\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch):  78\n\n\nZu klein!\n\n\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch):  89\n\n\nZu klein!\n\n\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch):  99\n\n\nZu groß!\n\n\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch):  91\n\n\nZu klein!\n\n\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch):  102\n\n\nZu groß!\n\n\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch):  -3\n\n\nZu klein!\n\n\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch):  -1\n\n\nAbbruch.\n\n\nEin Beispiel für break in einer for-Schleife:\n\nbag = [\"Schlüssel\", \"Handy\", \"Brille\", \"Geldbörse\", \"Stift\"]  # Dinge in der Tasche\nsearch_item = \"Geldbörse\"  # Der Gegenstand, den wir suchen\n\nfor item in bag:\n    print(\"Suche nach \", search_item, \" läuft. Aktueller Gegenstand: \", item)\n    \n    if item == search_item:\n        # Die Schleife wird abgebrochen, \n        # da der Gegenstand gefunden wurde:\n        print(search_item, \"gefunden!\")\n        break  \n\nSuche nach  Geldbörse  läuft. Aktueller Gegenstand:  Schlüssel\nSuche nach  Geldbörse  läuft. Aktueller Gegenstand:  Handy\nSuche nach  Geldbörse  läuft. Aktueller Gegenstand:  Brille\nSuche nach  Geldbörse  läuft. Aktueller Gegenstand:  Geldbörse\nGeldbörse gefunden!\n\n\n\n\ncontinue - Aktuellen Schleifendurchlauf vorzeitig abbrechen, weiter mit dem nächsten!\nDas Keyword continue bricht nur den aktuellen Schleifendurchlauf an Ort und Stelle ab, aber nicht die ganze Schleife. Es geht einfach direkt mit dem nächsten Durchlauf weiter. Wir erweitern das Ratespiel von oben durch ein continue bei ungültiger Eingabe:\n\nimport random\nsecret_number = random.randint(0,100)  # erzeugt eine Zufallszahl\nguess = -1\n\nwhile guess != secret_number:\n   \n    guess = int(input(\"Raten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): \"))\n    \n    if guess &gt; 100 or guess &lt; -1: \n        # Eingabe außerhalb gültiger Grenzen\n        print(\"Ungültig!\")\n        # Durchgang abbrechen und nächste Runde: \n        continue \n    \n    if guess == -1:\n        # Die Schleife wird abgebrochen\n        print(\"Abbruch.\")\n        break \n    \n    # Falls das Spiel fortgesetzt wird, geben wir Tipps:\n    if secret_number &lt; guess:\n        print(\"Zu groß!\")\n    elif secret_number &gt; guess:\n        print(\"Zu klein!\")\n    else:\n        print(\"Gratulation!\")  # Geheime Zahl erraten!\n\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): 102\nUngültig!\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): -3\nUngültig!\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): 23\nZu klein!\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): 54\nZu groß!\nRaten Sie die geheime Zahl zwischen 0 und 100 (-1 für Abbruch): -1\nAbbruch.\n\n\nAuch hierzu ein Beispiel mit for (es illustriert eine einfache Datenbereinigung):\n\nuser_inputs = [\"23\", \"abc\", \"45\", \"-1\", \"67\", \"150\", \"\", \"89\", \"0\", \"xyz\"]\ncleaned_data = []  # Liste für bereinigte Eingaben\n\nfor input_str in user_inputs:\n\n    # 1. Überspringe nicht-numerische Eingabe\n    if not input_str.isdigit():\n        continue\n\n    # 2. Wandle die Eingabe in eine Zahl um\n    input_number = int(input_str)  \n\n    # 3. Überspringe Werte außerhalb gültiger Grenzen\n    if input_number &lt; 10 or input_number &gt; 100:\n        continue\n\n    # Füge gültige Eingabe der Liste hinzu:\n    cleaned_data.append(input_number)  \n\nprint(\"Bereinigte Eingaben:\", cleaned_data)\n\nBereinigte Eingaben: [23, 45, 67, 89]\n\n\n\n\n\nVerschachtelte Schleifen\nVerschachtelte Schleifen, also Schleifen innerhalb anderer Schleifen, sind ein wesentliches Konstrukt in der Programmierung. Sie werden verwendet, um mehrdimensionale Strukturen (z. B. Matrizen, Tabellen, Raster) zu durchlaufen oder kombinatorische Probleme (z. B. Permutationen) zu lösen. Typische Anwendungen finden sich in der Datenanalyse, Bildbearbeitung oder Mathematik.\nPython erlaubt beliebig tiefe Schachtelungen von Schleifen. Jede innere Schleife wird bei jedem Durchlauf der äußeren Schleife vollständig ausgeführt. Das entspricht der ganz normalen Funktionsweise von Schleifen: Der Schleifenkörper wird für jede Iteration abgearbeitet, ganz egal, was drin steht (im Fall von verschachtelten Schleifen eine weitere Schleife).\n\nfor i in range(3):       # äußere Schleife\n    for j in range(2):   # innere Schleife\n        print(f\"i={i}, j={j}\")\n\ni=0, j=0\ni=0, j=1\ni=1, j=0\ni=1, j=1\ni=2, j=0\ni=2, j=1\n\n\nDie innere Schleife wird für jeden Wert der äußeren Schleife komplett durchlaufen (dadurch kommt es zu insgesamt 3 * 2 = 6 Aufrufen von print). Dieses Schema könnte zum Beispiel genutzt werden, um eine Tabelle, bestehend aus drei Zeilen (Index i) und zwei Spalten (Index j), einzulesen oder zu bearbeiten.\n\n\n\n\n\n\nVorsicht\n\n\n\nbreak und continue beziehen sich immer auf die innerste Schleife, in der sie stehen!\n\n\nBeispiele zu break und continue bei verschachtelten Schleifen:\n\nfor i in range(3):\n    for j in range(5):\n        if j == 2:\n            break  # verlässt nur die innere Schleife\n        print(f\"i={i}, j={j}\")\n\ni=0, j=0\ni=0, j=1\ni=1, j=0\ni=1, j=1\ni=2, j=0\ni=2, j=1\n\n\n\nfor i in range(3):\n    for j in range(3):\n        if j == 1:\n            continue  # überspringt j==1\n        print(f\"i={i}, j={j}\")\n\ni=0, j=0\ni=0, j=2\ni=1, j=0\ni=1, j=2\ni=2, j=0\ni=2, j=2\n\n\n\nÜbung: In eine Namensliste haben sich manche Namen doppelt eingeschlichen. Diese sollen mithilfe von verschachtelten Schleifen gefunden werden. Gewünschte Ausgabe: Doppelte Namen mit ihren Indizes. Sie können voraussetzen, dass kein Name häufiger als zweimal vorkommt! Testdaten: names = [\"Anna\", \"Chris\", \"Fabiola\", \"Clara\", \"Chris\", \"Ben\", \"Dora\", \"Ben\", \"Anna\"].\n\nTipp, falls Sie Schwierigkeiten mit den korrekten Schleifen haben:\n\n\nCode\nnames = [\"Anna\", \"Chris\", \"Fabiola\", \"Clara\", \"Chris\", \"Ben\", \"Dora\", \"Ben\", \"Anna\"]\n\nfor i in range(len(names)):\n    for j in range(i + 1, len(names)):\n            #\n            # Hier Code einfügen\n            #\n            break  # Keine weiteren Vergleiche für diesen Namen nötig",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Kontrollstrukturen</span>"
    ]
  },
  {
    "objectID": "notebooks/4-controls.html#anwendungen-in-der-mathematik",
    "href": "notebooks/4-controls.html#anwendungen-in-der-mathematik",
    "title": "6  Kontrollstrukturen",
    "section": "6.3 Anwendungen in der Mathematik",
    "text": "6.3 Anwendungen in der Mathematik\nMit den Werkzeugen, die uns jetzt zur Verfügung stehen, können wir bereits interessante Berechnungen durchführen und praktische Algorithmen implementieren. Wir illustrieren dies mit zwei Anwendungsfällen:\n\nDas Newton-Verfahren ist ein Algorithmus aus der numerischen Mathematik, um Nullstellen einer Funktion zu finden. Es wird auch angewendet, um Gleichungen zu lösen (dafür werden die Gleichungen so umformuliert, dass ein Nullstellenproblem vorliegt) oder Extremstellen zu identifizieren (das Verfahren sucht nach den Nullstellen der ersten Ableitung).\nLineare Algebra arbeitet mit Vektoren und Matrizen. Der Datentyp list eignet sich zur Modellierung dieser Objekte. Mithilfe von Schleifen können alle elementaren Operationen (z.B. Skalarprodukt oder Matrix-mal-Vektor) implementiert werden.\n\n\nDas Newton-Verfahren\n\nAufgabe: Implementieren Sie das Newton-Verfahren (siehe Wikipedia), welches nach einer Nullstelle einer Funktion \\(f(x)\\) sucht. Testen Sie es für die Funktion \\(f(x)=x^3+x^2-2\\,x-1\\) und probieren Sie dabei verschiedene Startwerte aus.\nHinweis: Da das Verfahren nicht immer konvergiert, sollten Sie eine maximale Zahl an Iterationen festlegen und danach das Verfahren abbrechen.\n\nWir erzeugen zunächst einen Plot der Funktion (den Code hierzu müssen Sie noch nicht nachvollziehen können):\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nxs = np.arange(-3,3,0.1)\nys = xs**3 + xs**2 - 2*xs-1\nplt.axhline(0, color=\"black\", linewidth=1)  # x-Achse\nplt.axvline(0, color=\"black\", linewidth=1)  # y-Achse\nplt.xlabel(\"x\")\nplt.ylabel(\"f(x)\")\nplt.plot(xs,ys,label=\"$f(x)=x^3+x^2-2\\,x-3$\")\n\n\n\n\n\n\n\n\n\nJetzt implementieren wir das Verfahren:\n\n\nCode\nmax_iter = 100  # maximale Zahl der Iterationen\nx = 1.0  # Startwert\ntol = 1e-6  # Toleranz\n\nfor i in range(max_iter):    \n\n    # Funktion:\n    f = x**3 + x**2 - 2 * x - 1 \n\n    # Ableitung:\n    fp = 3 * x**2 + 2 * x - 2 \n    \n    if abs(f) &lt; tol:\n        # Funktionswert ist nahe genug bei Null\n        print(\"Konvergiert nach \", i, \"Iterationen.\")\n        break\n    \n    x = x - f / fp  # Iteration des Newton-Verfahrens\n    \nprint(\"x=\", x, \"f(x)=\", f)\n\n\nBemerkung: Eine alternative Abbruchbedingung betrachtet die Änderung in \\(x\\) von Schritt zu Schritt. Sobald sich \\(x\\) nicht mehr signifikant ändert, bricht das Verfahren ab. Wir gehen an dieser Stelle nicht auf die Vor- und Nachteile der jeweiligen Abbruchbedingung ein.\n\n\nLineare Algebra mit Listen\nVektoren und Matrizen können mit Python-Listen dargestellt werden. Mithilfe von Schleifen können elementare Operationen der Linearen Algebra programmiert werden. Wir beginnen mit zwei Vektoren:\n\nv = [1.0, -2.0, 1.5] # Vektor v\nw = [-1.0, 1.0, 0.5] # Vektor w\n\n\nVektoraddition\n\nv_plus_w = [0,0,0] # Initialisierung\n\nfor i in range(3):\n    v_plus_w[i] = v[i] + w[i]\n\nprint(v_plus_w)\n\n[0.0, -1.0, 2.0]\n\n\nWas wäre eigentlich geschehen, wenn wir v + w ausprobiert hätten? Vergessen Sie nicht, dass v und w Listen sind und als solche keine natürliche Addition kennen. Statt dessen konkatentiert der Plus-Operator die beiden Listen:\n\nv_concat_w = v + w\nprint(v_concat_w)  # offensichtlich keine Vektoraddition \n\n[1.0, -2.0, 1.5, -1.0, 1.0, 0.5]\n\n\n\n\nSkalarprodukt\nDas Skalarprodukt ist eine wichtige Operation in der Linearen Algebra, mit der z.B. überprüft werden kann, ob zwei Vektoren senkrecht aufeinander stehen (Skalarprodukt gleich Null). Implementation:\n\nv_dot_w = 0  # Initialisierung\n\nfor i in range(3):\n    v_dot_w += v[i] * w[i]\n\nprint(v_dot_w)\n\n-2.25\n\n\n\n\nMatrizen\nEine Matrix kann als verschachtelte Liste dargestellt werden. Man kann sich das so vorstellen, dass die Elemente der äußeren Liste die Zeilen der Matrix sind (jede Zeile ist wiederum eine Liste ihrer Elemente):\n\n# innerhalb der eckigen Klammern sind \n# Zeilenumbrüche erlaubt, was die\n# Lesbarkeit als Matrix erhöht:\nM = [\n    [1.0, 0.0, 1.0],   # erste Zeile\n    [0.0, -1.0, 0.0],  # zweite Zeile\n    [2.0, 0.0, 0.0]    # dritte Zeile\n]\nprint(M)\n\n[[1.0, 0.0, 1.0], [0.0, -1.0, 0.0], [2.0, 0.0, 0.0]]\n\n\nAuf die Elemente der Matrix kann über Indizes zugegriffen werden:\n\nM[0]  # ist die erste Zeile\nM[0][0]  # erste Zeile, erste Spalte\nM[0][1]  # erste Zeile, zweite Spalte\nM[0][2]  # erste Zeile, dritte Spalte\n\nprint(M[2][0])  # dritte Zeile, erste Spalte\n\n2.0\n\n\n\n\nMatrixaddition\n\nM = [\n    [1.0, 0.0, 1.0],   # erste Zeile\n    [0.0, -1.0, 0.0],  # zweite Zeile\n    [2.0, 0.0, 0.0]    # dritte Zeile\n]\n\nN = [                  \n    [1.0, 0.5, 1.0],   # erste Zeile\n    [2.0, 1.0, 2.0],  # zweite Zeile\n    [-1.0, -1.0, 1.0]    # dritte Zeile\n]\n\n\nM_plus_N = [           # Initialisierung\n    [0.0, 0.0, 0.0],   # erste Zeile\n    [0.0, 0.0, 0.0],   # zweite Zeile\n    [0.0, 0.0, 0.0]    # dritte Zeile\n]\n\nfor i in range(3):     # i iteriert über die Zeilen\n    for j in range(3): # j iteriert über die Spalten\n        M_plus_N[i][j] = M[i][j] + N[i][j]\n\nprint(M_plus_N)  # überprüfen Sie das Ergebnis\n\n[[2.0, 0.5, 2.0], [2.0, 0.0, 2.0], [1.0, -1.0, 1.0]]\n\n\nMachen Sie sich die Funktionsweise der verschachtelten For-Schleifen klar: Der Zeilenindex i iteriert von 0 bis 2. Für jede Zeile, also jeden Wert von i, startet der Spaltenindex j jeweils wieder bei 0 und iteriert bis 2. So wird jede Kombination von i und j durchlaufen.\n\n\nMatrix mal Vektor\n\nM_dot_v = [0, 0, 0]  # Initialisierung\n\nfor i in range(3):\n    for j in range(3):\n        M_dot_v[i] += M[i][j] * v[j]\n\nprint(M_dot_v)  # rechnen Sie nach!\n\n[2.5, 2.0, 2.0]\n\n\n\nÜbungen:\n\nImplementieren Sie die Multiplikation von zwei Matrizen.\nImplementieren Sie eine Schleife, die die Transponierte einer Matrix berechnet.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Kontrollstrukturen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html",
    "href": "notebooks/5-functions.html",
    "title": "7  Funktionen",
    "section": "",
    "text": "7.1 Prozedurale Programmierung\nFunktionen sind ein zentrales Konzept der Programmierung, das es ermöglicht, Code in wiederverwendbare Einheiten zu gliedern. Sie tragen dazu bei, Programme übersichtlicher und wartbarer zu gestalten, vermeiden insbesondere redundanten Code. Wann immer man geneigt ist, eine Codezeile oder einen Block zu kopieren, sollte man darüber nachdenken, ob eine Funktion sinnvoll ist. In diesem Kapitel werden Funktionen allgemein und ihre Anwendung in Python im Speziellen vorgestellt.\nWir befinden uns noch immer in der sog. imperativen Programmierung: Dabei wird der Programmablauf durch eine Abfolge von Befehlen gesteuert, die der Reihe nach abgearbeitet werden (der Kontrollfluss wird insbesondere durch Verzweigungen und Schleifen beeinflusst).\nDie prozedurale Programmierung ist ein Ansatz innerhalb der imperativen Programmierung, bei dem das Programm als eine Reihe von Prozeduren oder Funktionen organisiert wird. Durch diese Aufteilung können komplexe Abläufe in einzelne, handhabbare Teile zerlegt werden, was zu einem klareren und besser wartbaren Code führt.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html#prozedurale-programmierung",
    "href": "notebooks/5-functions.html#prozedurale-programmierung",
    "title": "7  Funktionen",
    "section": "",
    "text": "Was ist eine Funktion?\nEine Funktion ist ein in sich geschlossener Block von Anweisungen, der eine bestimmte Aufgabe erfüllt. Vergleichen Sie eine Funktion mit einem Kochrezept: Das Rezept beschreibt eine schrittweise Anleitung zur Zubereitung eines Gerichts. Wann immer Sie das Gericht kochen, verwenden Sie dasselbe Rezept wieder und wieder. In der Programmierung würden wir sagen: “Sie rufen dieselbe Funktion immer wieder auf.” Von dem Rezept benötigen Sie aber nur ein einziges Exemplar (ganz egal, wie oft sie das Gericht kochen werden). So ist es auch mit dem Code, der in einer Funktion definiert wird: Sie schreiben ihn ein einziges Mal und verwenden ihn dann beliebig oft.\nManchmal wird auch eine Analogie zu mathematischen Funktionen \\(f(x)\\) gezogen. Diese Analogie hat aber einige Schwächen: Die mathematische Funktion bekommt immer einen Input (hier \\(x\\)) und gibt immer einen Wert als Output (\\(y = f(x)\\)) zurück. Das muss bei Funktionen in der Programmierung nicht sein! Eine Funktion in der Programmierung kommt auch ohne Input und Output aus, wie wir gleich sehen werden. Es liegt ganz in Ihrer Freiheit, ob Ihre Funktionen mit Inputs und Outputs arbeitet oder nicht. Sie können sogar eine Funktion programmieren, die beliebig viele Inputs verarbeiten kann (eine solche Funktion haben wir bereits kennengelernt, wissen Sie welche?).\nBevor wir konkret werden, fassen wir die Vorteile von Funktionen zusammen:\n\nModularisierung: Zerlegung des Codes in kleine, verständliche Einheiten.\nWiederverwendbarkeit: Einmal definierte Funktionen können mehrfach eingesetzt werden.\nLesbarkeit und Wartbarkeit: Klar strukturierter Code erleichtert das Verständnis und die Fehlersuche.\nVermeidung von Redundanz: Gleicher Code muss nicht mehrfach geschrieben werden, sondern kann über Funktionsaufrufe wiederverwendet werden. Insbesondere von Vorteil, wenn Sie etwas ändern müssen: Sie müssen nur eine Stelle korrigieren, egal wie oft die Funktion aufgerufen wird.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html#funktionen-in-python",
    "href": "notebooks/5-functions.html#funktionen-in-python",
    "title": "7  Funktionen",
    "section": "7.2 Funktionen in Python",
    "text": "7.2 Funktionen in Python\nPython bietet eine einfache und flexible Syntax zur Definition von Funktionen. Eine Funktion wird mit dem Schlüsselwort def eingeleitet, gefolgt vom Funktionsnamen (den Sie selbst festlegen). In runden Klammern werden optional Eingangsparameter definiert, dann folgt ein Doppelpunkt. Der eigentliche Funktionsblock muss eingerückt werden (das kennen Sie schon von Code-Blöcken in Verzweigungen und Schleifen). Hier ein einfaches Beispiel ohne Eingangsparameter:\n\ndef greeting():\n    print(\"Hello, world!\")\n\nWir haben eine sehr primitive Funktion definiert, die nichts anderes tut, als \"Hello, World\" auszugeben, wann immer wir sie aufrufen:\n\ngreeting()\n\nHello, world!\n\n\nBeachten Sie beim Aufruf der Funktion die runden Klammern, die gleich mehr Sinn ergeben werden.\n\nParameter und Argumente\nWie bereits erwähnt, können Funktionen Parameter entgegennehmen, um mit variablen Eingabewerten zu arbeiten. Zum Beispiel können wir unsere Begrüßungsfunktion so erweitern, dass Sie einen Namen als Parameter entgegennimmt und diesen für eine personalisierte Begrüßung verwendet:\n\ndef greeting(name):\n    print(\"Hallo,\",name)\n\n\ngreeting(\"Anna\")\n\nHallo, Anna\n\n\n\ngreeting(\"Tom\")\n\nHallo, Tom\n\n\n\n\n\n\n\n\nArgumente\n\n\n\nDen konkreten Wert, den man an eine Funktion übergibt, nennt man Argument. Wir haben in unseren Beispielen bereits verschiedene Argumente (“Anna”,“Tom”) für den Parameter name verwendet.\n\n\nWas jetzt nicht mehr funktioniert: Wir können die Funktion nicht mehr ohne ein Argument für den Parameter name aufrufen! Probieren Sie greeting() und Python wird sich beschweren, dass ein Argument fehlt! Eine besondere Möglichkeit, dieses Problem zu beheben, ist sog. Standardargumente für Parameter festzulegen. Diese werden verwendet, wenn der Anwender der Funktion kein Argument übergibt (ob das sinnvoll ist oder nicht, hängt ganz von Ihrer Anwendung ab). Wir demonstrieren die Begrüßungsfunktion mit einem Standardargument:\n\ndef greeting(name = \"Welt\"):\n    print(\"Hallo,\",name)\n\n\ngreeting(\"Lisa\")\n\nHallo, Lisa\n\n\n\ngreeting()\n\nHallo, Welt\n\n\nDer Parameter name wurde durch die Definition eines Standardarguments zu einem optionalen Parameter: Es ist nicht mehr zwingend erforderlich, ihn beim Funktionsaufruf festzulegen.\n\n\nMehrere Parameter\nSelbstverständlich können wir mehr als einen Parameter verwenden:\n\ndef greeting(name, age):\n    print(\"Hallo,\", name)\n    if age &lt; 18:\n        print(\"Sie sind noch minderjährig!\")\n    else:\n        print(\"Willkommen im Club!\")\n\n\ngreeting(\"Tom\", 16)\ngreeting(\"Lisa\", 21)\n\nHallo, Tom\nSie sind noch minderjährig!\nHallo, Lisa\nWillkommen im Club!\n\n\nJetzt muss man allerdings aufpassen, wenn man Standardargumente verwenden will, denn es gibt eine wichtige Regel:\n\n\n\n\n\n\nOptionale Parameter immer hinter nicht-optionalen Parametern!\n\n\n\nFolgende Definition ist korrekt:\ndef greeting(name, age = 20):\n    # Funktionsblock\nFolgender Code ist falsch und wird nicht funktionieren:\ndef greeting(name=\"Peter\", age):\n    # Funktionsblock\n\n\n\n\nRückgabewerte\nFunktionen können einen Wert zurückgeben. Hierfür verwendet man (wie in C oder C++) das Keyword return:\n\ndef square(x):\n    return x * x\n\nresult = square(4)\nprint(result)\n\n16\n\n\nWir können die Funktion wieder beliebig oft mit verschiedenen Argumenten aufrufen:\n\nprint(square(3))\nprint(square(-2))\nprint(square(7.3))\n\n9\n4\n53.29\n\n\n\n\n\n\n\n\nMerke: return beendet sofort die Funktion!\n\n\n\nInnerhalb einer Funktion können wir den Kontrollfluss mit allen uns bekannten Mitteln beeinflussen, z.B. mit Verzweigungen. Wichtig ist aber, dass die Funktion sofort verlassen wird, wenn der Interpreter auf ein return trifft!\n\n\nEine Besonderheit in Python ist, dass wir sogar mehr als einen Wert zurückgeben können! Das geht in vielen anderen Programmiersprachen nicht ohne Weiteres, in C oder C++ würde man dafür z.B. Datenstrukturen (als Container für mehrere Werte) oder Zeiger verwenden (die auf einen Bereich im Speicher verweisen, wo die Werte hintereinander abgelegt werden). In Python geht das ganz einfach, wie das folgende Beispiel zeigt:\n\ndef divmod(a, b): \n    # Division mit Rest\n    # zwei Rückgabewerte durch Komma getrennt:\n    return a // b, a % b \n\na = 13\nb = 3\n\nquotient, remainder = divmod(a,b)\n\nprint(a, \"geteilt durch\", b ,\"ergibt:\")\nprint(quotient, \"mit Rest\", remainder)\n\n13 geteilt durch 3 ergibt:\n4 mit Rest 1\n\n\nDie Reihenfolge der Rückgabewerte ist natürlich zu beachten, sonst geschehen leicht Fehler (würde man versehentlich remainder, quotient = divmod(a,b) schreiben, stünde in quotient der Rest und in remainder der Quotient).\n\n\nKeyword-Argumente\nPython erlaubt uns, Funktionen mit sog. Keyword-Argumenten aufzurufen. Damit ist gemeint, dass die Argumente explizit benannt werden, anstatt sie anhand ihrer Reihenfolge zu identifizieren. Betrachten wir zunächst folgendes Beispiel, in dem wir eine Funktion wie gewohnt aufrufen:\n\ndef print_personal_details(name, age, city):\n    print(\"Name:\", name)\n    print(\"Alter:\", age)\n    print(\"Wohnort:\", city)\n\nprint_personal_details(\"Alice\", 23, \"London\") # wie gehabt\n\nName: Alice\nAlter: 23\nWohnort: London\n\n\nJetzt zeigen wir Varianten mit Keyword-Argumenten:\n\n# mit Verwendung von Keyword-Argumenten:\nprint_personal_details(name = \"John\", city = \"Birmingham\", age = 32) \n\nName: John\nAlter: 32\nWohnort: Birmingham\n\n\n\n# teilweise mit Keyword-Argumenten:\nprint_personal_details(\"Marc\", city = \"Hamburg\", age = 19)\n\nName: Marc\nAlter: 19\nWohnort: Hamburg\n\n\nWie Sie sehen, können Sie die Parameternamen explizit verwenden, um ein Argument zu definieren und dabei sogar von der Reihenfolge im Funktionskopf abweichen. Eine Regel gibt es allerdings auch hier wieder: Wenn Sie nur teilweise Keyword-Argumente verwenden (wie im Beispiel \"Marc\" oben), kommen die Keyword-Argumente immer am Schluss! Zur namentlichen Abgrenzung von den Keyword-Argumenten, bezeichnet man die Argumente, die anhand ihrer Reihenfolge identifiziert werden, als Positionsargumente (engl.: keyword arguments and positional arguments). Halten wir also fest:\n\n\n\n\n\n\nPositions-Argumente zuerst, dann Keyword-Argumente!\n\n\n\nPython weist zunächst die Argumente entsprechend ihrer Reihenfolge den Parametern zu (Positionsargumente). Danach können verbleibende Parameter explizit über Schlüsselworte (Keyword-Argumente) gesetzt werden.\n\n\n\nÜbungen:\n\nSchreiben Sie eine Funktion, die einen persönlichen Begrüßungstext auf verschiedenen Sprachen ausgeben kann. Die Standardsprache soll Deutsch sein, bieten Sie mindestens zwei weitere Sprachen an. Übergeben Sie neben der Sprache weitere Argumente, die Sie für eine personalisierte Begrüßung benötigen.\n\nEin Körper werde aus seiner Ruhelage beschleunigt. Implementieren Sie eine Funktion accelerated_motion(a, t), die die Beschleunigung a und die Zeit t als Parameter erwartet und die zurückgelegte Strecke \\(s(t)=\\frac{1}{2}a\\,t^2\\) und die Geschwindigkeit \\(v(t)=a\\cdot t\\) zurückgibt.\nErweitern Sie die Funktion accelerated_motion um zwei optionale Parameter s0 und v0, die eine Anfangsposition bzw. eine Anfangsgeschwindigkeit zum Zeitpunkt \\(t=0\\) darstellen. Übergibt man keine Argumente, soll die Bewegung wie gehabt aus der Ruhelage beginnen.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html#dynamische-typisierung-und-mögliche-gefahren",
    "href": "notebooks/5-functions.html#dynamische-typisierung-und-mögliche-gefahren",
    "title": "7  Funktionen",
    "section": "7.3 Dynamische Typisierung und mögliche Gefahren",
    "text": "7.3 Dynamische Typisierung und mögliche Gefahren\nWir kennen bereits die dynamische Typisierung als besondere Eigenschaft von Python. Im Zusammenhang mit Funktionen erlaubt Sie uns, dieselbe Funktion mit unterschiedlichen Datentypen aufzurufen (wir haben das bereits oben einmal getan, finden Sie das Beispiel?). In anderen Programmiersprachen muss man dafür die Funktion in der Regel mehrfach implementieren (eine Variante für jeden Datentyp), man sagt auch: die Funktion wird überladen. Bei überladenen Funktionen in C oder C++ erkennt der Compiler anhand der übergebenen Datentypen, welche Version der Funktion gemeint ist.\nNicht so in Python, wo der Datentyp der Parameter und Rückgabewerte nicht vom Programmierer bzw. der Programmiererin festgelegt wird. Das kann sehr nützlich sein, aber auch zu Fehlern führen, wenn die Funktion mit inkompatiblen Datentypen aufgerufen wird. Hierzu ein Beispiel:\n\ndef multiply(x, y):\n    return x * y\n\nEine sehr einfache Funktion, die zwei Parameter miteinander multipliziert. Wir rufen sie jetzt mit unterschiedlichen Datentypen auf:\n\nprint(multiply(3, 4)) # zwei Integer\nprint(multiply(2, 3.2)) # Integer und Float\nprint(multiply(2+2j, 3-1j)) # zwei komplexe Zahlen\nprint(multiply(\"hi\", 3)) # String und Integer\n\n12\n6.4\n(8+4j)\nhihihi\n\n\nHätten Sie geahnt, was alles mit dieser kleinen, unscheinbaren Funktion möglich ist?\nEs scheint fast alles möglich zu sein, aber eben nur fast! Rufen Sie die Funktion mit zwei Strings auf und Ihr Programm stürzt ab (wie sollen zwei Strings miteinander multipliziert werden?). Natürlich sind auch viele weitere Kombinationen nicht möglich (versuchen Sie z.B. zwei Listen miteinander zu multiplizieren oder eine Liste mit einem String). Manchmal ist es sogar noch schlimmer, wenn das Programm zwar nicht abstürzt, aber das Ergebnis völlig unerwartet ist (hätten Sie z.B. das Ergebnis der Multiplikation von String mit Integer in der Form erwartet?). Dann entstehen an einer anderen Stelle im Code womöglich überraschend Probleme und Sie müssen langwierig debuggen, bis Sie die Ursache finden.\nDaran erkennen Sie wieder: Python bietet große Flexibilität, aber Sie müssen damit verantwortungsbewusst umgehen!\n\nÜbung: Schreiben Sie eine Funktion a_plus_b(a, b), die die Summe von zwei Parametern a und b zurückgibt.\n\nFinden Sie mindestens fünf verschiedene Kombinationen von Datentypen, für die sich die Funktion ausführen lässt.\nFinden Sie mindestens fünf verschiedene Kombinationen von Datentypen, die zu einem Absturz führen!\n\n\n\nErgänzung: Mit isinstance den Typ von Parametern prüfen\nMit der Funktion isinstance kann bei Bedarf der Typ von Übergabeparametern geprüft werden. Es ist somit möglich, eine Funktion gegen die Verwendung mit inkompatiblen Typen abzusichern. Im Beispiel sieht dies so aus:\n\ndef add_and_sort_lists(a, b):\n    if isinstance(a, list) and isinstance(b, list):\n        c = a + b\n        c.sort()\n        return c\n    else:\n        print(\"Inkompatible Typen\")\n\n\nadd_and_sort_lists([1, 5, 2], [4, 3])\n\n[1, 2, 3, 4, 5]\n\n\n\nadd_lists([1, 2], 3.4)\n\nInkompatible Typen\n\n\nHinweis: Eine Abfrage mit type() (z.B. type(x) == int) wird für diesen Zweck nicht empfohlen, da isinstance() im Gegensatz zu type() auch abgeleitete Datentypen erkennt (siehe Vererbung / objektorientierte Programmierung: Wenn eine Klasse Dog von einer Klasse Animal erbt, würde isinstance einen Dog auch als Animal erkennen.).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html#funktionen-mit-beliebig-vielen-parametern",
    "href": "notebooks/5-functions.html#funktionen-mit-beliebig-vielen-parametern",
    "title": "7  Funktionen",
    "section": "7.4 Funktionen mit beliebig vielen Parametern",
    "text": "7.4 Funktionen mit beliebig vielen Parametern\nWir kennen seit Beginn des Kurses eine Funktion, die beliebig viele Argumente entgegennehmen kann:\n\nprint()  # 0 Argumente\nprint(\"Hallo\")  # 1 Argument\nprint(\"Hallo,\", \"Welt\")  # 2 Argumente usw.\n\n\nHallo\nHallo, Welt\n\n\nMit einem einfachen Trick, können Sie selbst solche Funktionen definieren: Stellen Sie vor ein Argument ein *, damit machen Sie deutlich, dass hier eine Sequenz von Argumenten übergeben werden kann. Innerhalb der Funktion können Sie über die Sequenz iterieren, z.B. mit der bekannten For-Schleife:\n\ndef sum_numbers(*numbers):\n    result = 0\n    \n    for number in numbers:\n        result += number\n\n    return result\n\nprint(sum_numbers(-2))\nprint(sum_numbers(5, 10))\nprint(sum_numbers(1, 2, 3, 4)) \n\n-2\n15\n10",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html#scope",
    "href": "notebooks/5-functions.html#scope",
    "title": "7  Funktionen",
    "section": "7.5 Scope",
    "text": "7.5 Scope\nIn Python – und generell in der Programmierung – bezieht sich der Scope (Gültigkeitsbereich) auf den Bereich des Codes, in dem eine Variable sichtbar und zugänglich ist. Es gibt dabei zwei Hauptarten von Scope:\n\nLokaler Scope: Eine Variable, die innerhalb einer Funktion definiert wird, ist nur in dieser Funktion sichtbar und außerhalb nicht zugänglich.\nGlobaler Scope: Eine Variable, die außerhalb einer Funktion definiert wird, ist nach ihrer Definition im gesamten Programm sichtbar (auch innerhalb einer Funktion). Python schützt uns aber davor, globale Variablen unbeabsichtigt im Inneren einer Funktion neu zuzuweisen, es sei denn wir machen unsere Absicht explizit deutlich. Dafür gibt es in Python das Keyword global.\n\nBeginnen wir mit einem Beispiel zum lokalen Scope:\n\ndef my_function(a, b):\n    c = a + b\n    return c**2\n\nmy_function(2,3)\nprint(c) # FEHLER!!!! c ist hier nicht bekannt. \n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[234], line 6\n      3     return c**2\n      5 my_function(2,3)\n----&gt; 6 print(c)\n\nNameError: name 'c' is not defined\n\n\n\nAuf die Variable c kann außerhalb der Funktion nicht zugegriffen werden, sie existiert nur im lokalen Scope der Funktion.\nNun versuchen wir umgekehrt innerhalb der Funktion auf eine Variable zuzugreifen, die außerhalb definiert wurde:\n\ndef greeting():\n    print(\"Hallo,\", name)  # name existiert im globalen Scope\n\nname = \"Peter\"\ngreeting()\n\nHallo, Peter\n\n\nDas Beispiel ist geglückt! Allerdings handelt es sich hierbei nicht um guten Programmierstil. Vielmehr sollte man name als Parameter der Funktion definieren. Was geschieht eigentlich, wenn es name im globalen und im lokalen Scope gibt?\n\ndef greeting(name):\n    print(\"Hallo,\", name)\n\nname = \"Peter\"\ngreeting(\"Tina\")\n\nHallo, Tina\n\n\nDer lokale Scope geht vor! Die Funktion sucht immer zuerst in ihrem lokalen Scope nach der Variable. Nur, wenn sie sie dort nicht findet, schaut sie im globalen Scope nach. Diese Regel nennt man auch LEGB-Rule: Python sucht nach Variablennamen von innen nach außen über diese Stufen: L = local scope, E = enclosing scope (umschließende Funktionen), G = global scope, B = built-in scope (eingebaute Python-Bezeichner).\n\nDas Keyword global in Python\nWie bereits erwähnt, schützt uns Python davor, unbeabsichtigt eine Variable aus dem globalen Scope neu zuzuweisen, wenn wir uns innerhalb einer Funktion befinden. Das wird im folgenden Beispiel illustriert:\n\ndef change_name(new_name):\n    name = new_name\n\nname = \"Peter\"\nchange_name(\"John\")\nprint(name)\n\nPeter\n\n\nHätten Sie die Ausgabe “John” erwartet? Python schützt uns: Beim Versuch die globale Variable innerhalb einer Funktion neu zuzuweisen, hat Python stattdessen eine neue Variable im lokalen Scope der Funktion angelegt - mit demselben Bezeichner: name! Diese lokale Variable bekam den Wert “John”, aber die Variable im globalen Scope wurde nicht angefasst. Machen wir das ruhig explizit:\n\ndef change_name(new_name):\n    name = new_name\n    print(\"name innerhalb der Funktion:\", name)\n\nname = \"Peter\"\nchange_name(\"John\")\nprint(\"name außerhalb:\", name)\n\nname innerhalb der Funktion: John\nname außerhalb: Peter\n\n\nWir haben nun bereits mehrfach gesehen, dass Variablen mit demselben Namen in unterschiedlichen Scopes existieren können. Python speichert die Variablennamen für jeden Scope in einer eigenen Liste, dem sog. Namespace, der zu diesem Scope gehört. Im obigen Beispiel existiert also eine Variable name im globalen Namespace und eine Variable name im Namespace der Funktion change_name. Obwohl diese beiden Variablen gleich heißen, handelt es sich doch um getrennte Variablen, die in der Regel unterschiedliche Instanzen referenzieren. Beim Aufruf von print innerhalb der Funktion wird gemäß der LEGB-Rule die lokale Variable zuerst gefunden und verwendet. Bei der Verwendung von print außerhalb der Funktion, findet Python stattdessen die globale Variable (Reminder: Python sucht immer von innen nach außen).\nEs gibt eine Möglichkeit, den vorgestellten Sicherheitsmechanismus auszuhebeln: mit dem Keyword global!\n\ndef change_name(new_name):\n    global name  # hey Python, wir meinen die globale Variable!\n    name = new_name\n\nname = \"Peter\"\nchange_name(\"John\")\nprint(name)\n\nJohn\n\n\nMit der Zeile global name weisen wir Python explizit an, die Variable name aus dem globalen Scope zu verwenden! In diesem Beispiel wird keine lokale Variante von name angelegt. Die Variable name existiert nur im globalen Namespace, kann aber in der Funktion frei verwendet werden.\n\n\n\n\n\n\nVerwendung globaler Variablen in Funktionen\n\n\n\nFinden Sie das alles noch ein wenig verwirrend? Gut so, denn Sie sollten von der Verwendung globaler Variablen in Funktionen sowieso besser absehen. Versuchen Sie stattdessen saubere Schnittstellen mithilfe von Parametern und Rückgabewerten zu definieren. Wann immer Sie geneigt sind, lesend auf einen globalen Wert zuzugreifen, übergeben Sie diesen lieber als Argument. Wann immer Sie geneigt sind, schreibend auf einen globalen Wert zuzugreifen, arbeiten Sie lieber mit einem Rückgabewert, den Sie im Hauptprogramm zuweisen können.\nBeispiel: Eine Zahl im globalen Scope soll durch ihre Quadratzahl ersetzt werden.\ndef square(x):\n    return x**2 # die Funktion führt die Rechnung durch\n\na = 42\na = square(a) # die eigentliche Veränderung geschieht außerhalb der Funktion",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/5-functions.html#docstrings-und-typ-annotationen-meine-funktion-für-andere-dokumentieren",
    "href": "notebooks/5-functions.html#docstrings-und-typ-annotationen-meine-funktion-für-andere-dokumentieren",
    "title": "7  Funktionen",
    "section": "7.6 Docstrings und Typ-Annotationen: Meine Funktion für andere dokumentieren",
    "text": "7.6 Docstrings und Typ-Annotationen: Meine Funktion für andere dokumentieren\nIn großen Software-Projekten sind Sie nicht die einzige Person, die Ihre Funktionen benutzt. Sie können durch verständliche Dokumentation die Nutzbarkeit Ihrer Funktionen enorm erhöhen. Eine einfache Möglichkeit sind sog. Docstrings: Dabei handelt es sich um eine spezielle Kommentierung, direkt nach der definierenden Zeile:\n\ndef bending_stress(moment, y, inertia):\n    \"\"\"\n    Berechnet die Biegespannung in einem Balken.\n\n    Formel: sigma = (M * y) / I\n\n    Args:\n        moment (float): Biegemoment in Newton-Meter (Nm).\n        y (float): Abstand von der Neutralachse in Meter (m).\n        inertia (float): Flächenträgheitsmoment in m^4.\n\n    Returns:\n        float: Biegespannung in Pascal (Pa).\n    \"\"\"\n    \n    return moment * y / inertia\n\nDer Docstring wird mit \"\"\" eingeleitet, es folgt eine kurze Erklärung der Funktion, anschließend eine Erklärung der Argumente und der Rückgabewerte, und zum Abschluss wieder \"\"\". Wie genau der Docstring formattiert wird, hängt von der gewählten Konvention ab (wir haben hier den Google-Style verwendet). Viele Editoren greifen Docstrings in unterstützenden Funktionen auf (Tooltips oder Autovervollständigungen). Insbesondere kann nun aber jeder Entwickler und jede Entwicklerin über die Funktion help()eine Hilfe zu Ihrer Funktion aufrufen:\n\nhelp(bending_stress)\n\nHelp on function bending_stress in module __main__:\n\nbending_stress(moment, y, inertia)\n    Berechnet die Biegespannung in einem Balken.\n    \n    Formel: sigma = (M * y) / I\n    \n    Args:\n        moment (float): Biegemoment in Newton-Meter (Nm).\n        y (float): Abstand von der Neutralachse in Meter (m).\n        inertia (float): Flächenträgheitsmoment in m^4.\n    \n    Returns:\n        float: Biegespannung in Pascal (Pa).\n\n\n\nEine weitere Unterstützung bieten Typ-Annotation, mit denen wir andere Entwickler bzw. Entwicklerinnen darüber informieren, welche Datentypen unsere Funktion erwartet bzw. zurückgibt. Aber Vorsicht: Diese Angaben sind rein informativ! Sie verhindern nicht, dass die Funktion mit anderen Datentypen aufgerufen wird! Unser Beispiel mit Typ-Annotationen:\n\ndef bending_stress(moment: float, y: float, inertia: float) -&gt; float:\n    # Rest wie oben\n    pass # pass ist nur ein Platzhalter\n\nDie Typ-Annotationen geben an: Wir erwarten den Datentyp float für die Parameter moment, y und inertia und geben auch eine Float als Ergebnis zurück (-&gt; float).\n\nÜbung:\nSchreiben Sie eine Funktion ohms_law(R, U, I): Der Anwender übergibt für jeweils zwei der drei Parameter Zahlenwerte und für den dritten den String \"*\". Daraufhin berechnet die Funktion den fehlenden Wert mithilfe des Ohmschen Gesetzes und gibt ihn zurück. Dokumentieren Sie die Funktion mit einem Docstring, der die Benutzung erklärt.\n\n\n\nCode\ndef ohms_law(R, U, I):\n    \"\"\"\n    Berechnet Widerstand, Spannung oder Strom mithilfe des Ohmschen Gesetzes. \n    Der fehlende Wert wird mit dem Argument \"*\" markiert; für die anderen beiden müssen Zahlen übergeben werden.\n    Args:\n        R (float oder string): El. Widerstand (Ohm) oder \"*\".\n        U (float oder string): El. Spannung (Volt) oder \"*\".\n        I (float oder string): El. Strom (A) oder \"*\".\n    Returns:\n        float: fehlender Wert\n    \"\"\"\n    \n    if R == \"*\":\n        return U / I\n    elif U == \"*\":\n        return R * I\n    elif I == \"*\":\n        return U / R\n    else:\n        print(\"Ungültige Eingabe! Siehe Hilfe: \")\n        help(ohms_law)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html",
    "href": "notebooks/6-sequences.html",
    "title": "8  Datenstrukturen in Python",
    "section": "",
    "text": "8.1 Ein Sensor speichert stündlich Temperaturdaten – Anwendung der Liste\nDatenstrukturen und Datentypen sind zentrale Begriffe in der Informatik, die eng miteinander verbunden, aber dennoch voneinander zu unterscheiden sind:\nWährend Datentypen also die Bausteine sind, definieren Datenstrukturen den Bauplan, wie diese Bausteine miteinander in Beziehung stehen und verarbeitet werden. In diesem Kapitel fokussieren wir uns auf grundlegende Datenstrukturen und deren Anwendung in Python anhand eines praxisnahen Beispiels: der Organisation und Analyse von Sensordaten. Das Beispiel wird im Verlauf des Kapitels sukzessive komplexer und damit auch realistischer.\nSie sollen einen Eindruck davon gewinnen, wie verschiedene Datenstrukturen für bestimmte Fragstellungen und Anwendungen ihre Stärken ausspielen.\nEin Sensor misst stündlich die Temperatur (z.B. in einem Raum oder einer Maschine). Diese Daten speichern wir der Reihe nach in einer Liste, einer der einfachsten Datenstrukturen. Die Liste ist ideal für lineares Speichern (Messwert für Messwert hintereinander). Sie ermöglicht den einfachen Zugriff auf Elemente anhand ihrer Position, stellt aber auch nützliche Funktionen zum Arbeiten mit den Daten bereit.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#ein-sensor-speichert-stündlich-temperaturdaten-anwendung-der-liste",
    "href": "notebooks/6-sequences.html#ein-sensor-speichert-stündlich-temperaturdaten-anwendung-der-liste",
    "title": "8  Datenstrukturen in Python",
    "section": "",
    "text": "Speichern der Daten\n\n# eine Liste kann mit Werten initialisiert werden\ntemperatures = [22.5, 23.1, 21.8]\n\n# es kann aber auch nach und nach ein Wert hinten angefügt werden:\ntemperatures.append(24.0)\ntemperatures.append(22.5)\ntemperatures.append(21.8)\n\nprint(temperatures)\n\n[22.5, 23.1, 21.8, 24.0, 22.5, 21.8]\n\n\nIn der Praxis würde an einer bestimmten Stelle im Code (einmal pro Stunde) mithilfe von append der aktuelle Messwert in der Liste gespeichert werden. Auffällig ist, dass die Funktion append zu unserer Liste selbst gehört, beim Aufruf verwenden wir einen . zwischen der Referenz auf die Liste und der Funktion. Solche Funktionen werden auch Methoden genannt und sind ein wesentlicher Bestandteil der objektorientierten Programmierung: Die Instanz einer Liste bietet Benutzern diese Funktion an, um ihren Inhalt zu manipulieren.\n\n\nSortieren der Messungen\nSortieren hilft, die Werte geordnet darzustellen und z.B. das Finden des höchsten oder niedrigsten Messwerts zu erleichtern. Auch hierfür steht eine Methode bereit:\n\n# Sortieren der Liste\ntemperatures.sort()\nprint(\"Sortierte Temperaturen:\", temperatures)\n\nSortierte Temperaturen: [21.8, 21.8, 22.5, 22.5, 23.1, 24.0]\n\n\nWir können nun direkt ablesen, dass der Wertebereich zwischen 21.8 und 24.0 liegt. Allerdings haben wir unsere Originalliste durch das Sortieren verändert! Das war womöglich gar nicht unsere Absicht, denn wir wollen weiterhin die Information besitzen, wann welcher Wert erhoben wurde. Für diesen Zweck gibt es eine Lösung: Anstelle der Methode .sort() verwenden wir die Funktion sorted(), die eine sortierte Liste zurückgibt ohne das Original zu verändern:\n\n# Wir stellen zunächst das Original wieder her\ntemperatures = [22.5, 23.1, 21.8, 24.0, 22.5, 21.8]\n\nsorted_data = sorted(temperatures)\nprint(\"Sortierte Liste: \", sorted_data)\nprint(\"Original: \", temperatures)\n\nSortierte Liste:  [21.8, 21.8, 22.5, 22.5, 23.1, 24.0]\nOriginal:  [22.5, 23.1, 21.8, 24.0, 22.5, 21.8]\n\n\nDie implementierten Sortieralgorithmen sind übrigens sehr effizient (schneller als der früher vorgestellte Bubble Sort).\n\n\nWerte extrahieren - Indexzugriff und List Slicing\nWir können auf die Werte in einer Liste ganz einfach über ihren Index zugreifen und dabei ist besonders nützlich, dass Python auch negative Indizes erlaubt: der Index -1 entspricht immer dem letzten Element, -2 dem vorletzten usw. Wir demonstrieren die Verwendung von Indizes:\n\nprint(\"1. Messwert: \" , temperatures[0])\nprint(\"Letzter Messwert: \" , temperatures[-1])\nprint(\"Min: \" , sorted_data[0])\nprint(\"Max: \" , sorted_data[-1])\nprint(\"5. Messwert: \" , temperatures[4])\nprint(\"Vorletzter Messwert: \" , temperatures[-2])\n\n1. Messwert:  22.5\nLetzter Messwert:  21.8\nMin:  21.8\nMax:  24.0\n5. Messwert:  22.5\nVorletzter Messwert:  22.5\n\n\nOft interessiert man sich für Bereiche von Messwerten und kann diese in Python sehr effizient mit sog. “List Slicing” ausschneiden: Hierfür verwendet man einen Start- und Endindex, getrennt durch ein :. Zu beachten ist, dass der Anfangsindex inkludiert wird, das Slicing aber einen Schritt vor dem Endindex aufhört:\n\n# Slicing: Werte gesucht ...\n# ... mit Indizes: 0,1,2\nprint(temperatures[0:3])  \n\n# ... mit Indizes: 2,3,4\nprint(temperatures[2:5])  \n\n# ... mit Indizes: 1,2,3...,vorletztes\nprint(temperatures[1:-1])  \n\n[22.5, 23.1, 21.8]\n[21.8, 24.0, 22.5]\n[23.1, 21.8, 24.0, 22.5]\n\n\nMan kann auch Start- und Endindex weglassen und meint damit “von Anfang” oder “bis Ende”:\n\n# Slicing: Werte gesucht ...\n# ... von Anfang bis Index 2\nprint(temperatures[:3]) \n\n# ... von Index 4 bis Schluss\nprint(temperatures[4:]) \n\n# Die ganze Liste als großer Slice:\nprint(temperatures[:]) \n\n[22.5, 23.1, 21.8]\n[22.5, 21.8]\n[22.5, 23.1, 21.8, 24.0, 22.5, 21.8]\n\n\nPython erlaubt sogar noch präzisere Analysen, indem es Schrittweiten beim Slicing zulässt. Die Schrittweite ist standardmäßig 1, aber kann als dritter Parameter hinter einem weiteren : verändert werden:\n\n# von Index 0 bis 4 in 2er Schritten\nprint(temperatures[0:5:2]) \n\n# von Index 1 bis Schluss in 2er Schritten\nprint(temperatures[1::2]) \n\n# jeder dritte Messwert\nprint(temperatures[::3]) \n\n# auch rückwärts funktioniert!\nprint(temperatures[4:1:-1]) \n\n# komplette Liste rückwärts\nprint(temperatures[::-1]) \n\n[22.5, 21.8, 22.5]\n[23.1, 24.0, 21.8]\n[22.5, 24.0]\n[22.5, 24.0, 21.8]\n[21.8, 22.5, 24.0, 21.8, 23.1, 22.5]\n\n\nMan kann auch mit dem Operator in fragen, ob ein spezifischer Wert in der Liste enthalten ist:\n\n23.1 in temperatures\n\nTrue\n\n\nDabei muss intern aber jedes Element einzeln abgefragt werden, mit Pech also die gesamte Liste durchgegangen werden (die Datentypen set und dict sind hier deutlioch effizienter).\nPraktisch sind auch die Funktionen min() und max():\n\nprint(\"Min: \", min(temperatures))\nprint(\"Max: \", max(temperatures))\n\nMin:  21.8\nMax:  24.0\n\n\n\n\n\n\n\n\nWie initialisiert man eine Liste?\n\n\n\nEs gibt mehrere Möglichkeiten, eine neue Liste anzulegen - leer oder mit Inhalt:\n\nLeere Initialisierung: [] oder list()\nMit Werten: [1, 2, 3]\nAus anderen Datenstrukturen: list(x), wobei x einen String, ein Set, ein Tuple oder ein Dictionary referenzieren kann. Im Falle vom String erhält man beispielsweise die Liste der Zeichen, im Falle des Dictionaries die Liste der Schlüssel.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#analyse-der-einzigartigen-messwerte-anwendung-des-sets",
    "href": "notebooks/6-sequences.html#analyse-der-einzigartigen-messwerte-anwendung-des-sets",
    "title": "8  Datenstrukturen in Python",
    "section": "8.2 Analyse der einzigartigen Messwerte – Anwendung des Sets",
    "text": "8.2 Analyse der einzigartigen Messwerte – Anwendung des Sets\nWir möchten wissen, welche Temperaturwerte einzigartig sind. Hierfür ist ein Set ideal, da es automatisch doppelte Einträge entfernt. Würden wir weiter mit einer Liste arbeiten, müssten wir selbst die Daten filtern, z.B. mit den uns bekannten Schleifen. Das wäre allerdings deutlich ineffizienter. Das Set entspricht einer mathematischen Menge, in der jedes Element nur einmal vorkommen darf. Für die Umwandlung führen wir ein explizites Casting durch:\n\nunique_values = set(temperatures)\nprint(unique_values) # keine doppelten Werte mehr\n\n{24.0, 21.8, 22.5, 23.1}\n\n\nSyntaktisch erkennen Sie das Set an den geschweiften Klammern {}. Ein Set erlaubt alle bekannten Mengenoperationen, die Sie aus der Mathematik kennen (z.B. Durchschnitt oder Vereinigung). Nehmen wir an, wir wollen überprüfen, ob unser Sensor mit einer anderen Messreihe gemeinsame Werte hat. Hierfür können wir ganz einfach die Schnittmenge aus beiden Mengen untersuchen:\n\nsecond_temperatures = [22.0, 23.1, 25.0, 22.4, 20.8]\nsecond_set = set(second_temperatures)\nintersection = unique_values.intersection(second_set)\nprint(\"Gemeinsame Werte: \", intersection)\n\nGemeinsame Werte:  {23.1}\n\n\nDie Abfrage mit dem Operator in ist übrigens bei Sets viel effizienter als bei Listen. Das liegt an einem Trick: Zu jedem Element eines Sets berechnet Python einen sog. “Hash-Wert”, der angibt, wo das Element im Speicher liegt. Fragt man, ob ein Element im Set liegt, muss Python nur den Hash-Wert für dieses Element berechnen und checken, ob der entsprechende Speicherplatz zum Set gehört. Daher ist der Aufwand - anders als bei Listen - unabhängig von der Größe des Sets!\n\n\n\n\n\n\nWie initialisiert man ein Set?\n\n\n\nEs gibt mehrere Möglichkeiten, ein neues Set anzulegen - leer oder mit Inhalt:\n\nLeere Initialisierung: set() (Achtung: leere geschweifte Klammern initialisieren ein Dictionary und kein Set!)\nMit Werten: {1, 2, 3}\nAus anderen Datenstrukturen: set(x), wobei x einen String, eine Liste, ein Tuple oder ein Dictionary referenzieren kann. Im Falle vom String erhält man beispielsweise die Menge der Zeichen (Duplikate werden entfernt!), im Falle des Dictionaries die Menge Schlüssel.\n\n\n\n\n\nÜbungen:\n\nErstellen Sie eine eigene Liste mit fünf Messwerten. Erweitern Sie Ihre Liste durch append() auf insgesamt 8 Elemente.\nGeben Sie mithilfe des Slicing-Operators folgende Messwerte aus: a) die ersten drei, b) jeden zweiten, c) alle zwischen dem 3. und 7. Messwert (ohne den 3. und ohne den 7. Messwert selbst) d) die letzten drei.\nFinden Sie den größten und den kleinsten Wert Ihrer Messreihe.\nSortieren Sie alle Messwerte der Größe nach von klein nach groß. Finden Sie auch heraus, wie Sie die umgekehrte Sortierung erhalten (also vom größten zum kleinsten Wert).\n\nReduzieren Sie Ihre Datenreihe auf ein Set, welches nur einzigartige Messwerte enthält.\n\n\n\nLösungsvarianten für die umgekehrte Sortierung in Aufgabe 4:\n\n\nCode\n# Variante 1\ndata = [1,3,5,2,3,4,0,-6]\ndata.sort(reverse=True)\nprint(data)\n\n# Variante 2\ndata = [1,3,5,2,3,4,0,-6]\nsorted_data = sorted(data, reverse=True)\nprint(sorted_data)\n\n# Variante 3\ndata = [1,3,5,2,3,4,0,-6]\nsorted_data = sorted(data)\nsorted_data.reverse()\nprint(sorted_data)\n\n# Variante 4\ndata = [1,3,5,2,3,4,0,-6]\nreverse_sorted_data = sorted(data)[::-1]\nprint(reverse_sorted_data)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#hinzufügen-von-zeitstempeln-anwendung-des-dictionaries",
    "href": "notebooks/6-sequences.html#hinzufügen-von-zeitstempeln-anwendung-des-dictionaries",
    "title": "8  Datenstrukturen in Python",
    "section": "8.3 Hinzufügen von Zeitstempeln – Anwendung des Dictionaries",
    "text": "8.3 Hinzufügen von Zeitstempeln – Anwendung des Dictionaries\nFür eine präzisere Darstellung ergänzen wir die Daten um Zeitstempel. Wir wären gerne in der Lage, folgende Frage zu beantworten: “Wie war die Temperatur am Tag xy zum Zeitpunkt z?”.\nHierzu speichern wir die Temperaturen als Werte (values) und die Zeitpunkte als Schlüssel (keys) in einem Dictionary. Bei einem Dictionary greift man über einen eindeutigen Schlüssel auf das entsprechende Element zu. Es bedarf keiner komplexen Suche nach dem passenden Element etc. Wir demonstrieren die Anwendung:\n\n# Dictionary für Zeitstempel und Temperaturen\ndata = {\n    \"2025-03-23 08:00\": 22.5,\n    \"2025-03-23 09:00\": 23.1,\n    \"2025-03-23 10:00\": 21.8,\n    \"2025-03-23 11:00\": 24.0,\n    \"2025-03-23 12:00\": 22.5,\n}\n\n# neue Werte können jederzeit einzeln hinzugefügt werden: \ndata[\"2025-03-23 13:00\"] = 21.8\n\nprint(data)\n\n{'2025-03-23 08:00': 22.5, '2025-03-23 09:00': 23.1, '2025-03-23 10:00': 21.8, '2025-03-23 11:00': 24.0, '2025-03-23 12:00': 22.5, '2025-03-23 13:00': 21.8}\n\n\nAchten Sie erneut auf die Syntax: Geschweifte Klammern (wie beim Set), aber darin befinden sich Auflistungen von Key:Value. Der Zugriff auf einzelne Elemente ähnelt syntaktisch dem Index-Zugriff bei einer Liste, aber anstelle eines Indizes verwendet man einen Schlüssel:\n\n# Zugriff auf bestimmte Temperatur\nprint(data[\"2025-03-23 09:00\"])\n\n23.1\n\n\nEine Gefahr besteht darin, dass man auf Schlüssel zugreifen möchte, die es nicht gibt. Dann würde das Programm abstürzen! Daher gibt es noch eine sicherere Zugriffsmethode über die Methode .get():\n\nprint(data.get(\"2025-03-23 09:00\"))\nprint(data.get(\"2025-03-23 22:00\")) # Key existiert nicht\nprint(data.get(\"2025-03-23 22:00\", \"Datensatz fehlt\")) # mit Alternativtext\n\n23.1\nNone\nDatensatz fehlt\n\n\n\n\n\n\n\n\nWie initialisiert man ein Dictionary?\n\n\n\nEs gibt mehrere Möglichkeiten, ein neues Dictionary anzulegen - leer oder mit Inhalt:\n\nLeere Initialisierung: {} oder dict()\nMit Schlüssel-Wert-Paaren: {\"a\": 1, \"b\": 2}\nAus einer Liste von Tupeln: dict([(\"a\", 1), (\"b\", 2)])\n\n\n\n\nÜbungen:\n\nErstellen Sie ein Dictionary, das ein einfaches Telefonbuch darstellt. Fügen Sie einige Namen und Telefonnummern hinzu. Greifen Sie auf einige Einträge zu, überschreiben Sie einen Eintrag und versuchen Sie auch auf einen Eintrag zuzugreifen, den es nicht gibt (einmal mit und einmal ohne .get()).\nErstellen Sie ein beliebiges Dictionary und wandeln Sie es anschließend in eine Liste um. Welche Einträge finden Sie in der Liste?\nRecherchieren Sie, wie man in Python echte Zeitstempel erzeugt (Tipp: es gibt eine Bibliothek dafür). Schreiben Sie Code, der alle zwei Minuten einen echten Zeitstempel erzeugt und mit einem simulierten Sensorwert (z.B. einer Zufallszahl) in ein Dictionary schreibt. Programmieren Sie eine Abbruchbedingung nach 10 Minuten und untersuchen Sie das entstandene Dictionary (Tipp: Zum Testen kann man zunächst kürzere Zeitintervalle wählen).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#speichern-einer-zweiten-messgröße---anwendung-des-tupels-engl.-tuple",
    "href": "notebooks/6-sequences.html#speichern-einer-zweiten-messgröße---anwendung-des-tupels-engl.-tuple",
    "title": "8  Datenstrukturen in Python",
    "section": "8.4 Speichern einer zweiten Messgröße - Anwendung des Tupels (engl.: tuple)",
    "text": "8.4 Speichern einer zweiten Messgröße - Anwendung des Tupels (engl.: tuple)\nNeben der Temperatur misst der Sensor nun auch die relative Luftfeuchtigkeit. Wir speichern beide Messwerte als Tupel. Ein Tupel ist ähnlich wie die Liste eine geordnete Kollektion von Elementen, aber mit einem wichtigen Unterschied: Das Tupel ist im Gegensatz zur Liste unveränderlich. Man kann weder Elemente hinzufügen, noch entfernen oder überschreiben! Diese Einschränkungen machen das Tupel zu einem sicheren Datenformat, welches außerdem weniger Speicher verbraucht als die Liste. Syntaktisch erkennt man das Tupel meistens an den runden Klammern ():\n\nmeasurement = (23.4, 40) # Tupel mit zwei Werten\nprint(measurement)\n\n(23.4, 40)\n\n\nDie Klammern können in diesem Beispiel aber auch weggelassen werden:\n\nmeasurement = 23.4, 40 # ebenfalls ein Tupel mit zwei Werten (Merke: \"das Komma macht das Tupel\")\nprint(measurement)\n\n(23.4, 40)\n\n\nEine Funktion mit mehreren Rückgabewerten liefert ebenfalls ein Tupel:\n\ndef my_function(x, y):\n    return x + y, x - y, x * y\n\nresult = my_function(5, 3)  # Ergebnisse als Tupel speichern\nprint(result)\n\n(8, 2, 15)\n\n\n\n# alternativ: Ergebnisse einzeln speichern\na, b, c = my_function(5, 3)  \nprint(a, b, c)\n\n8 2 15\n\n\nMan kann die Werte eines Tupels über den Indexzugriff auslesen (aber nicht überschreiben!):\n\nprint(\"Temperatur: \", measurement[0])\nprint(\"Luftfeuchtigkeit: \", measurement[1])\n\n#measurement[0] = 25.0 ist nicht erlaubt! Ein Tupel ist unveränderlich!\n\nTemperatur:  23.4\nLuftfeuchtigkeit:  40\n\n\nUnser neues Dictionary sieht jetzt so aus:\n\n# Erweiterung: Values = Tupel aus Temperatur und Luftfeuchtigkeit\ndata = {\n    \"2025-03-23 08:00\": (22.5, 60),\n    \"2025-03-23 09:00\": (23.1, 55),\n    \"2025-03-23 10:00\": (21.8, 58),\n    \"2025-03-23 11:00\": (24.0, 61),\n    \"2025-03-23 12:00\": (22.5, 62)\n}\n\n# neuen Wert hinzufügen\ndata[\"2025-03-23 13:00\"] = (24.0, 58)\n\n# einen Zeitpunkt abfragen\nprint(data.get(\"2025-03-23 10:00\"))\n\n\n(21.8, 58)\n\n\nTatsächlich könnte man die beiden Messwerte natürlich auch als Liste mit zwei Elementen zusammenfassen, aber das Tupel hat in diesem Fall klare Vorteile:\n\nSemantik: Ein Tupel repräsentiert eine feste Kombination von Werten, z. B. Temperatur und Luftfeuchtigkeit, die logisch zusammengehören.\nUnveränderbarkeit: Tupel verhindern unbeabsichtigte Änderungen. (Will man bewusst einen Wert verändern, kann man in eine Liste umwandeln.)\nEffizienz: Tupel benötigen weniger Speicherplatz und werden (etwas) schneller verarbeitet als Listen.\n\n\n\n\n\n\n\nWie initialisiert man ein Tupel?\n\n\n\nEs gibt mehrere Möglichkeiten, ein neues Tupel anzulegen - leer oder mit Inhalt:\n\nLeere Initialisierung: () oder tuple()\nMit Werten: (1, 2, 3)\nOhne Klammern: t = 1, 2, 3 wird automatisch als Tupel interpretiert.\nAchtung Spezialfall - Tupel mit exakt einem Wert: (42,) oder 42, (Merke: Das Komma macht das Tupel, nicht die Klammern!)\nAus anderen Datenstrukturen: tuple(x), wobei x einen String, eine Liste, ein Set oder ein Dictionary referenzieren kann. Im Falle vom String erhält man beispielsweise das Tupel der Zeichen, im Falle des Dictionaries das Tupel der Schlüssel.\n\n\n\n\n\nÜbung:\nErstellen Sie ein Dictionary, das eine Kontaktliste darstellt: Zu jedem Namen speichert es ein Tupel aus Telefonnummer, Geburtsdatum und Adresse. Testen Sie Ihr Dictionary mit einigen Dummy-Einträgen. Lesen Sie dabei die drei Attribute eines Eintrags einzeln aus (wenn Sie beispielsweise nur am Geburtsdatum interessiert sind, wollen Sie nicht die Telefonnummer oder die Adresse ausgeben).\n\nLösung:\n\n\nCode\ncontacts_dict = {}\n# Tupel-Einträge für 3 Dummy-Kontakte:\ncontacts_dict[\"Harry\"] = \"0111-222\", \"1.1.1995\", \"Hogwarts 1\"\ncontacts_dict[\"Hermine\"] = \"0222-1234\", \"3.2.1992\", \"Hogwarts 2\"\ncontacts_dict[\"Ron\"] =\"0311-4321\", \"4.5.1994\", \"Hogwarts 3\"\n#  Hinweis: Auf der rechten Seite können runde Klammern benutzt werden,\n# das ist aber nicht erforderlich. \"Das Komma macht das Tupel!\"\n\n\n# Zugriffe auf die 3 Attribute eines Eintrags erfolgen\n# über den korrekten Index des Tupels:\nprint(\"Rons Geburtstag:\", contacts_dict[\"Ron\"][1])\nprint(\"Rons Adresse:\", contacts_dict[\"Ron\"][2])\nprint(\"Rons Telefonnummer:\", contacts_dict[\"Ron\"][0])",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#daten-mehrerer-sensoren---verschachtelte-dictionaries",
    "href": "notebooks/6-sequences.html#daten-mehrerer-sensoren---verschachtelte-dictionaries",
    "title": "8  Datenstrukturen in Python",
    "section": "8.5 Daten mehrerer Sensoren - verschachtelte Dictionaries",
    "text": "8.5 Daten mehrerer Sensoren - verschachtelte Dictionaries\nStellen Sie sich vor, wir hätten drei anstelle von einem Sensor und wollten die Daten aller Sensoren strukturiert erfassen. Hierzu können wir zwei Dictionaries ineinander verschachteln: Der erste Key ist der Name des Sensors, zugehöriger Value ist ein Dictionary, das wie bisher die Messwerte dieses einen Sensors sammelt (also Zeitstempel als Key, Messwert als Value). Im Code sieht das so aus:\n\n# Verschachtelte Dictionaries für drei Sensoren\ndata = {\n    \"Sensor1\": {\n        \"2025-03-23 08:00\": (22.5, 60),\n        \"2025-03-23 09:00\": (23.1, 55)\n    },\n    \"Sensor2\": {\n        \"2025-03-23 08:00\": (21.8, 57),\n        \"2025-03-23 09:00\": (22.0, 67)\n    },\n    \"Sensor3\": {\n        \"2025-03-23 08:00\": (24.0, 58),\n        \"2025-03-23 09:00\": (23.8, 57)\n    }\n}\n\n# So würde man Messwerte hinzufügen:\ndata[\"Sensor3\"][\"2025-03-23 10:00\"] = (25.2, 62) # Neuer Wert für Sensor 3\n\n\nÜbung:\nErstellen Sie ein verschachteltes Dictionary, das eine Kontaktliste darstellt: Zu jedem Namen speichert es ein weiteres Dictionary mit den Keys \"Telefon\", \"Geburtsdatum\" und \"Adresse\". Testen Sie Ihr Dictionary mit einigen Dummy-Einträgen. Greifen Sie für einen Namen auf jedes der drei Attribute einzeln zu.\n\nLösung:\n\n\nCode\ncontacts_dict = {}\n# Einträge für 3 Dummy-Kontakte:\ncontacts_dict[\"Harry\"] = {\"Telefon\":\"0111-222\", \"Geburtsdatum\":\"1.1.1995\", \"Adresse\":\"Hogwarts 1\"}\ncontacts_dict[\"Hermine\"] = {\"Telefon\":\"0222-1234\", \"Geburtsdatum\":\"3.2.1992\", \"Adresse\":\"Hogwarts 2\"}\ncontacts_dict[\"Ron\"] ={\"Telefon\":\"0311-4321\", \"Geburtsdatum\":\"4.5.1994\", \"Adresse\":\"Hogwarts 3\"}\n\n# Zugriffe:\nprint(\"Hermines Geburtsdatum:\", contacts_dict[\"Hermine\"][\"Geburtsdatum\"])\nprint(\"Hermines Adresse:\", contacts_dict[\"Hermine\"][\"Adresse\"])\nprint(\"Hermines Telefonnummer:\", contacts_dict[\"Hermine\"][\"Telefon\"])",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#exkurs-mutable-und-immutable-datentypen-in-python",
    "href": "notebooks/6-sequences.html#exkurs-mutable-und-immutable-datentypen-in-python",
    "title": "8  Datenstrukturen in Python",
    "section": "8.6 Exkurs: Mutable und immutable Datentypen in Python",
    "text": "8.6 Exkurs: Mutable und immutable Datentypen in Python\nPython unterscheidet zwischen immutable (unveränderlichen) und mutable (veränderlichen) Datentypen. Diese Begriffe beziehen sich auf Instanzen eines bestimmten Datentyps:\n\nWenn eine Instanz immutable ist, kann sich ihr Wert nie verändern! Python wird deshalb denselben Wert nicht mehrmals speichern, sondern genau einmal. Wenn der Wert einer Variable, die auf eine immutable Instanz zeigt, sich verändert, zeigt die Variable hinterher auf eine andere Instanz! Integers, Floats, Bools, Strings und Tuples sind in Python immutable.\nAnders bei den mutable Datentypen: Hier kann die Instanz verändert werden. Dies führt zu Seiteneffekten, wenn mehrere Variablen dieselbe Instanz referenzieren. Listen, Dictionaries und Sets sind mutable.\n\nVielleicht können Sie jetzt schon ahnen, dass diese Unterschiede zu ungewolltem Verhalten führen können, wenn man sich ihrer nicht bewusst ist. Bei Unsicherheiten können Sie die Identitäten abfragen. Es gibt aber noch eine direktere Möglichkeit, nämlich den is-Operator: Er liefert True, wenn zwei Variablen auf dieselbe Instanz zeigen:\n\nmy_shopping_list = ['apples', 'oranges', 'paper']\nyour_shopping_list = my_shopping_list\n\n# Mit is auf identische \n# Instanzen prüfen:\nmy_shopping_list is your_shopping_list \n\nTrue\n\n\nWenn die Instanz in diesem Beispiel über eine der beiden Referenzen geändert wird, hat das auch Auswirkungen auf die zweite Referenz:\nmy_shopping_list.append(‘shoes’) # Instanz verändert sich! print(your_shopping_list)\nSeiteneffekte können auch durch den Aufruf von Funktionen auftreten: Wir übergeben an Funktionen eine Referenz auf eine Instanz. Wenn die Instanz mutable ist, kann die Funktion die Instanz verändern! Hierzu eine Demo:\n\ndef append_a(l:list, a:int):\n    l.append(a)\n\nmy_list = [1, 2, 3]\nappend_a(my_list, 100)\n\nprint(my_list)  # my_list wurde verändert\n\n[1, 2, 3, 100]\n\n\nIn diesem Beispiel gibt es zwei Referenzen auf ein veränderliche Instanz: l im lokalen Scope der Funktion und my_list im globalen Scope. Beide sehen die Änderung, die durch .append(...) hervorgerufen wird!\nBesonders überraschend ist vielleicht das folgende Beispiel:\n\ndef append_a_to_global_list(a:int):\n    my_list.append(a) # my_list wird über die LEGB-Rule im globalen Namespace gefunden\n\nmy_list = [1, 2, 3]\nappend_a_to_global_list(100)\n\nprint(my_list)  # my_list wurde verändert\n\n[1, 2, 3, 100]\n\n\nWundern Sie sich, dass wir das Keyword global nicht gebraucht haben? Der Grund ist einfach: In der Funktion wurde keine neue Zuweisung an my_list vorgenommen. Stattdessen haben wir lediglich die bereits existierende Instanz verändert – und das funktioniert nur bei veränderbaren (mutable) Datentypen. Das Keyword global wäre nur dann erforderlich gewesen, wenn wir my_list innerhalb der Funktion eine neue Instanz zugewiesen hätten, also z. B. mit my_list = [4, 5, 6]. In diesem Fall müssten wir – wie bekannt – mit global my_list deutlich machen, dass sich die Zuweisung auf die globale Variable beziehen soll (und nicht nur auf eine lokale im Namespace der Funktion).\nAbschließender Hinweis: Behalten Sie stets im Hinterkopf, dass es bei den Begriffen mutable bzw. immutable immer um die Instanz geht, nicht um die Referenz. Natürlich können Sie eine Variable, die auf eine immutable Instanz zeigt, ändern. Dann zeigt sie aber auf eine andere Instanz.\n\n\n\n\n\n\nWie ist das in anderen Sprachen?\n\n\n\nDas Konzept der Immutability, wie wir es in Python kennengelernt haben, existiert nicht genauso in anderen Sprachen. Auch der prinzipielle Umgang mit Speicher unterscheidet sich teils grundlegend. Sprachen wie Java oder C# sind Python ähnlicher, da sie Instanzen und Referenzen verwenden und teilweise Immutability durch Sprachmechanismen unterstützen, wie z. B. immutable Strings oder Klassen.\nIn C hingegen gibt es keine Sprachmechanismen für immutable Instanzen. Stattdessen operiert C als Low-Level-Sprache direkt mit Speicheradressen. Werte können überschrieben und mehrere Pointer auf denselben Speicherbereich angelegt werden, die den Wert dort verändern können. Es liegt in der Verantwortung der Programmierer, Speicher sicher zu verwalten, was anfällig für Fehler macht – etwa Speicherlecks oder unvorhergesehene Zustandsänderungen. Die Freiheit von C ist jedoch unverzichtbar, wenn es um Hardware-nahe Programmierung, Performance-Optimierung oder ressourcensparende Anwendungen geht.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#sicheres-kopieren-von-listen",
    "href": "notebooks/6-sequences.html#sicheres-kopieren-von-listen",
    "title": "8  Datenstrukturen in Python",
    "section": "8.7 Sicheres Kopieren von Listen",
    "text": "8.7 Sicheres Kopieren von Listen\nSeien Sie immer auf der Hut, wenn Sie eine Liste kopieren wollen. Da sie zu den mutable Datentypen gehört, erzeugen Sie schnell unbeabsichtigt nur eine zweite Referenz auf das Original mit den genannten Seiteneffekten als Gefahr. Eine einfache Möglichkeit, dies zu umgehen, ist eine Kopie mithilfe des Slicing-Operators:\n\noriginal = [\"apples\", \"oranges\", \"books\"]\n\n# Zuweisung erzeugt nur eine zweite Referenz:\nsecond_reference = original  # keine Kopie! \n\n# mit Slicing eine Kopie erzeugen:\ncopy = original[:] \n\n# Wir zeigen, dass copy keine Seiteneffekte hat: \ncopy.append(\"bananas\")\nprint(\"Original: \", original) # unverändert\nprint(\"Kopie: \", copy)\n\nOriginal:  ['apples', 'oranges', 'books']\nKopie:  ['apples', 'oranges', 'books', 'bananas']\n\n\nEs gibt allerdings noch eine Diffizilität: Der Trick mit dem Slicing-Operator funktioniert nur so lange, wie die Elemente der Liste immutable sind. Sollten sich darunter aber mutable Datentypen befinden, kann es immer noch zu Seiteneffekten kommen. Wir haben zwar eine Kopie erstellt, allerdings nur eine sog. “flache Kopie”. Um alle Mehrfachreferenzen aufzulösen und eine völlig unabhängige Kopie zu erhalten, braucht es eine sog. “tiefe Kopie”. Hierfür gibt es bestimmte Algorithmen aus dem Modul copy:\n\nimport copy\noriginal = [[1,2],3,4] # Liste mit einem mutable Element\n\ncopy1 = original[:] # flache Kopie\ncopy2 = copy.deepcopy(original) # tiefe Kopie\n\n# Demo der Seiteneffekte:\n# Das mutable erste Element wird in den Kopien verändert\ncopy1[0].append(3) \ncopy2[0].append(100)\n\nprint(\"Original: \", original)\nprint(\"flache Kopie: \", copy1)\nprint(\"tiefe Kopie: \", copy2)\n\nOriginal:  [[1, 2, 3], 3, 4]\nflache Kopie:  [[1, 2, 3], 3, 4]\ntiefe Kopie:  [[1, 2, 100], 3, 4]\n\n\nDie Änderungen an der flachen Kopie hatten noch Auswirkungen auf das Original, weil beide die Referenz auf das erste Element teilten, welches mutable war. Nur bei der tiefen Kopie handelt es sich um eine völlig autarke Kopie, die nichts mehr mit dem Original gemein hat.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/6-sequences.html#list-comprehensions",
    "href": "notebooks/6-sequences.html#list-comprehensions",
    "title": "8  Datenstrukturen in Python",
    "section": "8.8 List Comprehensions",
    "text": "8.8 List Comprehensions\nIn Python gibt es eine elegante und kompakte Möglichkeit, Listen zu erzeugen: die sogenannte List Comprehension.\nStatt mit einer Schleife umständlich Elemente einer Liste hinzuzufügen, können wir in einer einzigen Zeile eine neue Liste erstellen. Das macht den Code kürzer, lesbarer und oft schneller.\n\nSyntax\nDie allgemeine Syntax sieht so aus:\n[ Ausdruck for Element in Sequenz ]\n\nSequenz: Etwas, über das iteriert werden kann (z.B. eine Liste, ein String, ein Bereich range()), wie wir es schon von der For-Schleife kennen.\nElement: Eine Variable, die nacheinander die Werte aus der Sequenz annimmt.\nAusdruck: Ein Ausdruck, der für jedes Element ausgewertet wird. Dieser wird dann der neuen Liste hinzugefügt.\n\nDer hintere Teil der List Comprehension verhält sich ganz analog zur For-Schleife, neu ist der Ausdruck. Ein Beispiel macht alles verständlicher:\n\n# Beispiel: Liste aller Quadratzahlen der Zahlen von 0 bis 9\nsquares = [x**2 for x in range(10)]\nprint(squares)\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nAnalysieren wir das Beispiel:\n\nSequenz: range(10).\nElement: x, eine eigene Bezeichnung für die Elemente der Sequenz.\nAusdruck: x**2, jedes x aus der genannten Sequenz soll quadriert werden.\n\nDie Syntax kann noch um eine if-Bedingung am Ende erweitert werden:\n[ Ausdruck for Element in Sequenz if Bedingung ]\n\nBedingung am Ende der List Comprehension: Nur Elemente, die die Bedingung erfüllen, werden berücksichtigt.\n\n\n# Ein Beispiel: Liste aller Quadratzahlen der geraden Zahlen von 0 bis 9\nsquares2 = [x**2 for x in range(10) if x % 2 == 0]\nprint(squares2)\n\n[0, 4, 16, 36, 64]\n\n\nDarüber hinaus können auch if- und else-Bedingungen vor dem for verwendet werden, um alternative Ausdrücke zu verwenden:\n\n# Mit if-else vor dem for\nresult = [x if x % 2 == 0 else -x for x in range(10)]\nprint(result)\n\n[0, -1, 2, -3, 4, -5, 6, -7, 8, -9]\n\n\nJe komplexer eine List Comprehension wird, desto schwieriger wird sie allerdings zu lesen und zu verstehen – und das kann schnell die Vorteile zunichtemachen, die man eigentlich durch die kürzere Schreibweise erreichen wollte.\n\n\nBeispiele aus der Ingenieurpraxis\nList Comprehensions sind sehr praktisch, um Messwerte von einer Einheit in eine andere umzurechnen:\n\nvalues_in_cm = [100, 250, 430, 125]\nvalues_in_m = [x / 100 for x in values_in_cm]\nprint(values_in_m)\n\n[1.0, 2.5, 4.3, 1.25]\n\n\n\ntemperatures_celsius = [0, 20, 37, 100]\ntemperatures_fahrenheit = [t * 9/5 + 32 for t in temperatures_celsius]\nprint(temperatures_fahrenheit)\n\n[32.0, 68.0, 98.6, 212.0]\n\n\nList Comprehensions werden auch gerne zum Filtern von Messwerten verwendet, wie das folgende Beispiel zeigt:\n\nvoltages = [3.3, 5.1, 2.5, 4.8, 2.1, 7.2, 0.7]\nhigh_voltages = [u for u in voltages if u &gt; 5]  # 5 V ist hier ein oberer Grenzwert \nlow_voltages = [u for u in voltages if u &lt;= 5]\nprint(\"Oberhalb des Grenzwertes:\", high_voltages)\nprint(\"Gültige Messwerte:\", low_voltages) \n\nOberhalb des Grenzwertes: [5.1, 7.2]\nGültige Messwerte: [3.3, 2.5, 4.8, 2.1, 0.7]\n\n\n\n# Alternativ könnte man die zu hohen Werte \"abschneiden\":\nvoltages = [3.3, 5.1, 2.5, 4.8, 2.1, 7.2, 0.7]\nlimited_voltages = [u if u &lt;= 5 else 5 for u in voltages]  # 5 V ist hier ein oberer Grenzwert \nprint(\"Bereinigte Messwerte:\", limited_voltages) \n\nBereinigte Messwerte: [3.3, 5, 2.5, 4.8, 2.1, 5, 0.7]\n\n\n\nÜbungen: Gegeben ist eine Liste, die Geschwindigkeitsmessungen in der Einheit km/h beinhaltet: speeds = [30.0, 50.7, 45.3, 77.4, 100.9]\n\nErstellen Sie mit einer List Comprehension eine Liste, die die Geschwindigkeiten in der Einheit m/s, gerundet auf zwei Nachkommastellen, beinhaltet.\nPassen Sie Ihre List Comprehension so an, dass nur Werte oberhalb 50 km/h umgerechnet und in die neue Liste aufgenommen werden.\n\nGegeben ist eine Liste von Fahrten, jeweils als Tupel (Strecke in km, Zeit in Minuten): trips = [(10, 30), (25, 60), (20, 20), (5, 10)].\n\nErstellen Sie mit einer List Comprehension eine Liste der jeweiligen Durchschnittsgeschwindigkeiten in der Einheit km/h.\nErstellen Sie mit einer List Comprehension eine Liste aus Strings mit den Labeln “langsam” (für Fahrten mit einer Durchschnittsgeschwindigkeit unter 50 km/h) und “schnell” (für alle anderen).\n\n\n\n\nCode\nspeeds = [30.0, 50.7, 45.3, 77.4, 100.9]\n\n# Übung 1: Einheit umrechnen nach km/h\n# Umrechnungsfaktor ist *1000/3600 (oder dividieren durch 3.6)\n# runden auf 2 Nachkommastellen: mit round(..., 2)\nspeeds_ms = [round(kmh * 1000/3600, 2) for kmh in speeds]\nprint(\"Ergebnis Übung 1:\", speeds_ms)\n\n# Übung 2: nur für solche mit kmh &gt; 50\nfast_speeds_ms = [round(kmh * 1000/3600, 2) for kmh in speeds if kmh &gt; 50]\nprint(\"Ergebnis Übung 2:\", fast_speeds_ms)\n\n# Übung 3\ntrips = [(10, 30), (25, 60), (20, 20), (5, 10)]\n# gesuchte Durchschnittsgeschwindigkeit: Strecke in km / Zeit in h\n# Die Zeiten müssen von min in h umgerechnet werden: durch 60 dividieren  \naverage_speeds = [trip[0]/(trip[1]/60) for trip in trips]\nprint(\"Ergebnis Übung 3:\", average_speeds)\n\n# Übung 4\ntrip_labels = [\"langsam\" if v &lt; 50 else \"schnell\" for v in average_speeds]\nprint(\"Ergebnis Übung 4:\", trip_labels)\n\n\n\n\nPerformance\nList Comprehensions sind in der Regel schneller als eine klassische Schleife mit append(), da sie in Python auf C-Ebene optimiert sind. Das bedeutet, viele Schritte (wie Funktionsaufrufe oder das Anhängen an eine Liste) passieren effizient im Hintergrund. Eine kleine Demo:\n\nimport time  # zum Messen von Zeiten\n\n# Klassische For-Loop mit append\nstart = time.time()\n\nresult = []\nfor i in range(10000000):\n    if i % 2 == 0:\n        result.append(i * 2)\nend = time.time()\n\nprint(f\"For-Loop Dauer: {round(end - start,2)} Sekunden\")\n\n# List Comprehension mit demselben Ergebnis\n\nstart = time.time()\n\nresult = [i * 2 for i in range(10000000) if i % 2 == 0]\n\nend = time.time()\n\nprint(f\"List Comprehension Dauer: {round(end - start,2)} Sekunden\")\n\nFor-Loop Dauer: 2.12 Sekunden\nList Comprehension Dauer: 1.01 Sekunden\n\n\nDie Zeiten variieren natürlich und werden auf Ihrem System andere Werte annehmen. Probieren Sie es aus!\nOb ein Code, wie in diesem Beispiel, eine Sekunde oder zwei Sekunden benötigt, spielt natürlich keine große Rolle. Der Performance-Unterschied wird nur relevant, wenn sie enorm große Mengen an Daten verarbeiten müssen.\n\n\nFazit für die Praxis\nList Comprehensions sind oft eine gute Wahl, wenn eine neue Liste erzeugt werden soll. Sie führen in der Regel zu kürzerem und verständlicherem Code. Allerdings sollte man sie nur verwenden, wenn Bedingungen und Ausdrücke einfach genug sind, um die Lesbarkeit nicht zu gefährden. Bei komplexerer Logik ist eine klassische Schleife oft die bessere Wahl, um die Wartbarkeit zu sichern. Sollte Performance eine entscheidende Rolle spielen, kann es sich lohnen, größere Schleifen in eine List Comprehension umzuschreiben – vorausgesetzt, die Lesbarkeit bleibt erhalten.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenstrukturen in Python</span>"
    ]
  },
  {
    "objectID": "notebooks/7-bibs.html",
    "href": "notebooks/7-bibs.html",
    "title": "9  Die Verwendung von Bibliotheken",
    "section": "",
    "text": "9.1 Einführung\nIn diesem Kapitel führen wir kurz in die Verwendung von Bibliotheken ein. Es gibt unzählige praktische Bibliotheken, die Entwicklerinnen und Entwicklern auf der ganzen Welt das Leben leichter machen. Natürlich können wir im Rahmen dieser Einführung nur einen kurzen Einblick geben: Wir erklären allgemein, was eine Bibliothek ist, wie man sie verwendet und installiert, und werfen dann einen exemplarischen Blick auf bekannte Bibliotheken, die Ihnen mit hoher Wahrscheinlichkeit in Ihren Projekten begegnen und helfen werden.\nEine Bibliothek ist eine Sammlung von fertigem Code, die Sie in Ihrem Programm nutzen können. So müssen Sie das Rad nicht immer wieder neu erfinden! Außerdem sind Bibliotheken oft hochoptimiert, teilweise “unter der Haube” in anderen Programmiersprachen geschrieben, um eine bessere Performance zu erzielen (z. B. in C oder C++).\nBevor wir eine Bibliothek in unserem Programm verwenden können, müssen wir Sie importieren:\nimport math  # importiert die Bibliothek math \n\n# jetzt kann math genutzt werden und das geht so:\n\nprint(math.sqrt(256))  # Wurzel ziehen\nprint(math.cos(2*math.pi))  # Trigonometrie\nprint(math.factorial(5))  # Fakultät\n\n# vieles mehr ist möglich mit math ...\n\n16.0\n1.0\n120\nWie Sie am Beispiel erkannt haben, wird der Name der Bibliothek den Funktionen vorangestellt. Über den . greifen Sie auf die Inhalte der Bibliothek zu. Man kann auch nur ausgewählte Elemente der Bibliothek importieren:\nfrom math import cos, sin, pi  # nur die genannten werden importiert\n\nprint(cos(2*pi) + sin(2*pi))  # das Präfix math fällt weg\n\n0.9999999999999998\nTipp: Ich bevorzuge es, zu sehen, aus welcher Bibliothek die Funktionen stammen. So werden auch potenzielle Konflikte mit eigenen Bezeichnungen vermieden. Daher nutze ich meistens die obere Variante.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Die Verwendung von Bibliotheken</span>"
    ]
  },
  {
    "objectID": "notebooks/7-bibs.html#einführung",
    "href": "notebooks/7-bibs.html#einführung",
    "title": "9  Die Verwendung von Bibliotheken",
    "section": "",
    "text": "Aliase\nEs ist möglich und auch üblich, einer Bibliothek beim Importieren einen Kurznamen (sog. Alias) zu geben. Wir könnten z.B. die math-Bibliothek mit m abkürzen:\n\nimport math as m  # importiert math mit Alias m\n\n# Verwendung:\nprint(m.sqrt(225), m.cos(m.pi), m.factorial(3))\n\n15.0 -1.0 6\n\n\nHäufig verwendete Bibliotheken haben mittlerweile Standard-Aliase, die so gut wie immer verwendet werden. Wir listen einige berühmte Beispiele auf:\n\n\n\n\n\n\n\n\n\nBibliothek\nTypischer Alias\nImport\nAnwendungsbereich\n\n\n\n\nnumpy\nnp\nimport numpy as np\nNumerische Mathematik\n\n\nmatplotlib.pyplot\nplt\nimport matplotlib.pyplot as plt\nVisualisierung / Diagramme\n\n\npandas\npd\nimport pandas as pd\nDatenanalyse und Tabellenverarbeitung\n\n\nseaborn\nsns\nimport seaborn as sns\nStatistische Datenvisualisierung\n\n\ntensorflow\ntf\nimport tensorflow as tf\nMachinelles Lernen / Neuronale Netze\n\n\n\n\n\nInstallation\nNicht alle Bibliotheken sind auf unserem System vorinstalliert, sondern müssen bei Bedarf erst heruntergeladen und installiert werden. Das geht zum Glück mithilfe von Paketverwaltungssoftware wie pip oder anaconda sehr einfach. Nehmen wir an, wir möchten die Bibliothek requests (für http-Requests) installieren:\n\nMit pip (für Standard-Python ohne Anaconda)\nIm Terminal oder in der Konsole eingeben:\npip install requests\nMit Anaconda\nStarten Sie Anaconda Prompt und tippen Sie ein:\nconda install requests\nÜber die grafische Oberfläche von Anaconda\n\nStarten Sie Anaconda Navigator.\nWählen Sie „Environments“ und setzen Sie den Filter auf “not installed” oder “all”.\nVerwenden Sie “Search Packages”, um das gewünschte Paket zu finden (z. B. requests).\nHäkchen setzen und „Apply“ klicken.\n\n\n\n\nKurze Begriffsklärung: Modul, Paket, Bibliothek\nDiese drei Begriffe gehen manchmal durcheinander und werden nicht immer sauber voneinander getrennt:\n\nModul:\nEine einzelne Datei mit Python-Code (.py), die Funktionen, Klassen oder Variablen enthält.\nPaket: Ein strukturierter Ordner mit mehreren Modulen.\nBibliothek: Ein allgemeiner Begriff für Module und Pakete, die bestimmte Aufgaben lösen (z. B. Datenanalyse).\n\nBei der praktischen Verwendung von Bibliotheken ist die Unterscheidung in der Regel nicht so wichtig: Wir importieren math (ein Modul) oder pandas (ein Paket), um Probleme zu lösen, die uns in unseren Projekten begegnen. Wenn wir dagegen selbst Module oder Bibliotheken für die Community entwicklen möchten, werden die Details natürlich wichtig.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Die Verwendung von Bibliotheken</span>"
    ]
  },
  {
    "objectID": "notebooks/7-bibs.html#numpy",
    "href": "notebooks/7-bibs.html#numpy",
    "title": "9  Die Verwendung von Bibliotheken",
    "section": "9.2 NumPy",
    "text": "9.2 NumPy\n\nÜberblick\nNumPy (Numerical Python) ist eine der zentralen Bibliotheken im wissenschaftlichen Rechnen mit Python. Sie bietet leistungsfähige Datenstrukturen, insbesondere das n-dimensionale Arrays, und eine breite Palette mathematischer Funktionen zur effizienten Verarbeitung großer Datenmengen. Für Ingenieurinnen und Ingenieure ist NumPy besonders wertvoll, da es numerische Simulationen, Datenanalyse und Algorithmenentwicklung deutlich vereinfacht und beschleunigt. Damit es keine Missverständnisse gibt: Numerisch bedeutet, dass wir in Numpy immer mit konkreten Zahlen rechnen und solche als Ergebnisse erhalten. Das Gegenteil wären symbolische Berechnungen, bei denen es darum geht eine Formel als Lösung für ein Problem zu finden. Hierfür gibt es übrigens auch eine Python-Bibliothek: SymPy (Symbolic Python).\nDrei Highlights von NumPy für die Ingenieurpraxis:\n\nEffiziente Matrixoperationen: Lineare Algebra ist das Rückgrat vieler ingenieurtechnischer Berechnungen, z. B. in der Statik, Regelungstechnik oder Signalverarbeitung. NumPy ermöglicht schnelle und speichereffiziente Operationen auf Matrizen – inklusive Inversion, Eigenwertberechnung oder Lösung linearer Gleichungssysteme.\nSchnelle Datenverarbeitung: Dank einer optimierten Implementierung (die Bibliothek wurde in C geschrieben!) ist NumPy um ein Vielfaches schneller als Standard-Python-Schleifen. Das ist ideal für Messdatenanalysen oder Simulationen, bei denen Zeit eine kritische Rolle spielt.\nNahtlose Integration mit anderen Tools: NumPy bildet die Grundlage für viele andere wissenschaftliche Bibliotheken wie SciPy, pandas oder Matplotlib. So lässt es sich leicht in bestehende Arbeitsabläufe integrieren – vom Datenimport bis zur Visualisierung der Ergebnisse.\n\n\n\nDemo: Matrixoperationen mit Arrays\n\nimport numpy as np\n\n# 3x3 Matrix als np.array\n# np.arrays werden aus Listen erzeugt:\nA = np.array([[2, 1, 3],\n              [0, -1, 4],\n              [5, 2, 0]])\n\n# ein Vektor\nb = np.array([1, 2, 3])\n\n# Matrix mal Vektor v = A * b:\nv = np.dot(A, b)\n\n# WARNUNG: Es ist wichtig, np.dot zu verwenden und nicht *\n# Letzteres führt kein Vektorprodukt, sondern eine \n# elementweise Multiplikation durch! \n\nprint(\"A * b = \",v)\n\nA * b =  [13 10  9]\n\n\nWir können viele Operationen aus der linearen Algebra direkt ausführen:\n\nA.T  # liefert die transponierte Matrix\n# alternativ: np.transpose(A)\n\narray([[ 2,  0,  5],\n       [ 1, -1,  2],\n       [ 3,  4,  0]])\n\n\n\nnp.linalg.eigvals(A)  # liefert die Eigenwerte von A\n\narray([ 5.83891641, -0.80708431, -4.0318321 ])\n\n\n\nnp.linalg.eig(A)  # liefert Eigenwerte und Eigenvektoren von A\n\nEigResult(eigenvalues=array([ 5.83891641, -0.80708431, -4.0318321 ]), eigenvectors=array([[-0.62757479, -0.37722073, -0.16597401],\n       [-0.39307122,  0.92504816, -0.78589196],\n       [-0.67204531,  0.04461408,  0.59567311]]))\n\n\n\nx = np.linalg.solve(A, b)  # löst das lineare Gleichungssystem: A*x = b\nprint(x)\n\n[ 1.31578947 -1.78947368  0.05263158]\n\n\nÜberprüfen wir das Ergebnis:\n\nprint(np.dot(A, x), \"Zum Vergleich: \", b)\n\n[1. 2. 3.] Zum Vergleich:  [1 2 3]\n\n\n\n\n\n\n\n\nNumpy-Arrays\n\n\n\nDie Arrays von Numpy sind ein hochoptimierter Datentyp für numerische Berechnungen. Anders als bei Listen können Sie innerhalb eines Arrays nicht mehr Datentypen wild mischen, sondern müssen konsequent einen Datentyp für alle Einträge verwenden, meistens float oder int. Zwei Besonderheiten von Numpy-Arrays möchten wir hier herausstellen:\n\nVektorisierte Operationen: NumPy bietet vektorisierten Code, d. h. mathematische Operationen wie Addition, Subtraktion, Multiplikation auf Arrays werden auf allen Elementen gleichzeitig angewendet. Dies ist viel schneller als manuelle Schleifen über Listen!\nBroadcasting: NumPy unterstützt Broadcasting, sodass auch Arrays unterschiedlicher Formen miteinander rechnen können, ohne dass wir diese mühsam aneinander anpassen müssen.\n\n\n\n\n\nDemo: Vektorisierung\nWir erstellen zunächst ein Array mit \\(x\\)-Werten, an denen wir eine Funktion auswerten wollen:\n\nx_values = np.array(range(10))  # Array mit den x-Werten 0, 1, 2, ..., 9  \nprint(x_values)\n\n[0 1 2 3 4 5 6 7 8 9]\n\n\nAn diesen Stellen sollen Funktionswerte der folgenden Funktion berechnet werden:\\(f(x) = 3\\,x^3 - x^2 + 2\\,x + 1\\). Vektorisierung bedeutet, dass wir die Rechenoperationen mit dem Array x_values durchführen können und NumPy diese elementweise durchführt. Das ist kinderleicht:\n\nf_values = 3 * x_values**3 - x_values**2 + 2 * x_values + 1  # berechnet f(x) für jeden x-Wert\nprint(f_values) # das Ergebnis ist wieder ein Array!\n\n[   1    5   25   79  185  361  625  995 1489 2125]\n\n\nWir benötigen keine Schleife und die Operationen werden sogar optimiert, also sehr schnell, ausgeführt. In der numerischen Mathematik kommen solche Operationen sehr häufig vor. Im folgenden Abschnitt werden wir sehen, wie man Vektorisierung verwendet, um mit wenigen Zeilen einen Funktionsgraphen zu zeichnen.\nWir können natürlich auch komplexere mathematische Funktionen berechnen. Das wollen wir an \\(g(x) =\\frac{1}{2} \\sqrt{x}\\) und \\(h(x) = x\\, e^{x^2}\\) demonstrieren:\n\ng_values = 1/2 * np.sqrt(x_values)  # berechnet Funktionswerte von g an den x-Stellen\nprint(g_values)\n\n[0.         0.5        0.70710678 0.8660254  1.         1.11803399\n 1.22474487 1.32287566 1.41421356 1.5       ]\n\n\n\nh_values = x_values * np.exp(x_values**2) # berechnet Funktionswerte von h an den x-Stellen\nprint(h_values)\n\n[0.00000000e+00 2.71828183e+00 1.09196300e+02 2.43092518e+04\n 3.55444421e+07 3.60024497e+11 2.58673893e+16 1.33514260e+22\n 4.98811926e+28 1.35548758e+36]\n\n\nWichtig ist, dass wir in den beiden letzten Beispielen die Mathe-Funktionen aus NumPy verwendet haben, also np.sqrt(...) bzw. np.exp(...). Andere Mathebibliotheken (z.B. math) sind nicht für vektorisierte Operationen auf NumPy-Arrays ausgelegt.\n\n\nDemo: Broadcasting\nEin Beispiel zu Broadcasting:\n\nA = np.array([[1, 0, 0],\n              [0, 2, 0],\n              [0, 0, 3]])\n\nv = np.array([1, 2, 3])\n\nB = A + v  # das passt eigentlich nicht!\n\nDie letzte Zeile führt überraschenderweise nicht zu einem Programmfehler, obwohl die Dimensionen von A und v überhaupt nicht zusammenpassen. In solchen Fällen geschieht Broadcasting: “Was nicht passt, wird passend gemacht (falls möglich)!”. Schauen wir uns das Ergebnis genauer an:\n\nprint(B)  \n\n[[2 2 3]\n [1 4 3]\n [1 2 6]]\n\n\nWir sehen: Der Vektor v wurde zeilenweise addiert. Für das Broadcasting gibt es ein klar definiertes Vorgehen, wie Arrays aneinander angeglichen werden und in welchen Fällen es überhaupt möglich ist. Man muss aufpassen, dass man kein unbeabsichtigtes Broadcasting durchführt und unerwartete Ergebnisse erhält. Aber so tief wollen wir an dieser Stelle nicht einsteigen.\n\n\nlinspace und arange\nDiese beiden Funktionen sind in der Praxis sehr nützlich und werden oft verwendet:\n\n# Mit np.linspace(begin, end, num) erzeugt man einen Array mit Punkten zwischen\n# den Grenzen begin und end (beide eingeschlossen). Es werden insgesamt num \n# Punkte in gleichmäßigen Abständen erzeugt.\n\na = np.linspace(0, 10, 5) # 5 Punkte zwischen 0 und 10\nprint(a)\nb = np.linspace(0, 10, 10) # 10 Punkte\nprint(b)\n\n[ 0.   2.5  5.   7.5 10. ]\n[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n  6.66666667  7.77777778  8.88888889 10.        ]\n\n\n\n# Mit np.arange(begin, end, step) erreichen Sie etwas ähnliches, \n# allerdings geben Sie nicht die Anzahl der Punkte, sondern \n# die Schrittweite step vor. \n\na = np.arange(0, 10, 1)\nprint(a)  # wie Sie sehen, gehört end nicht dazu (analog zur range-Funktion)\n\nb = np.arange(0, 10 + 1.25, 1.25)  # hier stellt man sicher, dass 10 überschritten wird\nprint(b)\n\n[0 1 2 3 4 5 6 7 8 9]\n[ 0.    1.25  2.5   3.75  5.    6.25  7.5   8.75 10.  ]\n\n\nDie beiden Funktionen linspace(...) und arange(...) werden oft zusammen mit Vektorisierung verwendet. Zum Beispiel erstellt man mit linspace(...) einen Array von \\(x\\)-Werten und berechnet dann mithilfe von Vektorisierung die zugehörigen \\(y\\)-Werte einer Funktion. Das könnte so aussehen wie im folgenden Beispiel:\n\nxs = np.linspace(-np.pi, np.pi, 100)  # 100 Punkte zwischen -pi und pi\nys = np.sin(xs)  # Funktionswerte von sin(x) an den zuvor berechneten Stellen\nprint(\"Auswertung an einer Beispielstelle:\")\nprint(\"x =\", round(xs[20],2), \", sin(x)=\", round(ys[20],2))\n\n# Vorschau auf den nächsten Abschnitt: \n# Mit den beiden Arrays xs und ys kann die Funktion geplottet werden. \n\nAuswertung an einer Beispielstelle:\nx = -1.87 , sin(x)= -0.95\n\n\n\nÜbungen:\n\nErzeugen Sie 100 \\(x\\)-Werte zwischen \\(-2\\) und \\(5\\) und berechnen Sie zu jedem dieser Werte den Funktionswert von \\(f(x) = \\frac{e^{-x}}{1 + x^2}\\). Geben Sie exemplarisch den Funktionswert für ein zufällig ausgewähltes \\(x\\) aus (auf zwei Nachkommastellen gerundet)!\nErzeugen Sie einen Array, der 1000 Zeitpunkte zwischen t=0 s und t= 100 s beinhaltet. Ein Körper befinde sich zum Zeitpunkt t=0 an der Position x(0)=0 und bewege sich gleichmäßig mit der Geschwindigkeit v= 2.5 m/s in positive x-Richtung. Erstellen Sie einen Array, der die x-Position zu jedem Zeitpunkt t angibt. Geben Sie die Position zum Zeitpunkt t=100 s aus.\nMultiplizieren Sie zwei 3x3 Matrizen miteinander.\nWie können Sie Broadcasting und transpose kombinieren, um einen Vektor v zu jeder Spalte einer Matrix zu addieren?\n\n\nLösungen:\n\n\nCode\nimport numpy as np\n# Übung 1 \nxs = np.linspace(-2, 5, 100)\nys = np.exp(-xs)/(1 + xs**2)\nprint(f\"Übung 1: f({round(xs[30],2)}) = {round(ys[30],2)}\")\n\n# Übung 2\nts = np.linspace(0,100, 1000)\nxs = 2.5 * ts  # x = velocity * time\nprint(\"\\nÜbung 2:\\nx(t = 100s) =\", xs[-1])\n\n# Übung 3\nA = np.array([[1, 2, 3],\n     [1, 2, 3],\n     [1, 2, 3]])\n\nB = np.ones_like(A)  # erzeugt eine Matrix mit derselben Form wie A, aber mit lauter Einsen\n\nC = np.dot(A, B)\n\nprint(\"\\nÜbung 3:\", \"A =\", A, \"B = \",B, \"A * B = \", C, sep=\"\\n\")\n\n# Übung 4\nA = np.array([[1, 2, 3],\n              [1, 2, 3],\n              [1, 2, 3]])\nv = np.array([-1, 0, -2])  # soll zu jeder Spalte addiert werden\n\n# A wird transponisert und v addiert,\n# dann wird das Ergebnis zurücktransponiert:\n\nresult = (A.T + v).T\n\nprint(\"\\nÜbung 3:\",\"A =\", A,\"v =\",v, \"A + v (spaltenweise)\", result, sep=\"\\n\")",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Die Verwendung von Bibliotheken</span>"
    ]
  },
  {
    "objectID": "notebooks/7-bibs.html#matplotlib",
    "href": "notebooks/7-bibs.html#matplotlib",
    "title": "9  Die Verwendung von Bibliotheken",
    "section": "9.3 Matplotlib",
    "text": "9.3 Matplotlib\nMatplotlib ist die Standard-Bibliothek in Python zum Erstellen von Diagrammen. Der am häufigsten verwendete Teil ist das Untermodul pyplot (eine Schnittstelle, über die das Modul leicht zu bedienen ist), das man fast immer mit dem Alias plt importiert.\n\nimport matplotlib.pyplot as plt  # Standard-Import für matplotlib\n\nMit Matplotlib kann man die unterschiedlichsten Arten von Diagrammen erzeugen. Auch hier können wir nur ein paar exemplarische Beispiele demonstrieren.\n\nEine Funktion plotten\nUm eine Funktion zu plotten, arbeiten wir mit Matplotlib und NumpPy zusammen: NumPy erzeugt die x- und y-Werte, Matplotlib stellt diese in einem einfachen Linienplot dar. Linienplot heißt, dass gerade Linien von Punkt zu Punkt gezogen werden. Wenn es ausreichend viele Punkte sind, entsteht der Eindruck einer glatten Kurve. Los geht’s:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Punkte erzeugen mit Numpy\n\nx_values = np.linspace(0, 50, 100) # 100 Punkte zwischen 0 und 50\ny_values = x_values**2 # Vektorisierung: so einfach rechnet man mit Numpy-Arrays!\n\n# Liniendiagramm erzeugen mit Matplotlib \n\nplt.plot(x_values, y_values)\n\n# Es folgen Einstellungen zur Darstellung (z.B. Beschriftung)\n\nplt.title(\"$y = x^2$\")  # Titel\nplt.xlabel(\"x\")  # Beschriftung x-Achse\nplt.ylabel(\"y\")  # Beschriftung y-Achse\nplt.tight_layout() # optimiert bei Bedarf den Zeichenbereich, damit nix abgeschnitten wird\nplt.grid(True) # zeigt ein Gitter zum einfacheren Ablesen der Werte\n\n# Finally:\n# Der eigentliche Befehl zum Rendern (= Zeichnen).\n\nplt.show()  # öffnet ein Fenster (oder rendert im Notebook) und zeigt den Plot.\n\n# PS: Der Befehl plt.show() wird von Jupyter oft automatisch aufgerufen, an anderer Stelle braucht man\n# ihn aber explizit. Wir schreiben ihn daher immer hin.  \n\n\n\n\n\n\n\n\n\n\nMesswerte in einem Streudiagramm darstellen\n\nimport matplotlib.pyplot as plt\n\n# Messwerte\ndehnung = [0.0, 0.01, 0.02, 0.03, 0.04, 0.05]\nspannung = [0, 100, 190, 270, 330, 360]  # in MPa\n\n# Streudiagramm mit Matplotlib erzeugen\nplt.scatter(dehnung, spannung, color='darkred')\n\n# Einstellungen für die Darstellung:\nplt.title(\"Spannung-Dehnung (Stahlprobe)\")\nplt.xlabel(\"Dehnung (ε)\")\nplt.ylabel(\"Spannung (σ in MPa)\")\nplt.grid(True)\nplt.tight_layout()\n\n# Finally: Rendern\nplt.show()\n\n\n\n\n\n\n\n\nHaben Sie auch sofort den Gedanken: “Kann ich da eine Kurve durchlegen?”\nSie können! Allerdings muss die Kurve zunächst berechnet werden, Matplotlib ist nur für die visuelle Darstellung verantwortlich. Eine einfache Möglichkeit bietet Numpy mit polynomialer Regression: Ein Polynom vorgegebenen Grades wird an die Messwerte angepasst. Das sieht im Ergebnis zum Beispiel so aus:\n\n\nCode\n# Polynom 2. Ordnung fitten\nkoeff = np.polyfit(dehnung, spannung, deg=2)\npolynom = np.poly1d(koeff)\nx_poly = np.linspace(min(dehnung), max(dehnung), 200) # x-Werte für das Polynom\n\n# Plotten\nplt.scatter(dehnung, spannung, label=\"Messdaten\", color='darkred')\nplt.plot(x_poly, polynom(x_poly), label=\"Polynom 2. Ordnung\", color=\"green\")\n\n# Einstellungen zur Darstellung\nplt.title(\"Spannung-Dehnung (Stahlprobe) mit Polynom-Fit\")\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\n\n# Finally: Rendern\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nEin einfaches Balkendiagramm\n\n# Daten\nwerkstoffe = [\"Aluminium\", \"Stahl\", \"Kupfer\"]\nfestigkeit = [150, 400, 210]  # in MPa\n\n# Plotten\nplt.bar(werkstoffe, festigkeit, color='steelblue')\n\n# Einstellungen zur Darstellung\nplt.title(\"Zugfestigkeit verschiedener Werkstoffe\")\nplt.ylabel(\"Zugfestigkeit (MPa)\")\nplt.tight_layout()\n\n# Finally: Rendern\nplt.show()\n\n\n\n\n\n\n\n\n\nÜbungen:\n\nPlotten Sie die Funktion \\(f(x)= 1 + 3\\,\\sqrt{x}\\) im Bereich von 0 bis 10. Tipp: np.sqrt für die Wurzel.\nGegeben sind mittlere Tagestemperaturen in Grad Celsius für die Tage einer Woche: temperatures = np.array([15, 17, 14, 20, 22, 19, 16]). Stellen Sie den Verlauf visuell dar.\nGegeben sind die Verkaufszahlen von vier verschiedenen Produkten im letzten Monat: sales_numbers = [50, 75, 30, 90]. Stellen Sie die Daten in einem Balkendiagramm dar.\n\n\nLösungen:\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Übung 1\nxs = np.linspace(0, 10, 500)\nys = 1 + 3 * np.sqrt(xs)\n\nplt.plot(xs, ys)\n\nplt.title(\"Ü1: $f(x)= 1 + 3\\\\sqrt{x}$\")\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.tight_layout()\nplt.grid(True)\n\nplt.show()\n\n# Übung 2\n\ndays = ['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So']\ntemperatures = np.array([15, 17, 14, 20, 22, 19, 16])\n\nplt.plot(days, temperatures, marker='o') # mit marker='o' markieren wir die Einzelpunkte\n# scatter-Plot wäre auch möglich\n\n\nplt.title(\"Ü2: Temperaturverlauf\")\nplt.xlabel(\"Tag\")\nplt.ylabel(\"mittlere Temperatur [°C]\")\nplt.tight_layout()\nplt.grid(True)\n\nplt.show()\n\n# Übung 3\n\nproducts = [\"A\", \"B\", \"C\", \"D\"]\nsales_numbers = [50, 75, 30, 90]\n\nplt.bar(products, sales_numbers)\n\nplt.title(\"Ü3: Verkaufszahlen im letzten Monat\")\nplt.ylabel(\"Verkäufe\")\nplt.tight_layout()\n\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Die Verwendung von Bibliotheken</span>"
    ]
  },
  {
    "objectID": "notebooks/7-bibs.html#pandas",
    "href": "notebooks/7-bibs.html#pandas",
    "title": "9  Die Verwendung von Bibliotheken",
    "section": "9.4 Pandas",
    "text": "9.4 Pandas\nPandas ist eine Python-Bibliothek zur Datenanalyse und -verarbeitung. Sie macht es einfach, mit tabellarischen Daten zu arbeiten – wie man es von Excel oder MATLAB kennt, nur viel mächtiger! Sie ist ideal für CSV-Dateien, Zeitreihen, Sensorlogs, usw.\nStellen Sie sich vor, Sie hätten eine CSV-Datei pruefstand.csv, die Messdaten von einem Elektromotor-Prüfstand auflistet, evtl. mit Tausenden oder Zehntausenden an Einträgen (Die folgenden Beispieldaten wurden von ChatGPT erzeugt, keine Garantie für Realitätsnähe…):\nzeit_s,drehzahl_rpm,drehmoment_Nm,temperatur_C,strom_A,spannung_V\n0,1497.922347561229,35.05722879661618,24.85808662838076,4.7097920725170965,400.7142291370718\n2,1483.1458149725818,37.49724149349054,25.967905384436204,4.846946612598922,400.8845878170255\n4,1543.0030557077196,34.68875783535333,25.033300464465054,4.003363546678268,401.7643521013756\n6,1478.8807509664023,33.57562248247703,25.72209534542697,3.8818618381400865,401.1119992202271\n8,1509.488872431028,34.695091353612426,25.009793428416128,4.252818267303441,399.13730139977235\n10,1457.8562653828417,36.17824929221712,25.32555101961123,3.9630387647710816,399.6263414315312\n...\nMit pandas ist es ein Leichtes, die Daten zu analysieren! Wir zeigen nur ein paar wenige der vielen Features, die pandas anbietet.\n\nimport pandas as pd\n\n# CSV einlesen\ndf = pd.read_csv(\"./data/pruefstand.csv\")  # oder auch aus einer URL oder Excel-Datei\n\n# Die Abkürzung df ist sehr gebräuchlich und steht für 'Data Frame' = eine Tabelle\n\n# Kurze Übersicht der Daten\ndf.head()  # Zeigt die ersten 5 Zeilen\n\n\n\n\n\n\n\n\nzeit_s\ndrehzahl_rpm\ndrehmoment_Nm\ntemperatur_C\nstrom_A\nspannung_V\n\n\n\n\n0\n0\n1497.922348\n35.057229\n24.858087\n4.709792\n400.714229\n\n\n1\n2\n1483.145815\n37.497241\n25.967905\n4.846947\n400.884588\n\n\n2\n4\n1543.003056\n34.688758\n25.033300\n4.003364\n401.764352\n\n\n3\n6\n1478.880751\n33.575622\n25.722095\n3.881862\n401.111999\n\n\n4\n8\n1509.488872\n34.695091\n25.009793\n4.252818\n399.137301\n\n\n\n\n\n\n\n\ndf.describe()  # liefert statistische Kennzahlen aller Größen\n\n\n\n\n\n\n\n\nzeit_s\ndrehzahl_rpm\ndrehmoment_Nm\ntemperatur_C\nstrom_A\nspannung_V\n\n\n\n\ncount\n500.000000\n500.000000\n500.000000\n500.000000\n500.000000\n500.000000\n\n\nmean\n499.000000\n1498.925139\n34.886097\n45.000590\n4.178905\n400.101695\n\n\nstd\n288.963666\n29.086169\n1.713803\n11.613131\n0.363051\n0.983697\n\n\nmin\n0.000000\n1407.077718\n29.012827\n24.858087\n3.188436\n396.918353\n\n\n25%\n249.500000\n1479.236970\n33.701481\n34.897158\n3.920708\n399.481565\n\n\n50%\n499.000000\n1499.585548\n34.930608\n44.786135\n4.169030\n400.070542\n\n\n75%\n748.500000\n1516.939953\n36.059463\n55.105094\n4.442258\n400.795715\n\n\nmax\n998.000000\n1583.667191\n38.831586\n65.451653\n5.151121\n403.723784\n\n\n\n\n\n\n\nDer describe-Befehl ist sehr nützlich: Wir sehen auf einen Blick, dass unsere Datei 500 Zeilen beinhaltet und erhalten Mittelwerte, Standardabweichungen, Wertebereiche und Quantile aller Messgrößen. Ein erster aufschlussreicher Überblick über unsere Daten!\n\n# Mittelwerte oder andere Kennzahlen können \n# ganz einfach auch einzeln abgefragt werden:\n\nmean_torque = df[\"drehmoment_Nm\"].mean()\nprint(f\"Mittleres Drehmoment: {round(mean_torque, 2)} Nm\")\n\nmean_temperature = df[\"temperatur_C\"].mean()\nprint(f\"Mittlere Temperatur: {round(mean_temperature, 2)} °C\")\n\n# Wie diese Beispiele zeigen, greift man auf einzelne Spalten\n# eines Data Frames über einen Indexzugriff zu, ganz analog zu\n# Dictionaries.\n\nMittleres Drehmoment: 34.89 Nm\nMittlere Temperatur: 45.0 °C\n\n\nSie können auch einfach neue Spalten erzeugen, wie das folgende Beispiel zeigt:\n\ndf[\"power_W\"]=df[\"strom_A\"]*df[\"spannung_V\"]\ndf.head()  # achten Sie auf die neue Spalte.\n\n\n\n\n\n\n\n\nzeit_s\ndrehzahl_rpm\ndrehmoment_Nm\ntemperatur_C\nstrom_A\nspannung_V\npower_W\n\n\n\n\n0\n0\n1497.922348\n35.057229\n24.858087\n4.709792\n400.714229\n1887.280700\n\n\n1\n2\n1483.145815\n37.497241\n25.967905\n4.846947\n400.884588\n1943.066195\n\n\n2\n4\n1543.003056\n34.688758\n25.033300\n4.003364\n401.764352\n1608.408762\n\n\n3\n6\n1478.880751\n33.575622\n25.722095\n3.881862\n401.111999\n1557.061363\n\n\n4\n8\n1509.488872\n34.695091\n25.009793\n4.252818\n399.137301\n1697.458407\n\n\n\n\n\n\n\nSelbstverständlich können wir nun auch Matplotlib in Kombination mit Pandas einsetzen, um Daten zu visualisieren:\n\nimport matplotlib.pyplot as plt\n\n# Plot: Temperatur über Zeit\nplt.plot(df[\"zeit_s\"], df[\"temperatur_C\"], label=\"Temperatur [°C]\", color=\"red\")\n\nplt.xlabel(\"Zeit [s]\")\nplt.ylabel(\"Temperatur [°C]\")\nplt.title(\"Prüfstandsdaten\")\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\n\nplt.show()\n\n\n\n\n\n\n\n\nEin Data Frame kann auch aus einem Dictionary erzeugt werden:\n\nimport pandas as pd\n\ndata = {\n    'Produkt': ['Produkt A', 'Produkt B', 'Produkt C', 'Produkt D'],\n    'Preis': [20, 35, 50, 15],\n    'Verkaufte Menge': [100, 150, 80, 200]\n}\n\ndf = pd.DataFrame(data)\ndf.head()\n\n\n\n\n\n\n\n\nProdukt\nPreis\nVerkaufte Menge\n\n\n\n\n0\nProdukt A\n20\n100\n\n\n1\nProdukt B\n35\n150\n\n\n2\nProdukt C\n50\n80\n\n\n3\nProdukt D\n15\n200\n\n\n\n\n\n\n\n\nÜbungen: Erzeugen Sie das Data Frame, wie im letzten Beispiel gezeigt.\n1. Fügen Sie eine Spalte Umsatz hinzu (Umsatz = Preis * Verkaufte Menge). \n2. Finden Sie das Produkt mit dem höchsten Umsatz. \n3. Erstellen Sie ein Balkendiagramm mit Matplotlib, das den Umsatz jedes Produkts zeigt.\n4. Wie groß sind Mittelwert und Standardabweichung des Umsatzes?\n\nLösung:\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Daten erstellen\ndata = {\n    'Produkt': ['Produkt A', 'Produkt B', 'Produkt C', 'Produkt D'],\n    'Preis': [20, 35, 50, 15],\n    'Verkaufte Menge': [100, 150, 80, 200]\n}\n\ndf = pd.DataFrame(data)\n\n# 1. Umsatz berechnen und als Spalte hinzufügen\ndf['Umsatz'] = df['Preis'] * df['Verkaufte Menge']\n\n# 2. Kann durch einfaches print gelöst werden:\nprint(df)  # Produkt B hat den höchsten Umsatz!\n\n# 3. Balkendiagramm erstellen\nplt.bar(df['Produkt'], df['Umsatz'], color=['red', 'blue', 'green', 'purple'])\nplt.title('Umsatz der Produkte')\nplt.xlabel('Produkt')\nplt.ylabel('Umsatz')\n\nplt.show()\n\n# 4. Statistische Kennzahlen\nprint(\"Mittlerer Umsatz: \", df['Umsatz'].mean(), \"Standardabweichung: \", df['Umsatz'].std())\n# Kann auch über describe abgelesen werden: \ndf.describe()",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Die Verwendung von Bibliotheken</span>"
    ]
  },
  {
    "objectID": "notebooks/8-oop.html",
    "href": "notebooks/8-oop.html",
    "title": "10  Objektorientierte Programmierung (OOP)",
    "section": "",
    "text": "10.1 Grundidee und Prinzipien\nDie objektorientierte Programmierung (OOP) ist ein Programmierparadigma, das Software in Form von Objekten strukturiert. Diese Objekte kombinieren Daten (Attribute) und Verhalten (Methoden) in einer einzigen Einheit. Das Ziel ist es, die reale Welt besser im Code abzubilden, indem Software-Entitäten geschaffen werden, die Eigenschaften und Fähigkeiten besitzen. Dadurch können sehr komplexe Systeme übersichtlich modelliert werden. OOP fördert dadurch eine modularere und wartungsfreundlichere Softwareentwicklung, die näher an der Wirklichkeit ist.\nVier zentrale Prinzipien prägen die objektorientierte Programmierung:",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Objektorientierte Programmierung (OOP)</span>"
    ]
  },
  {
    "objectID": "notebooks/8-oop.html#grundidee-und-prinzipien",
    "href": "notebooks/8-oop.html#grundidee-und-prinzipien",
    "title": "10  Objektorientierte Programmierung (OOP)",
    "section": "",
    "text": "Kapselung (Encapsulation)\nDaten und Funktionen, die zusammengehören, werden in Klassen zusammengefasst. Der Zugriff auf sensible Daten wird kontrolliert – häufig durch private Attribute und öffentliche Schnittstellen (Methoden), die genau festlegen, wie die Attribute verändert oder gelesen werden dürfen. Eine Klasse ist die abstrakte Beschreibung einer Gesamtheit: Sie definiert, was Objekte dieser Art auszeichnet. Beispielsweise beschreibt die Klasse Person abstrakt Eigenschaften wie Name, Geburtsdatum oder Wohnort. Eine konkrete Instanz, wie etwa Max Mustermann, ist dann ein Objekt dieser Klasse.\nVererbung (Inheritance)\nKlassen können Eigenschaften und Verhalten von anderen Klassen übernehmen, um Redundanzen zu vermeiden und Code-Wiederverwendung zu ermöglichen. Man kann sich Klassen vorstellen, die verschiedene Tierarten beschreiben, etwa Dog, Cat oder Mouse. Obwohl sich diese Klassen unterscheiden, teilen sie gemeinsame Merkmale, die in einer Basisklasse Animal zusammengefasst werden können. Die abgeleiteten Klassen spezifizieren dann die Besonderheiten jeder Art. Man sagt: “Dog erbt von Animal” oder “Dog ist abgeleitet von Animal”.\nPolymorphie oder Polymorphismus (Polymorphism)\nObjekte verschiedener Klassen können über die gleiche Schnittstelle angesprochen werden. Dadurch können Funktionen allgemeiner und flexibler gestaltet werden. Im obigen Beispiel kann eine Funktion, die ein Objekt der Klasse Animal erwartet, gleichermaßen mit einem Dog, einer Cat oder einer Mouse arbeiten. Für die Funktion ist nur relevant, dass es sich um ein Animal-Objekt handelt, nicht um dessen genaue Art. Polymorphismus unterstützt dadurch die Erweiterbarkeit und Anpassbarkeit von Programmen. Beispiel: In einer Tierarztpraxis werden alle Patienten in einer Datenbank verwaltet. Dabei ist es egal, ob es sich um Hunde, Katzen oder Mäuse handelt – alle Tiere werden als Instanzen der allgemeinen Klasse Tier gespeichert. Die spezifischen Eigenschaften (z.B. Hunderasse oder Lieblingsfutter der Katze) werden in abgeleiteten Klassen ergänzt.\nAbstraktion (Abstraction)\nNur die wesentlichen Merkmale eines Objekts werden dargestellt; unwichtige Details werden ausgeblendet. Dies erleichtert die Handhabung komplexer Systeme. Dieses Prinzip entspricht dem allgemeinen Konzept der Modellbildung: Ein Modell sollte so präzise wie nötig, aber so einfach wie möglich sein. Eine vollständige Abbildung der Realität wäre genauso komplex wie die Realität selbst und damit unpraktisch. Daher ist Abstraktion immer ein bewusster Kompromiss – zugunsten besserer Verständlichkeit und Lösbarkeit von Problemen. In der objektorientierten Programmierung kann man sogar sog. abstrakte Klassen programmieren, die zwar selbst nicht instanziiert werden können, aber die Struktur aller abgeleiteten Klassen festlegen.\n\n\n\n\n\n\n\nParadigmen der Programmierung\n\n\n\nIn der Softwareentwicklung bezeichnet der Begriff Paradigma einen grundlegenden Ansatz oder eine Methode, wie Probleme durch Programmieren gelöst werden. Jedes Paradigma hat seine eigenen Prinzipien und Konzepte, die eine bestimmte Herangehensweise an die Problemstellung fördern. Die Wahl des Paradigmas beeinflusst die Struktur des Codes, die Art der Probleme, die gelöst werden können, und wie effizient der Entwicklungsprozess verläuft. Jedes Programmierparadigma hat seine Stärken und eignet sich für bestimmte Arten von Aufgaben. In der Praxis wird häufig eine Kombination verschiedener Paradigmen verwendet.\nWichtige Programmierparadigmen:\n\nImperative Programmierung:\nIn der imperativen Programmierung wird die Ausführung einer Software durch eine Reihe von Anweisungen beschrieben, die den Zustand des Programms verändern. Der Fokus liegt darauf, wie ein Problem gelöst wird, also auf den einzelnen Schritten und deren Reihenfolge. Prozedurale Programmierung erweitert die imperative Programmierung um die Möglichkeit, Code in wiederverwendbare Teilaufgaben zu zerlegen. Praktisch alle aktuellen imperativen Programmiersprachen unterstützen den prozeduralen Ansatz.\nHauptprinzipien: Sequentielle Anweisungen, Zustandsänderung, Schleifen und Bedingungen.\nBeispiele: Sprachen wie C, Python und Java unterstützen dieses Paradigma.\nObjektorientierte Programmierung (OOP):\nIn der objektorientierten Programmierung werden Daten und Funktionen, die auf diese Daten operieren, in Objekten organisiert. OOP fördert die Wiederverwendbarkeit und Strukturierung von Code durch die Konzepte von Klassen, Objekten, Vererbung und Polymorphismus.\nHauptprinzipien: Kapselung, Vererbung, Polymorphismus, Abstraktion.\nBeispiele: Java, Python, C++.\nFunktionale Programmierung:\nFunktionale Programmierung basiert auf der Verwendung von Funktionen als grundlegende Bausteine des Programms. Sie betont die Unveränderlichkeit von Daten und vermeidet Zustandsänderungen und Seiteneffekte. Funktionen werden als First-Class-Objekte behandelt, was bedeutet, dass sie als Argumente übergeben und als Rückgabewerte genutzt werden können.\nHauptprinzipien: Unveränderliche Daten, Funktionen als Objekte, keine Seiteneffekte.\nBeispiele: Haskell, Scala.\nLogische Programmierung:\nBei der logischen Programmierung wird ein Problem in Form von Fakten und Regeln beschrieben, die zusammen die Lösung des Problems definieren. Während der Programmierung gibt man an, was wahr ist, und der Computer zieht Schlussfolgerungen, um zu einer Lösung zu gelangen.\nHauptprinzipien: Fakten, Regeln, Schlussfolgerungen.\nBeispiel: Prolog.\n\n\n\n\nKurze Historie\nDie Grundlagen der objektorientierten Programmierung entstanden bereits in den 1960er Jahren: Simula 67 (entwickelt von Ole-Johan Dahl und Kristen Nygaard) gilt als die erste Programmiersprache mit objektorientierten Konzepten. In den 1980ern wurde OOP populärer, insbesondere durch die Sprache Smalltalk. Mit der Verbreitung von C++ und später Java wurde OOP zum dominanten Paradigma in der Softwareentwicklung.\nHeute wird OOP in vielen modernen Programmiersprachen wie Python, C# oder Ruby eingesetzt und ist ein fester Bestandteil der Informatikausbildung. Sie findet in zahlreichen Bereichen Anwendung, etwa in der Anwendungsentwicklung, der Spieleprogrammierung oder der Systementwicklung.\nOOP ermöglicht es, große Softwareprojekte effizient zu entwickeln, indem die Komplexität in kleinere, logisch verbundene Einheiten zerlegt wird. In der Praxis werden dazu von Software-Architekt:innen zunächst die benötigten Klassen und deren Schnittstellen abstrakt definiert – häufig mithilfe von UML-Diagrammen –, bevor die konkrete Implementierung durch Programmiererinnen und Programmierer erfolgt.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Objektorientierte Programmierung (OOP)</span>"
    ]
  },
  {
    "objectID": "notebooks/8-oop.html#bestandteile-einer-klasse-methoden-und-attribute",
    "href": "notebooks/8-oop.html#bestandteile-einer-klasse-methoden-und-attribute",
    "title": "10  Objektorientierte Programmierung (OOP)",
    "section": "10.2 Bestandteile einer Klasse: Methoden und Attribute",
    "text": "10.2 Bestandteile einer Klasse: Methoden und Attribute\nOhne genauer darauf hinzuweisen, haben wir bereits sehr oft mit Objekten gearbeitet: In Python 3 sind nämlich alle Datentypen in Wahrheit Klassen. Besonders auffällig ist dies bei der Verwendung von Datenstrukturen, wie Listen:\n\nmy_list = [3, 1, 2]  # erzeugt ein Objekt der Klasse \"list\"\nprint(type(my_list))\n\n&lt;class 'list'&gt;\n\n\nDie Klasse list bietet eine Vielzahl an Methoden an, das sind alle Funktionen, die innerhalb der Klasse definiert sind, z.B.:\n\nmy_list.sort()  # sort-Methode der Klasse list\nmy_list.reverse()  # reverse-Methode\nmy_list.append(10)  # append-Methode\n\nWir betrachten nun als weiteres Beispiel die Klasse datetime aus dem gleichnamigen Modul:\n\nfrom datetime import datetime  # importiert die Klasse\n\n# wir erzeugen eine Instanz von datetime \n# mit dem heutigen Datum:\ntoday = datetime.now()\n\nÜber die Referenz today können wir nun die erzeugte Instanz untersuchen und auf ihre Eigenschaften - die sogenannten Attribute - zugreifen:\n\ntoday.year  # Zugriff auf das Attribut year\n\n2025\n\n\n\ntoday.month  # Zugriff auf das Attribut month\n\n4\n\n\nDie Klasse bietet aber auch Methoden an, z.B. toordinal(), eine Funktion, die das Datum als Integer ausgibt, der die Tage seit dem 1. Januar im Jahre 1 n. Chr. zählt:\n\ntoday.toordinal()\n\n739369\n\n\nEin zweites Beispiel ist die Methode strftime, mit der ein Datum als formatierter String ausgegeben wird:\n\ntoday.strftime(\"%d.%m.%Y\")  # das Format ist beliebig anpassbar\n\n'28.04.2025'\n\n\nAls wir unsere Instanz oben erzeugt haben, verwendeten wir die Methode now(). Diese Methode konnten wir auch ohne konkretes Objekt verwenden, da sie für alle Objekte der Klasse identisch ist. Sie wurde direkt über den Klassennamen datetime aufgerufen. Methoden dieser Art heißen statische Methoden (es kann auch statische Attribute geben).\nFassen wir die wichtigsten Begriffe zusammen:\n\n\n\n\n\n\nAttribut\nEin Attribut ist eine Variable innerhalb einer Klasse, die den Zustand oder eine Eigenschaft eines Objekts beschreibt.\nBeispiel: today.year, wobei today ein Objekt der Klasse datetime referenziert.\nMethode\nEine Methode ist eine Funktion innerhalb einer Klasse, die das Verhalten eines Objekts definiert und auf dessen Attribute zugreifen oder sie verändern kann.\nBeispiel: today.toordinal(), wobei today ein Objekt der Klasse datetime referenziert.\nStatisch\nStatisch bezeichnet Elemente, die zur Klasse selbst gehören und nicht an einzelne Objekte gebunden sind. Statische Attribute und Methoden werden unabhängig von Instanzen verwendet.\nBeispiel: datetime.now()\nMembers\nDer Begriff Members fasst alle Bestandteile einer Klasse zusammen; alle Attribute und alle Methoden (auch statische) sind Members der Klasse.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Objektorientierte Programmierung (OOP)</span>"
    ]
  },
  {
    "objectID": "notebooks/8-oop.html#erste-eigene-klassen",
    "href": "notebooks/8-oop.html#erste-eigene-klassen",
    "title": "10  Objektorientierte Programmierung (OOP)",
    "section": "10.3 Erste eigene Klassen",
    "text": "10.3 Erste eigene Klassen\nWir programmieren erste kleine Klassen, um uns an das Konzept und die Syntax zu gewöhnen.\n\nclass Animal:\n    \n    # mit der Methode __init__ - dem \"Konstruktor\" - fängt alles an:\n    def __init__(self, name, age):\n        self.name = name  # Attribut name wird angelegt\n        self.age = age  # Attribut age wird angelegt\n\n    # eine weitere Methode:\n    def speak(self):\n        print(f\"{self.name} macht ein Geräusch.\")\n\n    # eine weitere Methode:\n    def birthday(self):\n        print(f\"Herzlichen Glückwunsch zum Geburtstag, {self.name}!\")\n        self.age += 1\n\nWir erkennen die allgemeine Syntax zum Definieren einer Klasse:\n\nclass Klassenname:\n    # eingerückter Code\n    # Definition aller Methoden\n\nDer Klassenname soll nach den offiziellen Empfehlungen mit einem Großbuchstaben beginnen und bei mehreren Wörtern in Camel Case geschrieben werden (z.B. GameController oder WindowManager). Im obigen Beispiel haben wir die Klasse Animal definiert und drei Methoden angelegt: __init__(...), speak(...) und birthday(...). Auffällig ist, dass alle Methoden einer Klasse als erstes Argument den Parameter self verwenden. Dieser Parameter verweist auf das aktuelle Objekt der Klasse. Das bedeutet, dass self die Instanz der Klasse repräsentiert, die die Methode gerade aufruft. Der Parameter wird automatisch gesetzt, wenn wir zum Beispiel today.toordinal() aufrufen (in diesem Fall entspricht self der Instanz von today).\nEin weiteres auffälliges Merkmal ist die Methode __init__, die durch die doppelten Unterstriche vor und nach ihrem Namen hervorsticht. Methoden dieser Art werden in Python als Magic Methods bezeichnet, da sie eine spezielle Bedeutung für den Python-Interpreter haben. In diesem Fall ist __init__ der Konstruktor einer Klasse. Der Konstruktor wird automatisch aufgerufen, wenn ein neues Objekt dieser Klasse erstellt wird. Neben dem obligatorischen self erhält der Konstruktor die Argumente name und age, die dann über die Zuweisungen self.name = name und self.age = age als Attribute in der Instanz gespeichert werden. Die Übergabeparameter des Konstruktors müssen dabei nicht zwangsläufig genauso heißen wie die Attribute, allerdings ist das eine weit verbreitete Praxis, um Verwechslungen bei der Zuweisung zu vermeiden.\nDie Methoden speak und birthday sind relativ selbsterklärend: speak gibt eine allgemeine Ausgabe des Tieres zurück, während birthday zum Geburtstag gratuliert und das Alter um eins erhöht. Testen wir nun unsere Klasse:\n\nmy_dog = Animal(\"Bello\", 5)  # ruft den Konstruktor auf\nmy_dog.speak()\n\nBello macht ein Geräusch.\n\n\n\nmy_dog.age  # greift auf das Attribut age zu\n\n5\n\n\n\nmy_dog.birthday()\n\nHerzlichen Glückwunsch zum Geburtstag, Bello!\n\n\n\nmy_dog.age\n\n6\n\n\n\n# Natürlich können wir beliebig viele\n# Animals erzeugen, hier ein zweites:\nmy_cat = Animal(\"Liz\", 1)\nmy_cat.speak()\n\nLiz macht ein Geräusch.\n\n\nDie speak-Methode ist noch sehr unzufriedenstellend. Ein Hund sollte doch bellen, eine Katze miauen. Allerdings ist Animal eine relativ abstrakte Basisklasse für alle Tiere und deshalb an dieser Stelle zwangsläufig unspezifisch. Wir können nun das Prinzip der Vererbung verwenden, um spezifische Tierklassen anzulegen:\n\n# Vererbung: Dog erbt von Animal\nclass Dog(Animal):\n    def speak(self):\n        print(f\"{self.name} bellt.\")\n\n# Vererbung: Cat erbt von Animal\nclass Cat(Animal):\n    def speak(self):\n        print(f\"{self.name} miaut.\")\n\nDie Basisklasse (hier: Animal) wird bei der Klassendefinition in Klammern angegeben. Das Anlegen der Klassen Dog und Cat ist sehr einfach, denn wir spezifizieren nur die Unterschiede zur Basisklasse, also die individuellen Realisierungen der Methode speak. Alles andere wird von der Basisklasse Animal übernommen (die abgeleiteten Klassen werden deshalb auch “Subklassen” oder “Kindklassen” genannt). Probieren wir unsere neuen Klassen aus:\n\nmy_dog = Dog(\"Bello\", 6)\nmy_cat = Cat(\"Liz\", 1)\nmy_turtle = Animal(\"Einstein\", 100)\n\nmy_dog.speak()\nmy_cat.speak()\nmy_turtle.speak()\n\nBello bellt.\nLiz miaut.\nEinstein macht ein Geräusch.\n\n\nMan sagt auch: Die Methode speak wurde in den Klassen Dog und Cat überschrieben. Mit Vererbung könnten wir noch deutlich spezifischere Klassen anlegen, z.B. konkrete Hunderassen (hierzu würden wir von Dog ableiten, z.B. class Husky(Dog):). Es entstehen beliebig komplexe Klassen-Hierarchien. An unserem Beispiel erkennen wir auch, dass die Basisklasse davon unbeschadet ist und weiterhin verwendet werden kann (my_turtle referenziert eine allgemeine Animal-Instanz).\nAlle Subklassen von Animal werden weiterhin als Animal betrachtet und können auch als solche verwendet werden. Das bedeutet, dass eine Funktion, die ein Animal erwartet, auch mit einem Dog oder einer Cat funktioniert. Dies ist ein Beispiel für Polymorphismus. Wichtig: Obwohl alle Instanzen Tiere sind, sind sie nicht alle gleich - die gleiche Methode (hier speak()) wird je nach konkretem Typ unterschiedlich ausgeführt.\nUmgekehrt muss man vorsichtiger sein: Eine Subklasse kann zusätzliche Methoden oder Attribute haben, die in der Basisklasse nicht existieren. Wenn eine Funktion speziell auf diese neuen Methoden zugreifen möchte, muss sie den spezifischen Typ des Objekts kennen, anstatt nur die Basisklasse zu verwenden. Andernfalls könnte der Zugriff auf diese zusätzlichen Eigenschaften oder Methoden zu einem Fehler führen, falls das Objekt tatsächlich eine Instanz der Basisklasse und nicht der Subklasse ist. Beispielhaft erweitern wir unsere Klasse Dog um eine Methode fetch():\n\nclass Dog(Animal):\n    def speak(self):\n        print(f\"{self.name} bellt.\")\n\n    def fetch(self):\n        print(f\"{self.name} fängt den Ball.\")\n\n\nmy_dog = Dog(\"Bello\", 6)\nmy_dog.fetch()\n\nmy_turtle = Animal(\"Einstein\", 100)\n# my_turtle.fetch() FEHLER! Die Methode existiert nicht in der Basisklasse!\n\nmy_cat = Cat(\"Liz\", 1)\n# my_cat.fetch() FEHLER! In der Klasse Cat existiert sie auch nicht!\n\nBello fängt den Ball.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Objektorientierte Programmierung (OOP)</span>"
    ]
  },
  {
    "objectID": "notebooks/8-oop.html#uml-klassendiagramme",
    "href": "notebooks/8-oop.html#uml-klassendiagramme",
    "title": "10  Objektorientierte Programmierung (OOP)",
    "section": "10.4 UML-Klassendiagramme",
    "text": "10.4 UML-Klassendiagramme\nWir wollen uns nun mit dem systematischen Design von Klassen befassen. Häufig wird dazu die Unified Modeling Language (UML) verwendet. Es handelt sich dabei um eine standardisierte grafische Sprache zur Modellierung und Visualisierung von Software-Systemen. UML ermöglicht es Entwickler:innen, die Struktur, das Verhalten und die Interaktionen eines Systems darzustellen. Ein besonders wichtiger Bestandteil von UML ist das Klassendiagramm. Es stellt die statische Struktur eines Systems dar, indem es die Klassen eines Systems sowie deren Beziehungen zueinander visualisiert. UML ist sehr mächtig und kann hier nur in kleinen Auszügen dargestellt werden.\n\nGrundstruktur eines Klassendiagramms\nEine Klasse wird durch ein Rechteck dargestellt, welches vertikal in drei Felder unterteilt wird (siehe Abbildung 10.1):\n\nDer Name der Klasse wird in das oberste Feld geschrieben.\nIm zweiten Feld werden alle Attribute aufgeführt.\nIm dritten Feld folgend die Methoden.\n\n\n\n\n\n\n\nAbbildung 10.1: Aufbau eines UML-Klassendiagramms.\n\n\n\nKonkret sieht es für unsere Animal-Klasse aus dem vorigen Abschnitt so aus wie in Abbildung 10.2.\n\n\n\n\n\n\nAbbildung 10.2: UML-Klassendiagramm für die Klasse Animal.\n\n\n\nVererbung wird im UML-Diagramm durch einen Pfeil dargestellt, der von der abgeleiteten Klasse zur Basisklasse zeigt. In der abgeleiteten Klasse werden Attribute und Methoden, die unverändert von der Basisklasse übernommen werden, nicht aufgeführt. In Abbildung 10.3 sehen wir dies für die Klassen Dog und Animal.\n\n\n\n\n\n\nAbbildung 10.3: UML-Klassendiagramm mit Vererbung: Dog erbt von Animal.\n\n\n\n\nZugriffsmodifizierer\nDie +-Zeichen in den bisherigen Diagrammen sind nicht beliebig, sondern stellen sog. Zugriffsmodifizierer dar. Sie geben an, wer über die gekennzeichneten Attribute und Methoden verfügen darf. Man unterscheidet drei Stufen:\n\nPublic (+): Öffentliche Elemente, die von überall und jedem aufgerufen werden können.\nPrivate (-): Private Elemente, die nur innerhalb der Klasse verwendet werden können. Außenstehende sollen diese Elemente nicht verwenden. Auch abgeleitete Klassen sollen keinen Zugriff auf sie haben.\nProtected (#): Geschützte Elemente, die in der Klasse und ihren Unterklassen verwendet werden können. Für Außenstehende sollen sie aber nicht direkt verfügbar sein.\n\nIn Python gibt es keine Möglichkeit, die Zugriffsrechte eins zu eins umzusetzen. Das ist ein großer Unterschied zu anderen Programmiersprachen, wie z.B. C++. Dennoch gibt es Mechanismen und Konventionen, wie in Python mit den unterschiedlichen Zugriffsrechten umgegangen wird. Darauf gehen wir in einem späteren Abschnitt genauer ein.\n\n\n\nBeziehungen zwischen Klassen\nIn UML wird eine ungerichtete Verbindungslinie verwendet, um auszudrücken, dass zwei Klassen miteinander in Beziehung stehen. Diese Beziehung wird als Assoziation bezeichnet. Ein Beispiel hierfür ist die Beziehung zwischen den Klassen Person und Animal in Abbildung 10.4, wobei eine Person ein oder mehrere Haustiere besitzt. In UML wird in diesem Fall häufig die Multiplizität angegeben, um zu definieren, wie viele Instanzen der einen Klasse mit wie vielen Instanzen der anderen Klasse in Beziehung stehen können.\nIn unserem Beispiel kann eine Person 0 oder beliebig viele Tiere besitzen, während jedes Tier exakt eine Person als Besitzer bzw. Besitzerin hat (eine vereinfachte Annahme). Dies verdeutlicht, dass zu jeder Assoziation immer zwei Multiplizitäten gehören, die direkt an den Enden der Verbindungslinie notiert werden. Die gängigsten Bezeichner für Multiplizitäten sind:\n1: genau eine Instanz.\n\n0..1: keine oder genau eine Instanz.\n\n0..*: keine oder beliebig viele Instanzen.\n\n1..*: eine oder beliebig viele Instanzen.\n\nm..n: mindestens m Instanzen, maximal n Instanzen (z.B. 3..10).\n\n\n\n\n\n\nAbbildung 10.4: UML-Klassendiagramm mit Assoziation: Beziehung zwischen Person und Animal.\n\n\n\n\n\nErgänzungen\n\nIm UML-Klassendiagramm kann außerdem der Datentyp von Attributen mitangegeben werden. Dazu verwendet man einen Doppelpunkt hinter dem Attribut gefolgt von der Typangabe, z.B. name: str.\nBei den Methoden werden in den Klammern alle Parameter angegeben, allerdings ohne das implizite self, welches eine Besonderheit von Python darstellt (UML-Diagramme sind nicht auf eine bestimmte Programmiersprache beschränkt).",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Objektorientierte Programmierung (OOP)</span>"
    ]
  },
  {
    "objectID": "notebooks/8-oop.html#beispiel-bibliotheksverwaltung",
    "href": "notebooks/8-oop.html#beispiel-bibliotheksverwaltung",
    "title": "10  Objektorientierte Programmierung (OOP)",
    "section": "10.5 Beispiel: Bibliotheksverwaltung",
    "text": "10.5 Beispiel: Bibliotheksverwaltung\nIn diesem Abschnitt wollen wir eine einfache Bibliotheksverwaltung programmieren. Das geplante System wird im folgenden UML-Klassendiagramm dargestellt:\n\n\n\n\n\n\nAbbildung 10.5: UML-Klassendiagramm für die Bibliotheksverwaltung.\n\n\n\n\nDie Klasse Library\nDas einzige Attribut der Klasse Library ist media_collection und stellt eine Liste aller verfügbaren Medien dar. Über die Methoden der Klasse können Medien entliehen (borrow_medium(medium_id)) bzw. zurückgegeben (return_medium(medium_id)), dem Bestand hinzugefügt (add_medium(medium)) bzw. aus ihm entfernt (remove_medium(medium_id)) werden. Schließlich soll get_media_info() eine Übersicht über alle Medien der Bibliothek liefern.\n\n\nDie Klasse Medium und ihre Kindklassen: Book und Magazine\nDie Klasse Medium auf der anderen Seite stellt eine Basisklasse für alle in der Bibliothek verfügbaren Medien dar (in unserem Beispiel Bücher und Magazine). Alle Medien besitzen einen Titel und eine eindeutige ID. Außerdem kennzeichnet ein boolesches Attribut, ob sie zur Zeit verfügbar sind oder nicht (available). Die Methode get_info() soll die wesentlichen Informationen über das Medium und den aktuellen Ausleih-Status widergeben. Die Klassen Book und Magazine erben von Medium und erweitern die Basisklasse um spezifische Attribute. Die Methode get_info() soll jeweils überschrieben werden.\nDie Medien-ID hat eine wichtige Bedeutung: Wie wir an den Methoden zum Ausleihen und Zurückgeben erkennen, arbeitet die Bibliothek intern ausschließlich mit dieser eindeutigen Kennzeichnung und nicht etwa mit dem Titel oder anderen Attributen. Sie muss auf jeden Fall eindeutig sein! Es stellt sich noch die Frage, wann und durch wen ein Medium seine ID erhält. In der realen Welt sicherlich durch die Bibliothek, vermutlich in dem Moment, in dem es in den Bestand der Bibliothek aufgenommen wird. Wir wollen das Beispiel aber zunächst einfacher halten und weisen jedem Medium bei seiner Erzeugung händisch eine ID zu.\n\n\nMit super() auf die Basisklasse zugreifen\nBevor wir mit dem Programmieren beginnen, möchten wir noch auf eine wichtige Besonderheit hinweisen: Da die abgeleiteten Klassen diesmal eigene zusätzliche Attribute besitzen, reicht es nicht aus, einfach den Konstruktor der Basisklasse zu übernehmen. Stattdessen müssen wir den Konstruktor in den Unterklassen selbst definieren. Dabei können wir jedoch weiterhin den bereits bestehenden Konstruktor der Basisklasse nutzen, um deren Attribute korrekt zu initialisieren. Dafür stellt Python die Funktion super() bereit. Mit ihrer Hilfe können wir gezielt Methoden der übergeordneten Klasse aufrufen. Konkret bedeutet das: Mit super().__init__(...) rufen wir den Konstruktor der Basisklasse auf und können ihm die entsprechenden Werte übergeben.\n\n\nDie Implementierung\nJetzt sind wir bereit für die Implementierung, wir beginnen auf der rechten Seite mit den Medien:\n\nclass Medium:\n    \n    def __init__(self, title, medium_id):\n        self.title = title\n        self.medium_id = medium_id\n        self.available = True  # wird auf True initialisiert\n        \n    def get_info(self):\n        status = \"verfügbar\" if self.available else \"entliehen\"\n        print(f\"ID: {self.medium_id}, Titel: {self.title}, Status: {status}\")\n\nclass Book(Medium):\n    \n        def __init__(self, title, medium_id, author, isbn):\n            # Konstruktor der Basisklasse aufrufen:\n            super().__init__(title, medium_id)\n            # zusätzliche Attribute zuweisen:\n            self.author = author\n            self.isbn = isbn\n            \n        def get_info(self):     \n            # Wir könnten auch hier super() verwenden,\n            # allerdings könnten wir dann die neuen Attribute \n            # nur darunter anfügen: \n            # super().get_info()\n            # print(f\"Author: {self.author}, ISBN: {self.isbn}\")\n            \n            status = \"verfügbar\" if self.available else \"entliehen\"\n            print(f\"ID: {self.medium_id}, Titel: {self.title}, Author: {self.author}, ISBN: {self.isbn}, Status: {status}\")\n\nclass Magazine(Medium):\n    \n        def __init__(self, title, medium_id, issue, year):\n            # Konstruktor der Basisklasse aufrufen:\n            super().__init__(title, medium_id)\n            # zusätzliche Attribute zuweisen:\n            self.issue = issue\n            self.year = year\n        \n        def get_info(self):     \n            status = \"verfügbar\" if self.available else \"entliehen\"\n            print(f\"ID: {self.medium_id}, Titel: {self.title}, Ausgabe: {self.issue}, Jahr: {self.year}, Status: {status}\") \n\nLegen wir ein paar Beispiel-Medien an:\n\nbook1 = Book(\"Herr der Ringe\", 1, \"Tolkien, J. R. R.\", \"978-3-16-148410-0\")\nmagazine1 = Magazine(\"Nature\", 2, 5, 2004)\nbook1.get_info()\nmagazine1.get_info()\n\nID: 1, Titel: Herr der Ringe, Author: Tolkien, J. R. R., ISBN: 978-3-16-148410-0, Status: verfügbar\nID: 2, Titel: Nature, Ausgabe: 5, Jahr: 2004, Status: verfügbar\n\n\n\nclass Library:\n    \n    def __init__(self):\n        self.media_collection = []\n        \n    def borrow_medium(self, medium_id):\n        \n        # Bestand wird durchsucht \n        for medium in self.media_collection:\n        \n            if medium.medium_id == medium_id:\n                \n                # Das Medium wurde im Bestand gefunden \n                \n                if medium.available:\n                    medium.available = False\n                    print(f\"{medium.title} wurde entliehen.\")\n                else:\n                    print(f\"AUSLEIHEN NICHT MÖGLICH! {medium.title} ist bereits entliehen.\")\n                \n                return\n                \n        print(f\"Das gewünschte Medium befindet sich nicht im Bestand\")\n\n    def return_medium(self, medium_id):\n        \n        for medium in self.media_collection:\n            \n            if medium.medium_id == medium_id:\n                \n                if not medium.available:\n                    medium.available = True\n                    print(f\"{medium.title} wurde zurückgegeben.\")\n                else:\n                    print(f\"Fehler: {medium.title} wurde noch nicht entliehen.\")\n                \n                return\n                \n        print(f\"Das Medium gehört nicht zum Bestand der Bibliothek\")\n\n    def add_medium(self, medium):\n        \n        medium.available = True\n        self.media_collection.append(medium)\n\n    def remove_medium(self):\n        self.media_collection.remove(medium)\n\n    def get_media_info(self):\n        print(\"Bibliotheks-Bestand:\")\n        for medium in self.media_collection:\n            medium.get_info()\n\n\n# Es folgen ein paar Tests unseres Systems\nlibrary = Library()\nlibrary.add_medium(book1)\nlibrary.add_medium(magazine1)\nlibrary.get_media_info()\n\nBibliotheks-Bestand:\nID: 1, Titel: Herr der Ringe, Author: Tolkien, J. R. R., ISBN: 978-3-16-148410-0, Status: verfügbar\nID: 2, Titel: Nature, Ausgabe: 5, Jahr: 2004, Status: verfügbar\n\n\n\nlibrary.borrow_medium(1)\nlibrary.get_media_info()\n\nHerr der Ringe wurde entliehen.\nBibliotheks-Bestand:\nID: 1, Titel: Herr der Ringe, Author: Tolkien, J. R. R., ISBN: 978-3-16-148410-0, Status: entliehen\nID: 2, Titel: Nature, Ausgabe: 5, Jahr: 2004, Status: verfügbar\n\n\n\nlibrary.borrow_medium(1)\nlibrary.borrow_medium(2)\nlibrary.return_medium(1)\nlibrary.get_media_info()\n\nAUSLEIHEN NICHT MÖGLICH! Herr der Ringe ist bereits entliehen.\nNature wurde entliehen.\nHerr der Ringe wurde zurückgegeben.\nBibliotheks-Bestand:\nID: 1, Titel: Herr der Ringe, Author: Tolkien, ISBN: 978-3-16-148410-0, Status: verfügbar\nID: 2, Titel: Nature, Ausgabe: 5, Jahr: 2004, Status: entliehen\n\n\n\nÜbungen:\n\nImplementieren Sie eine Klasse, die einen weiteren Medien-Typ darstellt (z.B. DVD oder CD). Wählen Sie selbst geeignete Attribute und überschreiben Sie get_info(). Fügen Sie der Bibliothek ein paar Exemplare des neuen Typs hinzu.\nLeiten Sie eine Klasse EBook von Book ab. Zusätzliche Attribute: Dateiformat und Dateigröße in MB. Fügen Sie der Bibliothek ein paar EBooks hinzu.\nImplementieren Sie in der Klasse Library eine Suchfunktion für Benutzer, die ein Medium anhand des Titels findet.\nRecherchieren Sie, was UUIDs sind und wie man diese in Python erzeugen kann. Jedes Medium soll bei der Aufnahme in den Bibliotheksbestand eine UUID als medium_id zugewiesen bekommen. Passen Sie den Konstruktor von Medium entsprechend an (initialisieren Sie medium_id z.B. mit -1).\nÄndern Sie die Klasse Library ab: Ersetzen Sie die Liste media_collection durch ein geeignetes Dictionary.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Objektorientierte Programmierung (OOP)</span>"
    ]
  },
  {
    "objectID": "notebooks/8-oop.html#public-protected-private",
    "href": "notebooks/8-oop.html#public-protected-private",
    "title": "10  Objektorientierte Programmierung (OOP)",
    "section": "10.6 Public, Protected, Private",
    "text": "10.6 Public, Protected, Private\nIn objektorientierten Programmiersprachen wie Java oder C++ ist die Sichtbarkeit von Attributen und Methoden streng durch Zugriffsmodifikatoren geregelt: public, protected und private. Python kennt diese Schlüsselwörter nicht in derselben Weise, bietet aber eigene Konventionen, um gewünschte Zugriffseinschränkungen auf Klassenbestandteile auszudrücken.\n\npublic - der Standard\nIn Python ist alles standardmäßig public. Das bedeutet, dass auf Methoden und Attribute von außerhalb der Klasse direkt zugegriffen werden kann. In den bisherigen Beispielen konnte man sowohl auf Attribute (z.B. issue in unserer Magazine-Klasse), als auch auf Methoden (z.B. get_info()) uneingeschränkt zugreifen. Das ist in anderen Programmiersprachen eher die Ausnahme, als die Regel.\n\n\nprotected - nur für den internen Gebrauch\nPython verwendet einen führenden Unterstrich (_), um zu signalisieren: Dieses Attribut oder diese Methode sollte von außen nicht direkt verwendet werden, sondern nur innerhalb der Klasse und ihrer abgeleiteten Klassen. Technisch ist der Zugriff aber weiterhin möglich – es handelt sich nur um eine Konvention, kein Verbot. Hier wird klar, dass Python stark auf die Verantwortung der Programmiererinnen und Programmierer setzt, statt auf strenge Zugriffsverbote. Ein Beispiel:\n\nclass Vehicle:\n    def __init__(self):\n        self._fuel_level = 100  # protected: nur für interne Verwendung gedacht\n\nclass Car(Vehicle):\n    def show_fuel(self):\n        print(f\"Aktueller Tankstand: {self._fuel_level}%\")\n    def refuel(self):\n        self._fuel_level = 100\n    def drive(self, velocity, distance):\n        pass  # Platzhalter für die Verbrauchsberechnung während einer Fahrt  \n\n\n\nprivate - Gehört nur einer einzigen Klasse!\nPrivate bedeutet, dass dieses Attribut oder diese Methode nur zu genau einer Klasse gehören soll und nicht zu davon abgeleiteten Klassen. Sie werden durch zwei führende Unterstriche (__) gekennzeichnet. Hier handelt es sich um mehr als nur eine Konvention: Python reagiert auf die beiden führenden Unterstriche mit Name Mangling: Das heißt, Python verändert intern den Namen und stellt den Namen der besitzenden Klasse voran (wiederum mit einem führenden Unterstrich). Kennt man den Mechanismus, könnte man über den neuen Namen wie gewohnt auf das Attribut oder die Methode zugreifen (auch von außerhalb oder innerhalb abgeleiteter Klassen), das ist aber nicht erwünscht. Beispiel:\n\nclass Engine:\n    def __init__(self):\n        self.__power = 150  # private: gehört nur der Klasse Engine \n\n    def show_power(self):\n        print(f\"Leistung: {self.__power} PS\")\n\n\ntest_engine = Engine()\n# So ist es gedacht:\ntest_engine.show_power()      \n\n# So nicht und es gibt einen Fehler:\n# print(test_engine.__power)\n# Grund: Intern heißt das Attribut nicht mehr __power, sondern _Engine__power.\n\nprint(test_engine._Engine__power)  # funktioniert – aber unsauber!\n\nLeistung: 150 PS\n150\n\n\nWichtig: __power ist nicht wirklich privat. Es wird intern als _Engine__power gespeichert. Über diesen Namen kann man darauf zugreifen, sollte es aber nicht tun. In anderen Sprachen heißt private auch wirklich private: kein Zugriff von außerhalb der Klasse ist möglich (auch nicht aus abgeleiteten Klassen heraus)!\n\n\nGetter und Setter\nGetter- und Setter-Methoden sind einfache Funktionen, die den kontrollierten Zugriff auf protected (_attribute) oder private (__attribute) Attribute ermöglichen. Die Idee: Über diese Funktionen wird eine öffentliche, kontrollierte Schnittstelle zu den geschützten Attributen angeboten.\n\nGetter liefern den aktuellen Wert eines Attributs zurück.\nSetter erlauben das Ändern eines Attributs, oft mit Prüfungen oder zusätzlicher Logik, um den gültigen Wertebereich einzuhalten.\n\n\nclass Vehicle:\n    def __init__(self):\n        self._fuel_level = 100  # protected Attribut: nur intern direkt verwenden!\n\n    def get_fuel_level(self):  # Getter: zum Abrufen des Attributs von außen.\n        return self._fuel_level\n\n    def set_fuel_level(self, value):  # Setter mit Validierung: zum kontrollierten Setzen des Attributs.\n        if 0 &lt;= value &lt;= 100:\n            self._fuel_level = value\n\nGetter und Setter unterstützen das Prinzip der Kapselung und sind in der objektorientierten Programmierung stark verbreitet.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Objektorientierte Programmierung (OOP)</span>"
    ]
  },
  {
    "objectID": "notebooks/8-oop.html#magic-methods",
    "href": "notebooks/8-oop.html#magic-methods",
    "title": "10  Objektorientierte Programmierung (OOP)",
    "section": "10.7 Magic Methods",
    "text": "10.7 Magic Methods\nMagic Methods – auch bekannt als dunder methods (wegen der doppelten Unterstriche: double underscore) – sind spezielle Methoden einer Klasse, die eine ganz bestimmte Bedeutung haben. Sie ermöglichen es selbstprogrammierten Objekten, sich wie eingebaute Python-Objekte zu verhalten, z. B. bei Vergleichen, Rechenoperationen oder der Darstellung im Print-Output. Magisch ist daran, dass diese Methoden automatisch von Python aufgerufen werden, wenn bestimmte Operationen auf einem Objekt durchgeführt werden – man muss sie nicht explizit aufrufen. Ein Beispiel ist der Konstruktor, der automatisch bei der Objekt-Erzeugung aufgerufen wird. Es gibt eine Vielzahl von Magic Methods, wir stellen einige vor:\n\n\n\n\n\n\n\n\nMethode\nWird aufgerufen bei …\nZweck\n\n\n\n\n__init__\nObjekt-Erzeugung\nInitialisierung des Objekts\n\n\n__str__\nstr(obj) oder print(obj)\nString-Repräsentation für Ausgaben\n\n\n__eq__\nobj1 == obj2\nVergleich auf Gleichheit\n\n\n__lt__\nobj1 &lt; obj2\nKleiner-Vergleich\n\n\n__add__\nobj1 + obj2\nAddition mit benutzerdefinierter Logik\n\n\n__len__\nlen(obj)\nLänge eines Objekts\n\n\n__int__\nint(obj)\nInteger-Repräsentation des Objekts (analog für float)\n\n\n\nWir erweitern unsere Klasse Book, um einige Magic Methods exemplarisch vorzustellen:\n\nclass Book(Medium): \n        def __init__(self, title, medium_id, author, isbn):\n            super().__init__(title, medium_id)\n            self.author = author\n            self.isbn = isbn\n        def get_info(self):                \n            \n            status = \"verfügbar\" if self.available else \"entliehen\"\n            \n            print(f\"ID: {self.medium_id}, Titel: {self.title}, Author: {self.author}, ISBN: {self.isbn}, Status: {status}\")\n\n        # der neue Teil: #\n        #----------------#\n\n        # wir definieren eine String-Repräsentation für Books:\n        def __str__(self):\n            return f\"'{self.title}' by {self.author}\"\n\n        # wir definieren den Gleichheitsoperator für Books:\n        def __eq__(self, other):\n            return self.isbn == other.isbn\n\n        # wir definieren eine Integer-Repräsentation für Books:\n        def __int__(self):\n            return self.medium_id\n        \n\n\nbook1 = Book(\"Herr der Ringe\", 1, \"Tolkien, J. R. R.\", \"978-3-16-148410-0\")\nbook2 = Book(\"Harry Potter und der Feuerkelch\", 2, \"Rowling, J. K.\", \"756-2-12-165320-1\")\n\n\nprint(book1)  # String-Repräsetnation wird ausgegeben\n\n'Herr der Ringe' by Tolkien, J. R. R.\n\n\n\nprint(book2)\n\n'Harry Potter und der Feuerkelch' by Rowling, J. K.\n\n\n\nint(book1)  # Casting nach int: wir erhalten die ID\n\n1\n\n\n\nint(book2)\n\n2\n\n\n\nprint(book1 == book2)  # ISBNs werden verglichen\n\nFalse\n\n\n\nprint(book1 != book2)\n\nTrue\n\n\n\n# book1 &lt; book2  # Diese Operation haben wir nicht definiert, sie führt deshalb zum Fehler!\n\n\n\n\n\n\n\nOperatoren überladen\n\n\n\nEin Operator ist eine Vorschrift, die aus einer Reihe von Operanden einen neuen Wert berechnet. Typische Beispiele sind Rechenoperatoren, wie + oder *, aber auch Vergleichsoperatoren wie &lt; oder == (bei letzteren ist das Ergebnis ein Wahrheitswert). Mit Magic Methods kann man in Python Operatoren überladen – also ihnen eine benutzerdefinierte Bedeutung für eigene Klassen geben.\nWichtige Magic Methods für Rechenoperationen:\n\n\n\n\n\n\n\n\nOperator\nMagic Method\nBeschreibung\n\n\n\n\n+\n__add__(self, other)\nAddition\n\n\n-\n__sub__(self, other)\nSubtraktion\n\n\n*\n__mul__(self, other)\nMultiplikation\n\n\n/\n__truediv__(self, other)\nDivision (Gleitkomma)\n\n\n//\n__floordiv__(self, other)\nGanzzahl-Division\n\n\n%\n__mod__(self, other)\nModulo (Rest)\n\n\n**\n__pow__(self, other)\nPotenz\n\n\nabs(obj)\n__abs__(self)\nAbsolutwert / Betrag\n\n\n\nWichtige Magic Methods für Vergleichsoperationen:\n\n\n\nOperator\nMagic Method\nBeschreibung\n\n\n\n\n==\n__eq__(self, other)\nGleichheit\n\n\n!=\n__ne__(self, other)\nUngleichheit\n\n\n&lt;\n__lt__(self, other)\nKleiner als\n\n\n&lt;=\n__le__(self, other)\nKleiner oder gleich\n\n\n&gt;\n__gt__(self, other)\nGrößer als\n\n\n&gt;=\n__ge__(self, other)\nGrößer oder gleich\n\n\n\nHinweis: Wenn __eq__(...) implementiert wird, nicht aber __ne__(...), funktioniert != automatisch als Negation von __eq__(...).\n\n\n\nÜbung:\nImplementieren Sie eine Klasse Vector, die Vektoren beliebiger Dimension repräsentiert und grundlegende Operationen der linearen Algebra mithilfe von Magic Methods unterstützt. Prüfen Sie bei allen Vektoroperationen, ob die Dimensionen übereinstimmen.\nAnforderungen:\n\nDer Konstruktor nimmt eine Liste von Zahlen entgegen (z. B. v = Vector([1, 2, 3])).\nImplementieren Sie eine String-Repräsentation, so dass print(v) aufgerufen werden kann.\n+, - soll Vektoren komponentenweise addieren.\n* soll ein Skalarprodukt zwischen zwei Vektoren realisieren.\nabs() soll die Euklidische Norm des Vektors, also seine Länge zurückgeben.\nDie Operatoren == und != sollen überprüfen, ob zwei Vektoren identisch sind.\nDie anderen Vergleichsoperatoren sollen sich auf die Länge der Vektoren beziehen.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Objektorientierte Programmierung (OOP)</span>"
    ]
  },
  {
    "objectID": "notebooks/8-oop.html#abstrakte-klassen",
    "href": "notebooks/8-oop.html#abstrakte-klassen",
    "title": "10  Objektorientierte Programmierung (OOP)",
    "section": "10.8 Abstrakte Klassen",
    "text": "10.8 Abstrakte Klassen\nAbstrakte Klassen sind spezielle Klassen, die man nicht direkt benutzen kann, um Objekte zu erstellen. Stattdessen dienen sie als Vorlage für andere Klassen. Sie definieren Methoden, die alle abgeleiteten Klassen verpflichtend selbst umsetzen müssen. Man könnte sagen: Die abstrakte Klasse gibt die Struktur für alle konkreten Klassen vor. Allerdings handelt es sich dabei um eine Art Basisstruktur, jede abgeleitete Klasse kann darüber hinaus weitere Attribute und Methoden anlegen.\nIm UML-Klassendiagramm kennzeichnen wir eine abstrakte Klasse durch ein &lt;&lt;abstract&gt;&gt; über dem Klassennamen (alternativ kann eine kursive Schrift für den Klassennamen verwendet werden, was aber leichter übersehen werden kann). Das folgende Beispiel illustriert das Konzept der abstrakten Klassen am Beispiel von geometrischen Figuren: Shape ist eine abstrakte Basisklasse mit zwei abstrakten Methoden, nämlich area() und perimeter() (Flächen- und Umfangsberechnung). Alle konkreten geometrischen Formen werden von dieser Basisklasse abgeleitet und müssen verpflichtend area() und perimeter() überschreiben. Dadurch wird ein einheitliches Design aller geometrischen Formen sichergestellt. Eine andere Sichtweise ist: Die abstrakte Klasse legt das Interface für die Benutzung der Klassen fest.\n\n\n\n\n\n\nAbbildung 10.6: UML-Klassendiagramm mit abstrakter Basisklasse\n\n\n\nIn Python nutzt man für die Umsetzung im Code das Modul abc (abstract class). Im folgenden Codebeispiel sehen wir, wie dies funktioniert:\n\nDie abstrakte Klasse wird von ABC abgeleitet.\nIhre Methoden werden mit einem sog. Decorator, @abstractmethod, als abstrakte Methoden markiert.\n\n\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        \"\"\"Flächeninhalt berechnen\"\"\"\n        pass\n\n    @abstractmethod\n    def perimeter(self):\n        \"\"\"Umfang berechnen\"\"\"\n        pass\n\nDie abstrakte Klasse Shape kann natürlich nichts berechnen (Welche Fläche?! Welchen Umfang?!), sie dient nur als eine Art “Bauplan” für alle konkreten Klassen, die nun von ihr abgeleitet werden:\n\nimport math\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self._width = width\n        self._height = height\n\n    def area(self):\n        return self._width * self._height\n\n    def perimeter(self):\n        return 2 * (self._width + self._height)\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self._radius = radius\n\n    def area(self):\n        return math.pi * self._radius ** 2\n\n    def perimeter(self):\n        return 2 * math.pi * self._radius\n\nclass Triangle(Shape):\n    def __init__(self, a, b, c):\n        self._a = a\n        self._b = b\n        self._c = c\n\n    def area(self):\n        # Heronsche Formel\n        s = self.perimeter() / 2\n        return math.sqrt(s * (s - self._a) * (s - self._b) * (s - self._c))\n\n    def perimeter(self):\n        return self._a + self._b + self._c\n\n# Test\n\nshapes = [\n    Rectangle(4, 5),\n    Circle(3),\n    Triangle(3, 4, 5)\n]\n\nfor shape in shapes:\n    print(f\"{shape.__class__.__name__}: Fläche = {shape.area():.2f}, Umfang = {shape.perimeter():.2f}\")\n\nRectangle: Fläche = 20.00, Umfang = 18.00\nCircle: Fläche = 28.27, Umfang = 18.85\nTriangle: Fläche = 6.00, Umfang = 12.00\n\n\nDurch die Verwendung des Moduls abc garantieren wir, dass die abstrakten Methoden vollständig implementiert werden müssen. Im folgenden verletzten wir diese Regel und definieren eine unvollständige Klasse Hexagon, die die abstrakte Methode perimeter nicht implementiert:\n\nclass Hexagon(Shape):\n    def __init__(self, side_length):\n        self._side_length = side_length\n\n    def area(self):\n        return (3 * math.sqrt(3) / 2) * self._side_length ** 2\n\nBeim Versuch ein Hexagon zu instanziieren, erhalten wir folgerichtig eine Fehlermeldung:\n\nhexagon = Hexagon(3.0)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[77], line 1\n----&gt; 1 hexagon = Hexagon(3.0)\n\nTypeError: Can't instantiate abstract class Hexagon with abstract method perimeter\n\n\n\n\nÜbungen:\n\nKorrigieren Sie die Klasse Hexagon und testen Sie sie.\nLeiten Sie von Rectangle eine Klasse Square ab. Müssen Sie die abstrakten Methoden erneut implementieren?\nRecherchieren Sie zu Decorators: Wie kann man mit einem Decorator eine statische Methode erstellen? Welche anderen Decorators gibt es?",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Objektorientierte Programmierung (OOP)</span>"
    ]
  }
]